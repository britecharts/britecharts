<html>
<head>
</head>
<body style="background: transparent;">
    <script src="scripts/docstrap.lib.js"></script>
    <script src="scripts/lunr.min.js"></script>
    <script src="scripts/fulltext-search.js"></script>

    <script type="text/x-docstrap-searchdb">
    {"bar.js.html":{"id":"bar.js.html","title":"Source: bar.js","body":" API BarBrushDonutLegendLineMini-tooltipSparklineStacked-areaStepTooltip Demos _CONTRIBUTING_GETTINGSTARTEDbarbrushdonutkitchen-sinklinesparklinestacked-areastep Global Global Source: bar.js define(function(require) { 'use strict'; const d3Array = require('d3-array'); const d3Axis = require('d3-axis'); const d3Dispatch = require('d3-dispatch'); const d3Scale = require('d3-scale'); const d3Selection = require('d3-selection'); const d3Transition = require('d3-transition'); const exportChart = require('./helpers/exportChart'); /** * @typedef BarChartData * @type {Object[]} * @property {Number} value Value of the group (required) * @property {String} name Name of the group (required) * * @example * [ * { * value: 1, * name: 'glittering' * }, * { * value: 1, * name: 'luminous' * } * ] */ /** * Bar Chart reusable API class that renders a * simple and configurable bar chart. * * @module Bar * @tutorial bar * @requires d3-array, d3-axis, d3-dispatch, d3-scale, d3-selection * * @example * var barChart = bar(); * * barChart * .height(500) * .width(800); * * d3Selection.select('.css-selector') * .datum(dataset) * .call(barChart); * */ return function module() { let margin = { top: 20, right: 20, bottom: 10, left: 40 }, width = 960, height = 500, data, chartWidth, chartHeight, xScale, yScale, numOfVerticalTicks = 5, numOfHorizontalTicks = 5, xAxis, yAxis, xAxisPadding = { top: 0, left: 0, bottom: 0, right: 0 }, horizontal = false, svg, valueLabel = 'value', nameLabel = 'name', maskGridLines, baseLine, // Dispatcher object to broadcast the mouse events // Ref: https://github.com/mbostock/d3/wiki/Internals#d3_dispatch dispatcher = d3Dispatch.dispatch('customMouseOver', 'customMouseOut', 'customMouseMove'), // extractors getName = ({name}) =&gt; name, getValue = ({value}) =&gt; value; /** * This function creates the graph using the selection as container * @param {D3Selection} _selection A d3 selection that represents * the container(s) where the chart(s) will be rendered * @param {BarChartData} _data The data to attach and generate the chart */ function exports(_selection){ _selection.each(function(_data){ chartWidth = width - margin.left - margin.right; chartHeight = height - margin.top - margin.bottom; data = cleanData(_data); buildScales(); buildAxis(); buildSVG(this); drawGridLines(); drawBars(); drawAxis(); }); } /** * Creates the d3 x and y axis, setting orientations * @private */ function buildAxis(){ if (!horizontal) { xAxis = d3Axis.axisBottom(xScale); yAxis = d3Axis.axisLeft(yScale) .ticks(numOfVerticalTicks, '%'); } else { xAxis = d3Axis.axisBottom(xScale) .ticks(numOfHorizontalTicks, '%') .tickSizeInner([-chartHeight]); yAxis = d3Axis.axisLeft(yScale); } } /** * Builds containers for the chart, the axis and a wrapper for all of them * Also applies the Margin convention * @private */ function buildContainerGroups(){ let container = svg.append('g') .classed('container-group', true) .attr('transform', `translate(${margin.left}, ${margin.top})`); container .append('g').classed('grid-lines-group', true); container .append('g').classed('chart-group', true); container .append('g').classed('x-axis-group axis', true); container .append('g').classed('y-axis-group axis', true); container .append('g').classed('metadata-group', true); } /** * Creates the x and y scales of the graph * @private */ function buildScales(){ if (!horizontal) { xScale = d3Scale.scaleBand() .domain(data.map(getName)) .rangeRound([0, chartWidth]) .padding(0.1); yScale = d3Scale.scaleLinear() .domain([0, d3Array.max(data, getValue)]) .rangeRound([chartHeight, 0]); } else { xScale = d3Scale.scaleLinear() .domain([0, d3Array.max(data, getValue)]) .rangeRound([0, chartWidth]); yScale = d3Scale.scaleBand() .domain(data.map(getName)) .rangeRound([chartHeight, 0]) .padding(0.1); } } /** * Builds the SVG element that will contain the chart * @param {HTMLElement} container DOM element that will work as the container of the graph * @private */ function buildSVG(container){ if (!svg) { svg = d3Selection.select(container) .append('svg') .classed('britechart bar-chart', true); buildContainerGroups(); } svg .attr('width', width + margin.left + margin.right) .attr('height', height + margin.top + margin.bottom); } /** * Cleaning data adding the proper format * @param {BarChartData} data Data * @private */ function cleanData(data) { return data.map((d) =&gt; { d.value = +d[valueLabel]; d.name = String(d[nameLabel]); return d; }); } /** * Draws the x and y axis on the svg object within their * respective groups * @private */ function drawAxis(){ svg.select('.x-axis-group.axis') .attr('transform', `translate(0, ${chartHeight})`) .call(xAxis); svg.select('.y-axis-group.axis') .call(yAxis); } /** * Draws the bars along the x axis * @param {D3Selection} bars Selection of bars * @return {void} */ function drawHorizontalBars(bars) { // Enter + Update bars.enter() .append('rect') .classed('bar', true) .attr('y', chartHeight) .attr('x', 0) .attr('height', yScale.bandwidth()) .attr('width', ({value}) =&gt; xScale(value)) .on('mouseover', function() { dispatcher.call('customMouseOver', this); }) .on('mousemove', function(d) { dispatcher.call('customMouseMove', this, d, d3Selection.mouse(this), [chartWidth, chartHeight]); }) .on('mouseout', function() { dispatcher.call('customMouseOut', this); }) .merge(bars) .attr('x', 0) .attr('y', ({name}) =&gt; yScale(name)) .attr('height', yScale.bandwidth()) .attr('width', ({value}) =&gt; xScale(value)); } /** * Draws the bars along the y axis * @param {D3Selection} bars Selection of bars * @return {void} */ function drawVerticalBars(bars) { // Enter + Update bars.enter() .append('rect') .classed('bar', true) .attr('x', chartWidth) .attr('y', ({value}) =&gt; yScale(value)) .attr('width', xScale.bandwidth()) .attr('height', ({value}) =&gt; chartHeight - yScale(value)) .on('mouseover', function() { dispatcher.call('customMouseOver', this); }) .on('mousemove', function(d) { dispatcher.call('customMouseMove', this, d, d3Selection.mouse(this), [chartWidth, chartHeight]); }) .on('mouseout', function() { dispatcher.call('customMouseOut', this); }) .merge(bars) .attr('x', ({name}) =&gt; xScale(name)) .attr('y', ({value}) =&gt; yScale(value)) .attr('width', xScale.bandwidth()) .attr('height', ({value}) =&gt; chartHeight - yScale(value)); } /** * Draws the bar elements within the chart group * @private */ function drawBars(){ let bars = svg.select('.chart-group').selectAll('.bar').data(data); if (!horizontal) { drawVerticalBars(bars); } else { drawHorizontalBars(bars) } // Exit bars.exit() .transition() .style('opacity', 0) .remove(); } /** * Draws grid lines on the background of the chart * @return void */ function drawGridLines(){ if (!horizontal) { drawVerticalGridLines(); } else { drawHorizontalGridLines(); } } /** * Draws the grid lines for an horizontal bar chart * @return {void} */ function drawHorizontalGridLines() { maskGridLines = svg.select('.grid-lines-group') .selectAll('line.vertical-grid-line') .data(xScale.ticks(4)) .enter() .append('line') .attr('class', 'vertical-grid-line') .attr('y1', (xAxisPadding.left)) .attr('y2', chartHeight) .attr('x1', (d) =&gt; xScale(d)) .attr('x2', (d) =&gt; xScale(d)) //draw a horizontal line to extend y-axis till the edges baseLine = svg.select('.grid-lines-group') .selectAll('line.extended-y-line') .data([0]) .enter() .append('line') .attr('class', 'extended-y-line') .attr('y1', (xAxisPadding.left)) .attr('y2', chartHeight) .attr('x1', 0) .attr('x2', 0); } /** * Draws the grid lines for a vertical bar chart * @return {void} */ function drawVerticalGridLines() { maskGridLines = svg.select('.grid-lines-group') .selectAll('line.horizontal-grid-line') .data(yScale.ticks(4)) .enter() .append('line') .attr('class', 'horizontal-grid-line') .attr('x1', (xAxisPadding.left)) .attr('x2', chartWidth) .attr('y1', (d) =&gt; yScale(d)) .attr('y2', (d) =&gt; yScale(d)) //draw a horizontal line to extend x-axis till the edges baseLine = svg.select('.grid-lines-group') .selectAll('line.extended-x-line') .data([0]) .enter() .append('line') .attr('class', 'extended-x-line') .attr('x1', (xAxisPadding.left)) .attr('x2', chartWidth) .attr('y1', height - margin.bottom - margin.top) .attr('y2', height - margin.bottom - margin.top); } /** * Chart exported to png and a download action is fired * @public */ exports.exportChart = function(filename) { exportChart.call(exports, svg, filename); }; /** * Gets or Sets the height of the chart * @param {number} _x Desired width for the graph * @return { height | module} Current height or Bar Chart module to chain calls * @public */ exports.height = function(_x) { if (!arguments.length) { return height; } height = _x; return this; }; /** * Gets or Sets the margin of the chart * @param {object} _x Margin object to get/set * @return { margin | module} Current margin or Bar Chart module to chain calls * @public */ exports.margin = function(_x) { if (!arguments.length) { return margin; } margin = _x; return this; }; /** * Gets or Sets the width of the chart * @param {number} _x Desired width for the graph * @return { width | module} Current width or Bar Chart module to chain calls * @public */ exports.width = function(_x) { if (!arguments.length) { return width; } width = _x; return this; }; /** * Gets or Sets the horizontal direction of the chart * @param {number} _x Desired horizontal direction for the graph * @return { horizontal | module} Current horizontal direction or Bar Chart module to chain calls * @public */ exports.horizontal = function(_x) { if (!arguments.length) { return horizontal; } horizontal = _x; return this; }; /** * Exposes an 'on' method that acts as a bridge with the event dispatcher * We are going to expose this events: * customMouseOver, customMouseMove and customMouseOut * * @return {module} Bar Chart * @public */ exports.on = function() { let value = dispatcher.on.apply(dispatcher, arguments); return value === dispatcher ? exports : value; }; /** * Chart exported to png and a download action is fired * @public */ exports.exportChart = function(filename, title) { exportChart.call(exports, svg, filename, title); }; return exports; }; }); × Search results Close "},"brush.js.html":{"id":"brush.js.html","title":"Source: brush.js","body":" API BarBrushDonutLegendLineMini-tooltipSparklineStacked-areaStepTooltip Demos _CONTRIBUTING_GETTINGSTARTEDbarbrushdonutkitchen-sinklinesparklinestacked-areastep Global Global Source: brush.js define(function(require) { 'use strict'; const d3Array = require('d3-array'); const d3Axis = require('d3-axis'); const d3Brush = require('d3-brush'); const d3Ease = require('d3-ease'); const d3Scale = require('d3-scale'); const d3Shape = require('d3-shape'); const d3Selection = require('d3-selection'); const d3Time = require('d3-time'); const d3TimeFormat = require('d3-time-format'); const d3Transition = require('d3-transition'); const colorHelper = require('./helpers/colors'); /** * @typedef BrushChartData * @type {Object[]} * @property {Number} value Value to chart (required) * @property {Date} date Date of the value (required) * * @example * [ * { * value: 1, * date: '2011-01-06T00:00:00Z' * }, * { * value: 2, * date: '2011-01-07T00:00:00Z' * } * ] */ /** * Brush Chart reusable API class that renders a * simple and configurable brush chart. * * @module Brush * @tutorial brush * @requires d3-array, d3-axis, d3-brush, d3-ease, d3-scale, d3-shape, d3-selection, d3-time, d3-time-format * * @example * let brushChart = brush(); * * brushChart * .height(500) * .width(800); * * d3Selection.select('.css-selector') * .datum(dataset) * .call(brushChart); * */ return function module() { let margin = { top: 20, right: 20, bottom: 30, left: 20 }, width = 960, height = 500, data, svg, ease = d3Ease.easeQuadOut, dateLabel = 'date', valueLabel = 'value', chartWidth, chartHeight, xScale, yScale, xAxis, brush, chartBrush, handle, onBrush = null, gradient = colorHelper.colorGradients.greenBlueGradient, // formats defaultTimeFormat = '%m/%d/%Y', xTickMonthFormat = d3TimeFormat.timeFormat('%b'), // extractors getValue = ({value}) =&gt; value, getDate = ({date}) =&gt; date; /** * This function creates the graph using the selection as container * @param {D3Selection} _selection A d3 selection that represents * the container(s) where the chart(s) will be rendered * @param {BrushChartData} _data The data to attach and generate the chart */ function exports(_selection){ _selection.each(function(_data){ chartWidth = width - margin.left - margin.right; chartHeight = height - margin.top - margin.bottom; data = cleanData(cloneData(_data)); buildScales(); buildAxis(); buildSVG(this); buildGradient(); buildBrush(); drawArea(); drawAxis(); drawBrush(); drawHandles(); // This last step is optional, just needed when // a given selection would need to be shown setBrush(0.25, 0.5); }); } /** * Creates the d3 x axis, setting orientation * @private */ function buildAxis(){ xAxis = d3Axis.axisBottom(xScale) .tickFormat(xTickMonthFormat); } /** * Creates the brush element and attaches a listener * @return {void} */ function buildBrush() { brush = d3Brush.brushX() .extent([[0, 0], [chartWidth, chartHeight]]) .on('brush', handleBrush) .on('end', handleBrushEnded); } /** * Builds containers for the chart, the axis and a wrapper for all of them * Also applies the Margin convention * @private */ function buildContainerGroups(){ let container = svg.append('g') .classed('container-group', true) .attr('transform', `translate(${margin.left}, ${margin.top})`); container .append('g') .classed('chart-group', true); container .append('g') .classed('metadata-group', true); container .append('g') .classed('x-axis-group', true); container .append('g') .classed('brush-group', true); } /** * Creates the gradient on the area * @return {void} */ function buildGradient() { let metadataGroup = svg.select('.metadata-group'); metadataGroup.append('linearGradient') .attr('id', 'brush-area-gradient') .attr('gradientUnits', 'userSpaceOnUse') .attr('x1', 0) .attr('x2', xScale(data[data.length - 1].date)) .attr('y1', 0) .attr('y2', 0) .selectAll('stop') .data([ {offset: '0%', color: gradient[0]}, {offset: '100%', color: gradient[1]} ]) .enter().append('stop') .attr('offset', ({offset}) =&gt; offset) .attr('stop-color', ({color}) =&gt; color); } /** * Creates the x and y scales of the graph * @private */ function buildScales(){ xScale = d3Scale.scaleTime() .domain(d3Array.extent(data, getDate )) .range([0, chartWidth]); yScale = d3Scale.scaleLinear() .domain([0, d3Array.max(data, getValue)]) .range([chartHeight, 0]); } /** * Builds the SVG element that will contain the chart * @param {HTMLElement} container DOM element that will work as the container of the graph * @private */ function buildSVG(container){ if (!svg) { svg = d3Selection.select(container) .append('svg') .classed('britechart brush-chart', true); buildContainerGroups(); } svg .transition() .ease(ease) .attr('width', width) .attr('height', height); } /** * Cleaning data adding the proper format * * @param {BrushChartData} data Data */ function cleanData(data) { let parseDate = d3TimeFormat.timeParse(defaultTimeFormat); return data.map(function (d) { d.date = parseDate(d[dateLabel]); d.value = +d[valueLabel]; return d; }); } /** * Clones the passed array of data * @param {Object[]} dataToClone Data to clone * @return {Object[]} Cloned data */ function cloneData(dataToClone) { return JSON.parse(JSON.stringify(dataToClone)); } /** * Draws the x axis on the svg object within its group * * @private */ function drawAxis(){ svg.select('.x-axis-group') .append('g') .attr('class', 'x axis') .attr('transform', `translate(0, ${chartHeight})`) .call(xAxis); } /** * Draws the area that is going to represent the data * * @return {void} */ function drawArea() { // Create and configure the area generator let area = d3Shape.area() .x(({date}) =&gt; xScale(date)) .y0(chartHeight) .y1(({value}) =&gt; yScale(value)) .curve(d3Shape.curveBasis); // Create the area path svg.select('.chart-group') .append('path') .datum(data) .attr('class', 'brush-area') .attr('d', area); } /** * Draws the Brush components on its group * @return {void} */ function drawBrush() { chartBrush = svg.select('.brush-group') .call(brush); // Update the height of the brushing rectangle chartBrush.selectAll('rect') .classed('brush-rect', true) .attr('height', chartHeight); } /** * Draws a handle for the Brush section * @return {void} */ function drawHandles() { let handleFillColor = colorHelper.colorSchemasHuman.britechartsGreySchema[1]; // Styling handle = chartBrush .selectAll('.handle.brush-rect') .style('fill', handleFillColor); } /** * When a brush event happens, we can extract info from the extension * of the brush. * * @return {void} */ function handleBrush() { let s = d3Selection.event.selection, dateExtent = s.map(xScale.invert); if (typeof onBrush === 'function') { onBrush.call(null, dateExtent); } // updateHandlers(dateExtent); } /** * Processes the end brush event, snapping the boundaries to days * as showed on the example on https://bl.ocks.org/mbostock/6232537 * @return {void} * @private */ function handleBrushEnded() { if (!d3Selection.event.sourceEvent) return; // Only transition after input. if (!d3Selection.event.selection) return; // Ignore empty selections. let d0 = d3Selection.event.selection.map(xScale.invert), d1 = d0.map(d3Time.timeDay.round); // If empty when rounded, use floor &amp; ceil instead. if (d1[0] &gt;= d1[1]) { d1[0] = d3Time.timeDay.floor(d0[0]); d1[1] = d3Time.timeDay.offset(d1[0]); } d3Selection.select(this) .transition() .call(d3Selection.event.target.move, d1.map(xScale)); } /** * Sets a new brush extent within the passed percentage positions * @param {Number} a Percentage of data that the brush start with * @param {Number} b Percentage of data that the brush ends with */ function setBrush(a, b) { let x0 = a * chartWidth, x1 = b * chartWidth; brush .move(chartBrush, [x0, x1]); } /** * Updates visibility and position of the brush handlers * @param {Number[]} dateExtent Date range * @return {void} */ function updateHandlers(dateExtent) { if (dateExtent == null) { handle.attr('display', 'none'); } else { handle .attr('display', null) .attr('transform', function(d, i) { return `translate(${dateExtent[i]},${chartHeight / 2})`; }); } } /** * Gets or Sets the gradient of the chart * @param {String[]} _x Desired gradient for the graph * @return { gradient | module} Current gradient or Chart module to chain calls * @public */ exports.gradient = function(_x) { if (!arguments.length) { return gradient; } gradient = _x; return this; }; /** * Gets or Sets the height of the chart * @param {number} _x Desired width for the graph * @return { height | module} Current height or Chart module to chain calls * @public */ exports.height = function(_x) { if (!arguments.length) { return height; } height = _x; return this; }; /** * Gets or Sets the margin of the chart * @param {object} _x Margin object to get/set * @return { margin | module} Current margin or Chart module to chain calls * @public */ exports.margin = function(_x) { if (!arguments.length) { return margin; } margin = _x; return this; }; /** * Gets or Sets the callback that will be called when the user brushes over the area * @param {Function} _x Callback to call * @return {Function | module} Current callback function or the Chart Module */ exports.onBrush = function(_x) { if (!arguments.length) return onBrush; onBrush = _x; return this; }; /** * Gets or Sets the width of the chart * @param {number} _x Desired width for the graph * @return { width | module} Current width or Chart module to chain calls * @public */ exports.width = function(_x) { if (!arguments.length) { return width; } width = _x; return this; }; return exports; }; }); × Search results Close "},"line.js.html":{"id":"line.js.html","title":"Source: line.js","body":" API BarBrushDonutLegendLineMini-tooltipSparklineStacked-areaStepTooltip Demos _CONTRIBUTING_GETTINGSTARTEDbarbrushdonutkitchen-sinklinesparklinestacked-areastep Global Global Source: line.js define(function(require){ 'use strict'; const d3Array = require('d3-array'); const d3Axis = require('d3-axis'); const d3Dispatch = require('d3-dispatch'); const d3Ease = require('d3-ease'); const d3Format = require('d3-format'); const d3Scale = require('d3-scale'); const d3Shape = require('d3-shape'); const d3Selection = require('d3-selection'); const d3Time = require('d3-time'); const d3TimeFormat = require('d3-time-format'); const d3Transition = require('d3-transition'); const colorHelper = require('./helpers/colors'); const exportChart = require('./helpers/exportChart'); const { axisTimeCombinations, lineGradientId, timeBenchmarks } = require('./helpers/constants.js'); /** * @typedef D3Selection * @type {Array[]} * @property {Number} length Size of the selection * @property {DOMElement} parentNode Parent of the selection */ /** * @typedef lineChartPointByTopic * @type {Object} * @property {Object[]} Data All data entries for a given topic (required) * @property {Number} topic Topic identifier (required) * @property {String} topicName Topic name (required) * * @example * { * Data: [ * { * date: '', * fullDate: '2017-01-16T16:00:00-08:00', * value: 1 * }, * { * date: '', * fullDate: '2017-01-16T17:00:00-08:00', * value: 2 * } * ], * topic: 123, * topicName: 'San Francisco' * } */ /** * @typedef lineChartPointByDate * @type {Object} * @property {Date} date Date value (required) * @property {Object[]} topics Data entries for that day (required) * * @example * { * date: '2017-01-16T16:00:00-08:00' * topics: [ * { * name: 123, * topicName: 'San Francisco', * value: 1 * }, * { * name: 345, * topicName: 'Other', * value: 2 * } * ] * } */ /** * @typedef LineChartData * @type {Object[]} * @property {lineChartPointByTopic[]} data Data values to chart (required) * @property {lineChartPointByDate[]} dataByDate Data values to chart ordered by date (required) * * @example * { * data: [ * { * Data: [ * { * date: '', * fullDate: '2017-01-16T16:00:00-08:00', * value: 1 * }, * { * date: '', * fullDate: '2017-01-16T17:00:00-08:00', * value: 2 * } * ], * topic: 123, * topicName: 'San Francisco' * }, * { * Data: [ * {...}, * {...} * ], * topic: 345, * topicName: 'Other' * } * ], * dataByDate: [ * { * date: '2017-01-16T16:00:00-08:00', * topics: [ * { * name: 123, * topicName: 'San Francisco', * value: 1 * }, * { * name: 345, * topicName: 'Other', * value: 2 * } * ] * }, * {...} * ] * } */ /** * Line Chart reusable API module that allows us * rendering a multi line and configurable chart. * * @module Line * @tutorial line * @requires d3-array, d3-axis, d3-brush, d3-ease, d3-format, d3-scale, d3-shape, d3-selection, d3-time, d3-time-format * * @example * let lineChart = line(); * * lineChart * .aspectRatio(0.5) * .width(500); * * d3Selection.select('.css-selector') * .datum(dataset) * .call(lineChart); * */ return function line() { let margin = { top: 60, right: 30, bottom: 40, left: 70 }, width = 960, height = 500, aspectRatio = null, tooltipThreshold = 480, svg, chartWidth, chartHeight, xScale, yScale, colorScale, xAxis, xMonthAxis, yAxis, xAxisPadding = { top: 0, left: 15, bottom: 0, right: 0 }, tickPadding = 5, colorSchema = colorHelper.colorSchemas.britechartsColorSchema, singleLineGradientColors = colorHelper.colorGradients.greenBlueGradient, topicColorMap, defaultAxisSettings = axisTimeCombinations.DAY_MONTH, forceAxisSettings = null, singleTickWidth = 20, horizontalTickSpacing = 40, ease = d3Ease.easeQuadInOut, animationDuration = 1500, data, dataByDate, numVerticalTics = 5, defaultNumMonths = 10, overlay, overlayColor = 'rgba(0, 0, 0, 0)', verticalMarkerContainer, verticalMarkerLine, maskGridLines, baseLine, // extractors getDate = ({date}) =&gt; date, getValue = ({value}) =&gt; value, getTopic = ({topic}) =&gt; topic, getLineColor = ({topic}) =&gt; colorScale(topic), // formats yTickNumberFormat = d3Format.format('.3'), xTickHourFormat = d3TimeFormat.timeFormat('%H %p'), xTickDateFormat = d3TimeFormat.timeFormat('%e'), xTickMonthFormat = d3TimeFormat.timeFormat('%b'), xTickYearFormat = d3TimeFormat.timeFormat('%Y'), // events dispatcher = d3Dispatch.dispatch('customMouseOver', 'customMouseOut', 'customMouseMove'); const formatMap = { hour: xTickHourFormat, day: xTickDateFormat, month: xTickMonthFormat }; /** * This function creates the graph using the selection and data provided * * @param {D3Selection} _selection A d3 selection that represents * the container(s) where the chart(s) will be rendered * @param {LineChartData} _data The data to attach and generate the chart */ function exports(_selection) { _selection.each(function(_data) { ({ data, dataByDate } = cleanData(_data)); chartWidth = width - margin.left - margin.right; chartHeight = height - margin.top - margin.bottom; buildScales(); buildAxis(); buildSVG(this); drawGridLines(); drawAxis(); buildGradient(); drawLines(); if (shouldShowTooltip()) { drawVerticalMarker(); drawHoverOverlay(); addMouseEvents(); } }); } /** * Adds events to the container group if the environment is not mobile * Adding: mouseover, mouseout and mousemove */ function addMouseEvents() { svg .on('mouseover', handleMouseOver) .on('mouseout', handleMouseOut) .on('mousemove', handleMouseMove); } /** * Adjusts the position of the y axis' ticks * @param {D3Selection} selection Y axis group * @return void */ function adjustYTickLabels(selection) { selection.selectAll('.tick text') .attr('transform', 'translate(0, -7)'); } /** * Returns tick object to be used when building the x axis * @return {object} tick settings for major and minr axis */ function getXAxisSettings() { let settings = forceAxisSettings || defaultAxisSettings; let minorTickValue, majorTickValue; let dateTimeSpan = xScale.domain()[1] - xScale.domain()[0]; let { ONE_AND_A_HALF_YEARS, ONE_DAY } = timeBenchmarks; // might want to add minute-hour if (dateTimeSpan &lt; ONE_DAY) { settings = axisTimeCombinations.HOUR_DAY; majorTickValue = d3Time.timeDay.every(1); } else if (dateTimeSpan &lt; ONE_AND_A_HALF_YEARS) { settings = axisTimeCombinations.DAY_MONTH; majorTickValue = d3Time.timeMonth.every(1); } else { settings = axisTimeCombinations.MONTH_YEAR; minorTickValue = 10; majorTickValue = d3Time.timeYear.every(1); } let [minor, major] = settings.split('-'); minorTickValue = dataByDate.length &lt; 5 ? d3Time.timeDay : getMaxNumOfHorizontalTicks(width, dataByDate.length); return { minor: { format: formatMap[minor], tick: minorTickValue, }, major: { format: formatMap[major], tick: majorTickValue, } }; } /** * Creates the d3 x and y axis, setting orientations * @private */ function buildAxis() { let rangeDiff = yScale.domain()[1] - yScale.domain()[0]; let yTickNumber = rangeDiff &lt; numVerticalTics - 1 ? rangeDiff : numVerticalTics; let {minor, major} = getXAxisSettings(); xAxis = d3Axis.axisBottom(xScale) .ticks(minor.tick) .tickSize(10, 0) .tickPadding(tickPadding) .tickFormat(minor.format); xMonthAxis = d3Axis.axisBottom(xScale) .ticks(major.tick) .tickSize(0, 0) .tickFormat(major.format); yAxis = d3Axis.axisLeft(yScale) .ticks(yTickNumber) .tickSize([0]) .tickPadding(tickPadding) .tickFormat(yTickNumberFormat); } /** * Builds containers for the chart, the axis and a wrapper for all of them * NOTE: The order of drawing of this group elements is really important, * as everything else will be drawn on top of them * @private */ function buildContainerGroups(){ let container = svg.append('g') .classed('container-group', true) .attr('transform', `translate(${margin.left},${margin.top})`); container .append('g').classed('x-axis-group', true) .append('g').classed('axis x', true); container.selectAll('.x-axis-group') .append('g').classed('month-axis', true); container .append('g').classed('y-axis-group axis y', true); container .append('g').classed('grid-lines-group', true); container .append('g').classed('chart-group', true); container .append('g').classed('metadata-group', true); } /** * Builds the gradient element to be used later * @return {void} */ function buildGradient() { svg.select('.metadata-group') .append('linearGradient') .attr('id', lineGradientId) .attr('x1', '0%') .attr('y1', '0%') .attr('x2', '100%') .attr('y2', '0%') .selectAll('stop') .data([ {offset:'0%', color: singleLineGradientColors[0]}, {offset:'100%', color: singleLineGradientColors[1]} ]) .enter() .append('stop') .attr('offset', ({offset}) =&gt; offset) .attr('stop-color', ({color}) =&gt; color) } /** * Creates the x and y scales of the graph * @private */ function buildScales(){ let minX = d3Array.min(data, ({Data}) =&gt; d3Array.min(Data, getDate)), maxX = d3Array.max(data, ({Data}) =&gt; d3Array.max(Data, getDate)), minY = d3Array.min(data, ({Data}) =&gt; d3Array.min(Data, getValue)), maxY = d3Array.max(data, ({Data}) =&gt; d3Array.max(Data, getValue)); xScale = d3Scale.scaleTime() .rangeRound([0, chartWidth]) .domain([minX, maxX]); yScale = d3Scale.scaleLinear() .rangeRound([chartHeight, 0]) .domain([Math.abs(minY), Math.abs(maxY)]) .nice(3); colorScale = d3Scale.scaleOrdinal() .range(colorSchema) .domain(data.map(getTopic)); // TODO add spread and rest operators to britecharts /* let range = colorScale.range(); topicColorMap = colorScale.domain().reduce((memo, item, i) =&gt; ({...memo, [item]: range[i], }), {}); */ let range = colorScale.range(); topicColorMap = colorScale.domain().reduce((memo, item, i) =&gt; { memo[item] = range[i]; return memo; }, {}); } /** * Builds the SVG element that will contain the chart * * @param {HTMLElement} container DOM element that will work as the container of the graph * @private */ function buildSVG(container){ if (!svg) { svg = d3Selection.select(container) .append('svg') .classed('britechart line-chart', true); buildContainerGroups(); } svg .attr('width', width) .attr('height', height); } /** * Parses dates and values into JS Date objects and numbers * @param {obj} data Raw data * @param {obj} dataByDate Raw data ordered by date * @return {obj} Parsed data with dates */ function cleanData({data, dataByDate}) { data.forEach(function(kv) { kv.Data.forEach(function(d) { d.date = new Date(d.fullDate); }); }); dataByDate.forEach((entry) =&gt; entry.date = new Date(entry.date)); return { data, dataByDate}; } /** * Removes all the datapoints highlighter circles added to the marker container * @return void */ function cleanDataPointHighlights(){ verticalMarkerContainer.selectAll('.circle-container').remove(); } /** * Draws the x and y axis on the svg object within their * respective groups * @private */ function drawAxis(){ svg.select('.x-axis-group .axis.x') .attr('transform', `translate(0, ${chartHeight})`) .call(xAxis); svg.select('.x-axis-group .month-axis') .attr('transform', `translate(0, ${(chartHeight + 28)})`) .call(xMonthAxis); svg.select('.y-axis-group.axis.y') .transition() .ease(ease) .attr('transform', `translate(${-xAxisPadding.left}, 0)`) .call(yAxis) .call(adjustYTickLabels); } /** * Draws the line elements within the chart group * @private */ function drawLines(){ let lines, topicLine, maskingRectangle; topicLine = d3Shape.line() .x(({date}) =&gt; xScale(date)) .y(({value}) =&gt; yScale(value)); lines = svg.select('.chart-group').selectAll('.line') .data(data); lines.enter() .append('g') .attr('class', 'topic') .append('path') .attr('class', 'line') .attr('d', ({Data}) =&gt; topicLine(Data)) .style('stroke', (d) =&gt; ( data.length === 1 ? `url(#${lineGradientId})` : getLineColor(d) )); lines .exit() .remove(); // We use a white rectangle to simulate the line drawing animation maskingRectangle = svg.append('rect') .attr('class', 'masking-rectangle') .attr('width', width) .attr('height', height) .attr('x', 0) .attr('y', 0); maskingRectangle.transition() .duration(animationDuration) .ease(ease) .attr('x', width) .on('end', () =&gt; maskingRectangle.remove()); } /** * Draws grid lines on the background of the chart * @return void */ function drawGridLines(){ maskGridLines = svg.select('.grid-lines-group') .selectAll('line.horizontal-grid-line') .data(yScale.ticks(5)) .enter() .append('line') .attr('class', 'horizontal-grid-line') .attr('x1', (-xAxisPadding.left - 30)) .attr('x2', chartWidth) .attr('y1', (d) =&gt; yScale(d)) .attr('y2', (d) =&gt; yScale(d)); //draw a horizontal line to extend x-axis till the edges baseLine = svg.select('.grid-lines-group') .selectAll('line.extended-x-line') .data([0]) .enter() .append('line') .attr('class', 'extended-x-line') .attr('x1', (-xAxisPadding.left - 30)) .attr('x2', chartWidth) .attr('y1', height - margin.bottom - margin.top) .attr('y2', height - margin.bottom - margin.top); } /** * Draws an overlay element over the graph * @inner * @return void */ function drawHoverOverlay(){ overlay = svg.select('.metadata-group') .append('rect') .attr('class','overlay') .attr('y1', 0) .attr('y2', height) .attr('height', height - margin.top - margin.bottom) .attr('width', width - margin.left - margin.right) .attr('fill', overlayColor) .style('display', 'none'); } /** * Creates the vertical marker * @return void */ function drawVerticalMarker(){ verticalMarkerContainer = svg.select('.metadata-group') .append('g') .attr('class', 'hover-marker vertical-marker-container') .attr('transform', 'translate(9999, 0)'); verticalMarkerLine = verticalMarkerContainer.selectAll('path') .data([{ x1: 0, y1: 0, x2: 0, y2: 0 }]) .enter() .append('line') .classed('vertical-marker', true) .attr('x1', 0) .attr('y1', height - margin.top - margin.bottom) .attr('x2', 0) .attr('y2', 0); } /** * Finds out which datapoint is closer to the given x position * @param {Number} x0 Date value for data point * @param {Object} d0 Previous datapoint * @param {Object} d1 Next datapoint * @return {Object} d0 or d1, the datapoint with closest date to x0 */ function findOutNearestDate(x0, d0, d1){ return (new Date(x0).getTime() - new Date(d0.date).getTime()) &gt; (new Date(d1.date).getTime() - new Date(x0).getTime()) ? d0 : d1; } /** * Calculates the maximum number of ticks for the x axis * @param {Number} width Chart width * @param {Number} dataPointNumber Number of entries on the data * @return {Number} Number of ticks to render */ function getMaxNumOfHorizontalTicks(width, dataPointNumber) { let ticksForWidth = Math.ceil(width / (singleTickWidth + horizontalTickSpacing)); return Math.min(dataPointNumber, ticksForWidth); } /** * Extract X position on the graph from a given mouse event * @param {Object} event D3 mouse event * @return {Number} Position on the x axis of the mouse */ function getMouseXPosition(event) { return d3Selection.mouse(event)[0]; } /** * Finds out the data entry that is closer to the given position on pixels * @param {Number} mouseX X position of the mouse * @return {Object} Data entry that is closer to that x axis position */ function getNearestDataPoint(mouseX) { let dateFromInvertedX = xScale.invert(mouseX); let bisectDate = d3Array.bisector(getDate).left; let dataEntryIndex = bisectDate(dataByDate, dateFromInvertedX, 1); let dataEntryForXPosition = dataByDate[dataEntryIndex]; let previousDataEntryForXPosition = dataByDate[dataEntryIndex - 1]; let nearestDataPoint; if (previousDataEntryForXPosition &amp;&amp; dataEntryForXPosition) { nearestDataPoint = findOutNearestDate(dateFromInvertedX, dataEntryForXPosition, previousDataEntryForXPosition); } else { nearestDataPoint = dataEntryForXPosition; } return nearestDataPoint; } /** * MouseMove handler, calculates the nearest dataPoint to the cursor * and updates metadata related to it * @private */ function handleMouseMove(){ let xPositionOffset = -margin.left, //Arbitrary number, will love to know how to assess it dataPoint = getNearestDataPoint(getMouseXPosition(this) + xPositionOffset), dataPointXPosition; if (dataPoint) { dataPointXPosition = xScale(new Date(dataPoint.date)); // More verticalMarker to that datapoint moveVerticalMarker(dataPointXPosition); // Add data points highlighting highlightDataPoints(dataPoint); // Emit event with xPosition for tooltip or similar feature dispatcher.call('customMouseMove', this, dataPoint, topicColorMap, dataPointXPosition); } } /** * MouseOut handler, hides overlay and removes active class on verticalMarkerLine * It also resets the container of the vertical marker * @private */ function handleMouseOut(data){ overlay.style('display', 'none'); verticalMarkerLine.classed('bc-is-active', false); verticalMarkerContainer.attr('transform', 'translate(9999, 0)'); dispatcher.call('customMouseOut', this, data); } /** * Mouseover handler, shows overlay and adds active class to verticalMarkerLine * @private */ function handleMouseOver(data){ overlay.style('display', 'block'); verticalMarkerLine.classed('bc-is-active', true); dispatcher.call('customMouseOver', this, data); } /** * Creates coloured circles marking where the exact data y value is for a given data point * @param {Object} dataPoint Data point to extract info from * @private */ function highlightDataPoints(dataPoint) { cleanDataPointHighlights(); // sorting the topics based on the order of the colors, // so that the order always stays constant dataPoint.topics = dataPoint.topics .filter(t =&gt; !!t) .sort((a, b) =&gt; topicColorMap[a.name] &gt; topicColorMap[b.name]); dataPoint.topics.forEach(({name}, index) =&gt; { let marker = verticalMarkerContainer .append('g') .classed('circle-container', true), circleSize = 12; marker.append('circle') .classed('data-point-highlighter', true) .attr('cx', circleSize) .attr('cy', 0) .attr('r', 5) .style('stroke', topicColorMap[name]); marker.attr('transform', `translate( ${(- circleSize)}, ${(yScale(dataPoint.topics[index].value))} )` ); }); } /** * Helper method to update the x position of the vertical marker * @param {Object} dataPoint Data entry to extract info * @return void */ function moveVerticalMarker(verticalMarkerXPosition){ verticalMarkerContainer.attr('transform', `translate(${verticalMarkerXPosition},0)`); } /** * Determines if we should add the tooltip related logic depending on the * size of the chart and the tooltipThreshold variable value * @return {Boolean} Should we build the tooltip? */ function shouldShowTooltip() { return width &gt; tooltipThreshold; } // API Methods /** * Gets or Sets the aspect ratio of the chart * @param {Number} _x Desired aspect ratio for the graph * @return { (Number | Module) } Current aspect ratio or Line Chart module to chain calls * @public */ exports.aspectRatio = function(_x) { if (!arguments.length) { return aspectRatio; } aspectRatio = _x; return this; }; /** * Gets or Sets the colorSchema of the chart * @param {String[]} _x Desired colorSchema for the graph * @return { colorSchema | module} Current colorSchema or Chart module to chain calls * @public */ exports.colorSchema = function(_x) { if (!arguments.length) { return colorSchema; } colorSchema = _x; return this; }; /** * Gets or Sets the height of the chart * @param {Number} _x Desired width for the graph * @return { (Number | Module) } Current height or Line Chart module to chain calls * @public */ exports.height = function(_x) { if (!arguments.length) { return height; } if (aspectRatio) { width = Math.ceil(_x / aspectRatio); } height = _x; return this; }; /** * Gets or Sets the margin of the chart * @param {Object} _x Margin object to get/set * @return { (Number | Module) } Current margin or Line Chart module to chain calls * @public */ exports.margin = function(_x) { if (!arguments.length) { return margin; } margin = _x; return this; }; /** * Gets or Sets the minimum width of the graph in order to show the tooltip * NOTE: This could also depend on the aspect ratio * @param {Number} _x Desired tooltip threshold for the graph * @return { (Number | Module) } Current tooltip threshold or Line Chart module to chain calls * @public */ exports.tooltipThreshold = function(_x) { if (!arguments.length) { return tooltipThreshold; } tooltipThreshold = _x; return this; }; /** * Gets or Sets the width of the chart * @param {Number} _x Desired width for the graph * @return { (Number | Module) } Current width or Line Chart module to chain calls * @public */ exports.width = function(_x) { if (!arguments.length) { return width; } if (aspectRatio) { height = Math.ceil(_x * aspectRatio); } width = _x; return this; }; /** * Chart exported to png and a download action is fired * @public */ exports.exportChart = function(filename, title) { exportChart.call(exports, svg, filename, title); }; /** * Exposes an 'on' method that acts as a bridge with the event dispatcher * We are going to expose this events: * customMouseHover, customMouseMove and customMouseOut * * @return {module} Bar Chart * @public */ exports.on = function() { let value = dispatcher.on.apply(dispatcher, arguments); return value === dispatcher ? exports : value; }; /** * Exposes the ability to force the chart to show a certain x axis grouping * @param {String} _x Desired format * @return { (String|Module) } Current format or module to chain calls */ exports.forceAxisFormat = function(_x) { if (!arguments.length) { return forceAxisSettings || defaultAxisSettings; } forceAxisSettings = _x; return this; }; /** * constants to be used to force the x axis to respect a certain granularity * current options: HOUR_DAY, DAY_MONTH, MONTH_YEAR * @example line.forceAxisFormat(line.axisTimeCombinations.HOUR_DAY) */ exports.axisTimeCombinations = axisTimeCombinations; return exports; }; }); × Search results Close "},"donut.js.html":{"id":"donut.js.html","title":"Source: donut.js","body":" API BarBrushDonutLegendLineMini-tooltipSparklineStacked-areaStepTooltip Demos _CONTRIBUTING_GETTINGSTARTEDbarbrushdonutkitchen-sinklinesparklinestacked-areastep Global Global Source: donut.js define(function(require){ 'use strict'; const d3Dispatch = require('d3-dispatch'); const d3Ease = require('d3-ease'); const d3Interpolate = require('d3-interpolate'); const d3Scale = require('d3-scale'); const d3Shape = require('d3-shape'); const d3Selection = require('d3-selection'); const d3Transition = require('d3-transition'); const exportChart = require('./helpers/exportChart'); const textHelper = require('./helpers/text'); const colorHelper = require('./helpers/colors'); /** * @typedef DonutChartData * @type {Object[]} * @property {Number} quantity Quantity of the group (required) * @property {Number} percentage Percentage of the total (required) * @property {String} name Name of the group (required) * @property {Number} id Identifier for the group required for legend feature (optional) * * @example * [ * { * quantity: 1, * percentage: 50, * name: 'glittering', * id: 1 * }, * { * quantity: 1, * percentage: 50, * name: 'luminous', * id: 2 * } * ] */ /** * Reusable Donut Chart API class that renders a * simple and configurable donut chart. * * @module Donut * @tutorial donut * @requires d3-dispatch, d3-ease, d3-interpolate, d3-scale, d3-shape, d3-selection * * @example * var donutChart = donut(); * * donutChart * .externalRadius(500) * .internalRadius(200); * * d3Selection.select('.css-selector') * .datum(dataset) * .call(donutChart); * */ return function module() { let margin = { top: 0, right: 0, bottom: 0, left: 0 }, width = 300, height = 300, ease = d3Ease.easeCubicInOut, arcTransitionDuration = 750, pieDrawingTransitionDuration = 1200, pieHoverTransitionDuration = 150, radiusHoverOffset = 12, paddingAngle = 0.016, data, chartWidth, chartHeight, externalRadius = 140, internalRadius = 45.5, legendWidth = externalRadius + internalRadius, layout, shape, slices, svg, quantityLabel = 'quantity', nameLabel = 'name', percentageLabel = 'percentage', // colors colorScale = d3Scale.schemeCategory20c, colorSchema = colorHelper.colorSchemas.britechartsColorSchema, // utils storeAngle = function(d) { this._current = d; }, reduceOuterRadius = d =&gt; { d.outerRadius = externalRadius - radiusHoverOffset; }, sortComparator = (a, b) =&gt; b.quantity - a.quantity, // extractors getQuantity = ({quantity}) =&gt; quantity, getSliceFill = ({data}) =&gt; colorScale(data.name), // events dispatcher = d3Dispatch.dispatch('customMouseOver', 'customMouseOut', 'customMouseMove'); /** * This function creates the graph using the selection as container * * @param {D3Selection} _selection A d3 selection that represents * the container(s) where the chart(s) will be rendered * @param {DonutChartData} _data The data to attach and generate the chart */ function exports(_selection) { _selection.each(function(_data) { chartWidth = width - margin.left - margin.right; chartHeight = height - margin.top - margin.bottom; data = cleanData(_data); buildLayout(); buildColorScale(); buildShape(); buildSVG(this); drawSlices(); initTooltip(); }); } /** * Builds color scale for chart, if any colorSchema was defined * @private */ function buildColorScale() { if (colorSchema) { colorScale = d3Scale.scaleOrdinal().range(colorSchema); } } /** * Builds containers for the chart, the legend and a wrapper for all of them * @private */ function buildContainerGroups() { let container = svg .append('g') .classed('container-group', true) .attr('transform', `translate(${width / 2}, ${height / 2})`); container.append('g').classed('chart-group', true); container.append('g').classed('legend-group', true); } /** * Builds the pie layout that will produce data ready to draw * @private */ function buildLayout() { layout = d3Shape.pie() .padAngle(paddingAngle) .value(getQuantity) .sort(sortComparator); } /** * Builds the shape function * @private */ function buildShape() { shape = d3Shape.arc() .innerRadius(internalRadius) .padRadius(externalRadius); } /** * Builds the SVG element that will contain the chart * * @param {HTMLElement} container DOM element that will work as the container of the graph * @private */ function buildSVG(container) { if (!svg) { svg = d3Selection.select(container) .append('svg') .classed('britechart donut-chart', true) .data([data]); //TO REVIEW buildContainerGroups(); } svg .transition() .ease(ease) .attr('width', width + margin.left + margin.right) .attr('height', height + margin.top + margin.bottom); } /** * Cleaning data adding the proper format * @param {DonutChartData} data Data * @private */ function cleanData(data) { return data.map((d) =&gt; { d.quantity = +d[quantityLabel]; d.name = String(d[nameLabel]); d.percentage = String(d[percentageLabel]); return d; }); } /** * Draws the values on the donut slice inside the text element * * @param {Object} obj Data object * @private */ function drawLegend(obj) { if (obj.data) { svg.select('.donut-text') .text(() =&gt; `${obj.data.percentage}% ${ obj.data.name}`) .attr('dy', '.2em') .attr('text-anchor', 'middle'); svg.select('.donut-text').call(wrapText, legendWidth); } } /** * Draws the slices of the donut * @private */ function drawSlices() { if (!slices) { slices = svg.select('.chart-group') .selectAll('g.arc') .data(layout(data)); slices.enter() .append('g') .each(storeAngle) .each(reduceOuterRadius) .classed('arc', true) .on('mouseover', handleMouseOver) .on('mouseout', handleMouseOut) .merge(slices) .append('path') .attr('fill', getSliceFill) .on('mouseover', tweenGrowthFactory(externalRadius, 0)) .on('mouseout', tweenGrowthFactory(externalRadius - radiusHoverOffset, pieHoverTransitionDuration)) .transition() .ease(ease) .duration(pieDrawingTransitionDuration) .attrTween('d', tweenLoading); } else { slices = svg.select('.chart-group') .selectAll('path') .data(layout(data)); slices .attr('d', shape); // Redraws the angles of the data slices .transition() .duration(arcTransitionDuration) .attrTween('d', tweenArc); } } /** * Cleans any value that could be on the legend text element * @private */ function cleanLegend() { svg.select('.donut-text').text(''); } function handleMouseOver(datum) { drawLegend(datum); dispatcher.call('customMouseOver', this, datum); } function handleMouseOut() { cleanLegend(); dispatcher.call('customMouseOut', this); } /** * Creates the text element that will hold the legend of the chart */ function initTooltip() { svg.select('.legend-group') .append('text') .attr('class', 'donut-text'); } /** * Stores current angles and interpolates with new angles * Check out {@link http://bl.ocks.org/mbostock/1346410| this example} * * @param {Object} a New data for slice * @return {Function} Tweening function for the donut shape * @private */ function tweenArc(a) { let i = d3Interpolate.interpolate(this._current, a); this._current = i(0); return function(t) { return shape(i(t)); }; } /** * Generates animations with tweens depending on the attributes given * * @param {Number} outerRadius Final outer radius value * @param {Number} delay Delay of animation * @return {Function} Function that when called will tween the element * @private */ function tweenGrowthFactory(outerRadius, delay) { return function() { d3Selection.select(this) .transition() .delay(delay) .attrTween('d', function(d) { let i = d3Interpolate.interpolate(d.outerRadius, outerRadius); return (t) =&gt; { d.outerRadius = i(t); return shape(d); }; }); }; } /** * Animation for chart loading * Check out {@link http://bl.ocks.org/mbostock/4341574| this example} * * @param {Object} b Data point * @return {Function} Tween function * @private */ function tweenLoading(b) { let i; b.innerRadius = 0; i = d3Interpolate.interpolate({ startAngle: 0, endAngle: 0}, b); return function(t) { return shape(i(t)); }; } /** * Utility function that wraps a text into the given width * * @param {D3Selection} text Text to write * @param {Number} legendWidth Width of the container * @private */ function wrapText(text, legendWidth) { let fontSize = externalRadius / 5; textHelper.wrapText.call(null, 0, fontSize, legendWidth, text.node()); } /** * Gets or Sets the colorSchema of the chart * @param {String[]} _x Desired colorSchema for the graph * @return { colorSchema | module} Current colorSchema or Chart module to chain calls * @public */ exports.colorSchema = function(_x) { if (!arguments.length) { return colorSchema; } colorSchema = _x; return this; }; /** * Gets or Sets the externalRadius of the chart * @param {Number} _x ExternalRadius number to get/set * @return { (Number | Module) } Current externalRadius or Donut Chart module to chain calls * @public */ exports.externalRadius = function(_x) { if (!arguments.length) { return externalRadius; } externalRadius = _x; return this; }; /** * Gets or Sets the height of the chart * @param {Number} _x Desired width for the graph * @return { (Number | Module) } Current height or Donut Chart module to chain calls * @public */ exports.height = function(_x) { if (!arguments.length) { return height; } height = _x; return this; }; /** * Gets or Sets the internalRadius of the chart * @param {Number} _x InternalRadius number to get/set * @return { (Number | Module) } Current internalRadius or Donut Chart module to chain calls * @public */ exports.internalRadius = function(_x) { if (!arguments.length) { return internalRadius; } internalRadius = _x; return this; }; /** * Gets or Sets the margin of the chart * @param {Object} _x Margin object to get/set * @return { (Number | Module) } Current margin or Donut Chart module to chain calls * @public */ exports.margin = function(_x) { if (!arguments.length) { return margin; } margin = _x; return this; }; /** * Gets or Sets the width of the chart * @param {Number} _x Desired width for the graph * @return { (Number | Module) } Current width or Donut Chart module to chain calls * @public */ exports.width = function(_x) { if (!arguments.length) { return width; } width = _x; return this; }; /** * Chart exported to png and a download action is fired * @public */ exports.exportChart = function(filename, title) { exportChart.call(exports, svg, filename, title); }; /** * Exposes an 'on' method that acts as a bridge with the event dispatcher * We are going to expose this events: * customMouseOver, customMouseMove and customMouseOut * * @return {module} Bar Chart * @public */ exports.on = function() { let value = dispatcher.on.apply(dispatcher, arguments); return value === dispatcher ? exports : value; }; return exports; }; }); × Search results Close "},"legend.js.html":{"id":"legend.js.html","title":"Source: legend.js","body":" API BarBrushDonutLegendLineMini-tooltipSparklineStacked-areaStepTooltip Demos _CONTRIBUTING_GETTINGSTARTEDbarbrushdonutkitchen-sinklinesparklinestacked-areastep Global Global Source: legend.js define(function(require){ 'use strict'; const d3 = require('d3'); const d3Format = require('d3-format'); const d3Scale = require('d3-scale'); const d3Selection = require('d3-selection'); const d3Transition = require('d3-transition'); const colorHelper = require('./helpers/colors'); /** * @typedef LegendChartData * @type {Object[]} * @property {Number} id Id of the group (required) * @property {Number} quantity Quantity of the group (required) * @property {String} name Name of the group (required) * * @example * [ * { * id: 1, * quantity: 2, * name: 'glittering' * }, * { * id: 2, * quantity: 3, * name: 'luminous' * } */ /** * @fileOverview Legend Component reusable API class that renders a * simple and configurable legend element. * * @example * var donutChart = donut(), * legendBox = legend(); * * donutChart * .externalRadius(500) * .internalRadius(200) * .on('customMouseOver', function(data) { * legendBox.highlight(data.data.id); * }) * .on('customMouseOut', function() { * legendBox.clearHighlight(); * }); * * d3Selection.select('.css-selector') * .datum(dataset) * .call(donutChart); * * d3Selection.select('.other-css-selector') * .datum(dataset) * .call(legendBox); * * @module Legend * @tutorial legend * @exports charts/legend * @requires d3 */ return function module() { let margin = { top: 0, right: 0, bottom: 0, left: 0 }, width = 320, height = 180, lineMargin = 12, circleRadius = 8, circleYOffset = -5, textSize = 12, textLetterSpacing = 0.5, valueReservedSpace = 40, numberLetterSpacing = 0.8, numberFormat = d3Format.format('s'), isFadedClassName = 'is-faded', // colors colorScale, colorSchema = colorHelper.colorSchemas.britechartsColorSchema, getId = ({id}) =&gt; id, getName = ({name}) =&gt; name, getFormattedQuantity = ({quantity}) =&gt; numberFormat(quantity), entries, chartWidth, chartHeight, data, svg; /** * This function creates the graph using the selection as container * @param {D3Selection} _selection A d3 selection that represents * the container(s) where the chart(s) will be rendered * @param {object} _data The data to attach and generate the chart */ function exports(_selection) { _selection.each(function(_data){ chartWidth = width - margin.left - margin.right; chartHeight = height - margin.top - margin.bottom; data = _data; buildColorScale(); buildSVG(this); drawEntries(); }); } /** * Builds containers for the legend * Also applies the Margin convention * @private */ function buildContainerGroups() { let container = svg .append('g') .classed('legend-container-group', true) .attr('transform', `translate(${margin.left},${margin.top})`); container .append('g') .classed('legend-group', true); } /** * Builds color scale for chart, if any colorSchema was defined * @private */ function buildColorScale() { colorScale = d3Scale.scaleOrdinal().range(colorSchema); } /** * Builds the SVG element that will contain the chart * @param {HTMLElement} container DOM element that will work as the container of the graph * @private */ function buildSVG(container) { if (!svg) { svg = d3Selection.select(container) .append('svg') .classed('britechart britechart-legend', true); buildContainerGroups(); } svg .transition() .attr('width', width + margin.left + margin.right) .attr('height', height + margin.top + margin.bottom); } /** * Removes the faded class from all the entry lines */ function cleanFadedLines() { svg.select('.legend-group') .selectAll('g.legend-line') .classed(isFadedClassName, false); } /** * Draws the entries of the legend * @private */ function drawEntries() { entries = svg.select('.legend-group') .selectAll('g.legend-line') .data(data); // Enter entries.enter() .append('g') .classed('legend-line', true) .attr('data-item', getId) .attr('transform', function(d, i) { let horizontalOffset = 2 * circleRadius + 10, lineHeight = chartHeight/ (data.length + 1), verticalOffset = (i + 1) * lineHeight; return `translate(${horizontalOffset},${verticalOffset})`; }) .merge(entries) .append('circle') .classed('legend-circle', true) .attr('cx', 0) .attr('cy', circleYOffset) .attr('r', circleRadius) .style('fill', function({quantity}) { return colorScale(quantity); }) .style('stroke-width', 1); svg.select('.legend-group') .selectAll('g.legend-line') .append('text') .classed('legend-entry-name', true) .text(getName) .attr('x', (2 * circleRadius) + lineMargin) .style('font-size', `${textSize}px`) .style('letter-spacing', `${textLetterSpacing}px`); svg.select('.legend-group') .selectAll('g.legend-line') .append('text') .classed('legend-entry-value', true) .text(getFormattedQuantity) .attr('x', chartWidth - valueReservedSpace) .style('font-size', `${textSize}px`) .style('letter-spacing', `${numberLetterSpacing}px`) .style('text-anchor', 'end') .style('startOffset', '100%'); // Exit svg.select('.legend-group') .selectAll('g.legend-line') .exit() .transition() .style('opacity', 0) .remove(); } /** * Applies the faded class to all lines but the one that has the given id * @param {number} exceptionItemId Id of the line that needs to stay the same */ function fadeLinesBut(exceptionItemId) { svg.select('.legend-group') .selectAll('g.legend-line') .classed(isFadedClassName, true); d3Selection.select(`[data-item=&quot;${exceptionItemId}&quot;]`) .classed(isFadedClassName, false); } /** * Clears the highlighted line entry */ exports.clearHighlight = function() { cleanFadedLines(); }; /** * Gets or Sets the colorSchema of the chart * @param {Array} _x Color scheme array to get/set * @return { (Number | Module) } Current colorSchema or Donut Chart module to chain calls * @public */ exports.colorSchema = function(_x) { if (!arguments.length) { return colorSchema; } colorSchema = _x; return this; }; /** * Gets or Sets the height of the legend chart * @param {number} _x Desired width for the chart * @return { height | module} Current height or Legend module to chain calls * @public */ exports.height = function(_x) { if (!arguments.length) { return height; } height = _x; return this; }; /** * Highlights a line entry by fading the rest of lines * @param {number} entryId ID of the entry line */ exports.highlight = function(entryId) { cleanFadedLines(); fadeLinesBut(entryId); }; /** * Gets or Sets the margin of the legend chart * @param {object} _x Margin object to get/set * @return { margin | module} Current margin or Legend module to chain calls * @public */ exports.margin = function(_x) { if (!arguments.length) { return margin; } margin = _x; return this; }; /** * Gets or Sets the width of the legend chart * @param {number} _x Desired width for the graph * @return { width | module} Current width or Legend module to chain calls * @public */ exports.width = function(_x) { if (!arguments.length) { return width; } width = _x; return this; }; return exports; }; }); × Search results Close "},"mini-tooltip.js.html":{"id":"mini-tooltip.js.html","title":"Source: mini-tooltip.js","body":" API BarBrushDonutLegendLineMini-tooltipSparklineStacked-areaStepTooltip Demos _CONTRIBUTING_GETTINGSTARTEDbarbrushdonutkitchen-sinklinesparklinestacked-areastep Global Global Source: mini-tooltip.js define(function(require){ 'use strict'; const d3Array = require('d3-array'); const d3Ease = require('d3-ease'); const d3Format = require('d3-format'); const d3Selection = require('d3-selection'); const d3Transition = require('d3-transition'); /** * Mini Tooltip Component reusable API class that renders a * simple and configurable tooltip element for Britechart's * bar and step chart. * * @module Mini-tooltip * @tutorial bar * @requires d3 * * @example * var barChart = line(), * miniTooltip = miniTooltip(); * * barChart * .width(500) * .height(300) * .on('customMouseHover', miniTooltip.show) * .on('customMouseMove', miniTooltip.update) * .on('customMouseOut', miniTooltip.hide); * * d3Selection.select('.css-selector') * .datum(dataset) * .call(barChart); * * d3Selection.select('.metadata-group .mini-tooltip-container') * .datum([]) * .call(miniTooltip); * */ return function module() { let margin = { top: 12, right: 12, bottom: 12, left: 12 }, width = 100, height = 100, // Optional Title title = '', // Data Format valueLabel = 'value', nameLabel = 'name', // Animations mouseChaseDuration = 100, ease = d3Ease.easeQuadInOut, // tooltip tooltipBackground, backgroundBorderRadius = 1, tooltipTextContainer, tooltipOffset = { y: 0, x: 20 }, // Fonts textSize = 14, textLineHeight = 1.5, valueTextSize = 27, valueTextLineHeight = 1.18, // Colors bodyFillColor = '#FFFFFF', borderStrokeColor = '#D2D6DF', titleFillColor = '#666a73', nameTextFillColor = '#666a73', valueTextFillColor = '#45494E', valueTextWeight = 200, // formats tooltipValueFormat = d3Format.format('.2f'), chartWidth, chartHeight, svg; /** * This function creates the graph using the selection as container * @param {D3Selection} _selection A d3 selection that represents * the container(s) where the chart(s) will be rendered * @param {Array} _data The data to attach and generate the chart (usually an empty array) */ function exports(_selection) { _selection.each(function(_data){ chartWidth = width - margin.left - margin.right; chartHeight = height - margin.top - margin.bottom; buildSVG(this); drawTooltip(); }); } /** * Builds containers for the tooltip * Also applies the Margin convention * @private */ function buildContainerGroups() { let container = svg.append('g') .classed('tooltip-container-group', true) .attr('transform', `translate( ${margin.left}, ${margin.top})`); container.append('g').classed('tooltip-group', true); } /** * Builds the SVG element that will contain the chart * @param {HTMLElement} container DOM element that will work as the container of the graph * @private */ function buildSVG(container) { if (!svg) { svg = d3Selection.select(container) .append('g') .classed('britechart britechart-mini-tooltip', true); buildContainerGroups(); } svg .attr('width', width + margin.left + margin.right) .attr('height', height + margin.top + margin.bottom); // Hidden by default exports.hide(); } /** * Draws the different elements of the Tooltip box * @return void */ function drawTooltip(){ tooltipTextContainer = svg.selectAll('.tooltip-group') .append('g') .classed('tooltip-text', true); tooltipBackground = tooltipTextContainer .append('rect') .classed('tooltip-background', true) .attr('width', width) .attr('height', height) .attr('rx', backgroundBorderRadius) .attr('ry', backgroundBorderRadius) .attr('y', - margin.top) .attr('x', - margin.left) .style('fill', bodyFillColor) .style('stroke', borderStrokeColor) .style('stroke-width', 1) .style('pointer-events', 'none') .style('opacity', 0.9); } /** * Figures out the max length of the tooltip lines * @param {D3Selection[]} texts List of svg elements of each line * @return {Number} Max size of the lines */ function getMaxLengthLine(...texts) { let textSizes = texts.filter(x =&gt; !!x) .map(x =&gt; x.node().getBBox().width); return d3Array.max(textSizes); } /** * Calculates the desired position for the tooltip * @param {Number} mouseX Current horizontal mouse position * @param {Number} mouseY Current vertical mouse position * @param {Number} parentChartWidth Parent's chart width * @param {Number} parentChartHeight Parent's chart height * @return {Number[]} X and Y position * @private */ function getTooltipPosition([mouseX, mouseY], [parentChartWidth, parentChartHeight]) { let tooltipX, tooltipY; if (hasEnoughHorizontalRoom(parentChartWidth, mouseX)) { tooltipX = mouseX + tooltipOffset.x; } else { tooltipX = mouseX - chartWidth - tooltipOffset.x - margin.right; } if (hasEnoughVerticalRoom(parentChartHeight, mouseY)) { tooltipY = mouseY + tooltipOffset.y; } else { tooltipY = mouseY - chartHeight - tooltipOffset.y - margin.bottom; } return [tooltipX, tooltipY]; } /** * Checks if the mouse is over the bounds of the parent chart * @param {Number} chartWidth Parent's chart * @param {Number} positionX Mouse position * @return {Boolean} If the mouse position allows space for the tooltip */ function hasEnoughHorizontalRoom(parentChartWidth, positionX) { return (parentChartWidth - margin.left - margin.right - chartWidth) - positionX &gt; 0; } /** * Checks if the mouse is over the bounds of the parent chart * @param {Number} chartWidth Parent's chart * @param {Number} positionX Mouse position * @return {Boolean} If the mouse position allows space for the tooltip */ function hasEnoughVerticalRoom(parentChartHeight, positionY) { return (parentChartHeight - margin.top - margin.bottom - chartHeight) - positionY &gt; 0; } /** * Hides the tooltip * @return {void} */ function hideTooltip() { svg.style('display', 'none'); } /** * Shows the tooltip updating it's content * @param {Object} dataPoint Data point from the chart * @return {void} */ function showTooltip(dataPoint) { updateContent(dataPoint); svg.style('display', 'block'); } /** * Draws the data entries inside the tooltip for a given topic * @param {Object} topic Topic to extract data from * @return void */ function updateContent(dataPoint = {}){ let value = dataPoint[valueLabel] || '', name = dataPoint[nameLabel] || '', lineHeight = textSize * textLineHeight, valueLineHeight = valueTextSize * valueTextLineHeight, defaultDy = '1em', temporalHeight = 0, tooltipValue, tooltipName, tooltipTitle; tooltipTextContainer.selectAll('text') .remove(); if (title) { tooltipTitle = tooltipTextContainer .append('text') .classed('mini-tooltip-title', true) .attr('dy', defaultDy) .attr('y', 0) .style('fill', titleFillColor) .style('font-size', textSize) .text(title); temporalHeight = lineHeight + temporalHeight; } if (name) { tooltipName = tooltipTextContainer .append('text') .classed('mini-tooltip-name', true) .attr('dy', defaultDy) .attr('y', temporalHeight || 0) .style('fill', nameTextFillColor) .style('font-size', textSize) .text(name); temporalHeight = lineHeight + temporalHeight; } if (value) { tooltipValue = tooltipTextContainer .append('text') .classed('mini-tooltip-value', true) .attr('dy', defaultDy) .attr('y', temporalHeight || 0) .style('fill', valueTextFillColor) .style('font-size', valueTextSize) .style('font-weight', valueTextWeight) .text(tooltipValueFormat(value)); temporalHeight = valueLineHeight + temporalHeight; } chartWidth = getMaxLengthLine(tooltipName, tooltipTitle, tooltipValue); chartHeight = temporalHeight; } /** * Updates size and position of tooltip depending on the side of the chart we are in * @param {Object} dataPoint DataPoint of the tooltip * @return void */ function updatePositionAndSize(mousePosition, parentChartSize) { let [tooltipX, tooltipY] = getTooltipPosition(mousePosition, parentChartSize); svg.transition() .duration(mouseChaseDuration) .ease(ease) .attr('height', chartHeight + margin.top + margin.bottom) .attr('width', chartWidth + margin.left + margin.right) .attr('transform', `translate(${tooltipX},${tooltipY})`); tooltipBackground .attr('height', chartHeight + margin.top + margin.bottom) .attr('width', chartWidth + margin.left + margin.right); } /** * Updates tooltip content, size and position * * @param {Object} dataPoint Current datapoint to show info about * @return void */ function updateTooltip(dataPoint, position, chartSize) { updateContent(dataPoint); updatePositionAndSize(position, chartSize); } /** * Hides the tooltip * @return {Module} Tooltip module to chain calls * @public */ exports.hide = function() { hideTooltip(); return this; }; /** * Gets or Sets data's nameLabel * @param {text} _x Desired nameLabel * @return { text | module} nameLabel or Step Chart module to chain calls * @public */ exports.nameLabel = function(_x) { if (!arguments.length) { return nameLabel; } nameLabel = _x; return this; }; /** * Shows the tooltip * @return {Module} Tooltip module to chain calls * @public */ exports.show = function() { showTooltip(); return this; }; /** * Gets or Sets the title of the tooltip * @param {string} _x Desired title * @return { string | module} Current title or module to chain calls * @public */ exports.title = function(_x) { if (!arguments.length) { return title; } title = _x; return this; }; /** * Updates the position and content of the tooltip * @param {Object} dataPoint Datapoint of the hovered element * @param {Array} mousePosition Mouse position relative to the parent chart [x, y] * @param {Array} chartSize Parent chart size [x, y] * @return {module} Current component */ exports.update = function(dataPoint, mousePosition, chartSize) { updateTooltip(dataPoint, mousePosition, chartSize); return this; }; return exports; }; }); × Search results Close "},"sparkline.js.html":{"id":"sparkline.js.html","title":"Source: sparkline.js","body":" API BarBrushDonutLegendLineMini-tooltipSparklineStacked-areaStepTooltip Demos _CONTRIBUTING_GETTINGSTARTEDbarbrushdonutkitchen-sinklinesparklinestacked-areastep Global Global Source: sparkline.js define(function(require){ 'use strict'; const d3Array = require('d3-array'); const d3Ease = require('d3-ease'); const d3Scale = require('d3-scale'); const d3Shape = require('d3-shape'); const d3Selection = require('d3-selection'); const d3Transition = require('d3-transition'); const exportChart = require('./helpers/exportChart'); const colorHelper = require('./helpers/colors'); /** * @typedef SparklineChartData * @type {Object[]} * @property {Number} value Value of the group (required) * @property {String} name Name of the group (required) * * @example * [ * { * value: 1, * date: '2011-01-06T00:00:00Z' * }, * { * value: 2, * date: '2011-01-07T00:00:00Z' * } */ /** * Sparkline Chart reusable API module that allows us * rendering a sparkline configurable chart. * * @module Sparkline * @tutorial sparkline * @requires d3 * * @example * var sparkLineChart = sparkline(); * * sparkLineChart * .width(200) * .height(100); * * d3Selection.select('.css-selector') * .datum(dataset) * .call(sparkLineChart); * */ return function module(){ let margin = { left: 5, right: 5, top: 5, bottom: 5 }, width = 100, height = 30, xScale, yScale, areaGradient = ['#F5FDFF', '#F6FEFC'], lineGradient = colorHelper.colorGradients.greenBlueGradient, svg, chartWidth, chartHeight, data, hasArea = true, isAnimated = false, clipDuration = 3000, ease = d3Ease.easeQuadInOut, line, markerSize = 1.5, valueLabel = 'value', dateLabel = 'date', // getters getDate = ({date}) =&gt; date, getValue = ({value}) =&gt; value; /** * This function creates the graph using the selection and data provided * * @param {D3Selection} _selection A d3 selection that represents * the container(s) where the chart(s) will be rendered * @param {SparklineChartData} _data The data to attach and generate the chart */ function exports(_selection) { _selection.each(function(_data){ chartWidth = width - margin.left - margin.right; chartHeight = height - margin.top - margin.bottom; data = cleanData(_data); buildScales(); buildSVG(this); createGradients(); createMaskingClip(); drawLine(); drawArea(); drawEndMarker(); }); } /** * Builds containers for the chart, the axis and a wrapper for all of them * NOTE: The order of drawing of this group elements is really important, * as everything else will be drawn on top of them * @private */ function buildContainerGroups(){ let container = svg.append('g') .classed('container-group', true) .attr('transform', `translate(${margin.left},${margin.top})`); container .append('g').classed('chart-group', true); container .append('g').classed('metadata-group', true); } /** * Creates the x, y and color scales of the chart * @private */ function buildScales(){ xScale = d3Scale.scaleLinear() .domain(d3Array.extent(data, getDate)) .range([0, chartWidth]); yScale = d3Scale.scaleLinear() .domain(d3Array.extent(data, getValue)) .range([chartHeight, 0]); } /** * Builds the SVG element that will contain the chart * @param {HTMLElement} container DOM element that will work as the container of the graph * @private */ function buildSVG(container){ if (!svg) { svg = d3Selection.select(container) .append('svg') .classed('britechart sparkline', true); buildContainerGroups(); } svg .transition() .ease(ease) .attr('width', width) .attr('height', height); } /** * Cleaning data adding the proper format * @param {array} data Data * @private */ function cleanData(data) { return data.map((d) =&gt; { d.date = new Date(d[dateLabel]); d.value = +d[valueLabel]; return d; }); } /** * Creates the gradient on the area below the line * @return {void} */ function createGradients() { let metadataGroup = svg.select('.metadata-group'); metadataGroup.append('linearGradient') .attr('id', 'sparkline-area-gradient') .attr('gradientUnits', 'userSpaceOnUse') .attr('x1', 0) .attr('x2', xScale(data[data.length - 1].date)) .attr('y1', 0) .attr('y2', 0) .selectAll('stop') .data([ {offset: '0%', color: areaGradient[0]}, {offset: '100%', color: areaGradient[1]} ]) .enter().append('stop') .attr('offset', ({offset}) =&gt; offset) .attr('stop-color', ({color}) =&gt; color); metadataGroup.append('linearGradient') .attr('id', 'sparkline-line-gradient') .attr('gradientUnits', 'userSpaceOnUse') .attr('x1', 0) .attr('x2', xScale(data[data.length - 1].date)) .attr('y1', 0) .attr('y2', 0) .selectAll('stop') .data([ {offset: '0%', color: lineGradient[0]}, {offset: '100%', color: lineGradient[1]} ]) .enter().append('stop') .attr('offset', ({offset}) =&gt; offset) .attr('stop-color', ({color}) =&gt; color); } /** * Creates a masking clip that would help us fake an animation if the * proper flag is true * * @return {void} */ function createMaskingClip() { if (isAnimated) { svg.select('.metadata-group') .append('clipPath') .attr('id', 'maskingClip') .append('rect') .attr('width', 0) .attr('height', height); d3Selection.select('#maskingClip rect') .transition() .ease(ease) .duration(clipDuration) .attr('width', width); } } /** * Draws the area that will be placed below the line * @private */ function drawArea(){ let area = d3Shape.area() .x(({date}) =&gt; xScale(date)) .y0(() =&gt; yScale(0)) .y1(({value}) =&gt; yScale(value)) .curve(d3Shape.curveBasis); svg.select('.chart-group') .append('path') .datum(data) .attr('class', 'sparkline-area') .attr('d', area) .attr('clip-path', 'url(#maskingClip)'); } /** * Draws the line element within the chart group * @private */ function drawLine(){ line = d3Shape.line() .curve(d3Shape.curveBasis) .x(({date}) =&gt; xScale(date)) .y(({value}) =&gt; yScale(value)); svg.select('.chart-group') .append('path') .datum(data) .attr('class', 'line') .attr('d', line) .attr('clip-path', 'url(#maskingClip)'); } /** * Draws a marker at the end of the sparkline */ function drawEndMarker(){ svg.selectAll('.chart-group') .append('circle') .attr('class', 'sparkline-circle') .attr('cx', xScale(data[data.length - 1].date)) .attr('cy', yScale(data[data.length - 1].value)) .attr('r', markerSize); } // Accessors /** * Gets or Sets the dateLabel of the chart * @param {Number} _x Desired dateLabel for the graph * @return { dateLabel | module} Current dateLabel or Chart module to chain calls * @public */ exports.dateLabel = function(_x) { if (!arguments.length) { return dateLabel; } dateLabel = _x; return this; }; /** * Gets or Sets the duration of the animation * @param {Number} _x Desired animation duration for the graph * @return { dateLabel | module} Current animation duration or Chart module to chain calls * @public */ exports.duration = function(_x) { if (!arguments.length) { return clipDuration; } clipDuration = _x; return this; }; /** * Gets or Sets the areaGradient of the chart * @param {String[]} _x Desired areaGradient for the graph * @return { areaGradient | module} Current areaGradient or Chart module to chain calls * @public */ exports.areaGradient = function(_x) { if (!arguments.length) { return areaGradient; } areaGradient = _x; return this; }; /** * Gets or Sets the lineGradient of the chart * @param {String[]} _x Desired lineGradient for the graph * @return { lineGradient | module} Current lineGradient or Chart module to chain calls * @public */ exports.lineGradient = function(_x) { if (!arguments.length) { return lineGradient; } lineGradient = _x; return this; }; /** * Gets or Sets the height of the chart * @param {Number} _x Desired width for the graph * @return { height | module} Current height or Chart module to chain calls * @public */ exports.height = function(_x) { if (!arguments.length) { return height; } height = _x; return this; }; /** * Gets or Sets the isAnimated property of the chart * @param {Boolean} _x Desired animation flag * @return { isAnimated | module} Current isAnimated flag or Chart module * @public */ exports.isAnimated = function(_x) { if (!arguments.length) { return isAnimated; } isAnimated = _x; return this; }; /** * Gets or Sets the margin of the chart * @param {Object} _x Margin object to get/set * @return { margin | module} Current margin or Chart module to chain calls * @public */ exports.margin = function(_x) { if (!arguments.length) { return margin; } margin = _x; return this; }; /** * Gets or Sets the width of the chart * @param {Number} _x Desired width for the graph * @return { width | module} Current width or Chart module to chain calls * @public */ exports.width = function(_x) { if (!arguments.length) { return width; } width = _x; return this; }; /** * Gets or Sets the valueLabel of the chart * @param {Number} _x Desired valueLabel for the graph * @return { valueLabel | module} Current valueLabel or Chart module to chain calls * @public */ exports.valueLabel = function(_x) { if (!arguments.length) { return valueLabel; } valueLabel = _x; return this; }; /** * Chart exported to png and a download action is fired * @public */ exports.exportChart = function(filename, title) { exportChart.call(exports, svg, filename, title); }; return exports; }; }); × Search results Close "},"stacked-area.js.html":{"id":"stacked-area.js.html","title":"Source: stacked-area.js","body":" API BarBrushDonutLegendLineMini-tooltipSparklineStacked-areaStepTooltip Demos _CONTRIBUTING_GETTINGSTARTEDbarbrushdonutkitchen-sinklinesparklinestacked-areastep Global Global Source: stacked-area.js define(function(require){ 'use strict'; const d3Array = require('d3-array'); const d3Axis = require('d3-axis'); const d3Collection = require('d3-collection'); const d3Dispatch = require('d3-dispatch'); const d3Ease = require('d3-ease'); const d3Format = require('d3-format'); const d3Scale = require('d3-scale'); const d3Shape = require('d3-shape'); const d3Selection = require('d3-selection'); const d3Time = require('d3-time'); const d3TimeFormat = require('d3-time-format'); const d3Transition = require('d3-transition'); const _ = require('underscore'); const exportChart = require('./helpers/exportChart'); const colorHelper = require('./helpers/colors'); const ONE_AND_A_HALF_YEARS = 47304000000; const ONE_DAY = 86400001; const uniq = (arrArg) =&gt; arrArg.filter((elem, pos, arr) =&gt; arr.indexOf(elem) == pos); /** * @typdef D3Layout * @type function */ /** * Stacked Area Chart reusable API module that allows us * rendering a multi area and configurable chart. * * @module Stacked-area * @tutorial stacked-area * @requires d3-array, d3-axis, d3-collection, d3-ease, d3-scale, d3-shape, d3-selection, d3-time, d3-time-format * * @example * let stackedArea = stackedArea(); * * stackedArea * .width(containerWidth); * * d3Selection.select('.css-selector') * .datum(dataset.data) * .call(stackedArea); * */ return function module() { let margin = { top: 70, right: 30, bottom: 60, left: 70 }, width = 960, height = 500, xScale, xAxis, xMonthAxis, yScale, yAxis, monthAxisPadding = 30, numVerticalTicks = 5, yTickTextYOffset = -8, yTickTextXOffset = 40, tickPadding = 5, colorSchema = colorHelper.colorSchemas.britechartsColorSchema, colorOrder = colorSchema .reduce((acc, color, index) =&gt; { acc[color] = index; return acc; }, {}), areaOpacity = 0.8, colorScale, categoryColorMap, layers, layersInitial, area, // Area Animation maxAreaNumber = 8, areaAnimationDelayStep = 20, areaAnimationDelays = d3Array.range(areaAnimationDelayStep, maxAreaNumber* areaAnimationDelayStep, areaAnimationDelayStep), overlay, verticalMarkerContainer, verticalMarker, dataPoints = {}, pointsSize = 1.5, pointsColor = '#c0c6cc', pointsBorderColor = '#ffffff', ease = d3Ease.easeQuadInOut, areaAnimationDuration = 1000, defaultNumMonths = 10, svg, chartWidth, chartHeight, data, dataByDate, dataByDateFormatted, dataByDateZeroed, tooltipThreshold = 480, xAxisPadding = { top: 0, left: 15, bottom: 0, right: 0 }, dateLabel = 'dateUTC', valueLabel = 'views', // getters getValueLabel = d =&gt; d[valueLabel], getValues = ({values}) =&gt; values, getKey = ({key}) =&gt; key, getName = ({name}) =&gt; name, getDate = ({date}) =&gt; date, // formats parseUTC = d3TimeFormat.timeParse('%Y-%m-%dT%H:%M:%SZ'), yTickNumberFormat = d3Format.format('.3'), xTickHourFormat = d3TimeFormat.timeFormat('%H %p'), xTickDateFormat = d3TimeFormat.timeFormat('%e'), xTickMonthFormat = d3TimeFormat.timeFormat('%b'), // events dispatcher = d3Dispatch.dispatch('customMouseOver', 'customMouseOut', 'customMouseMove'); /** * This function creates the graph using the selection and data provided * @param {D3Selection} _selection A d3 selection that represents * the container(s) where the chart(s) will be rendered * @param {Object} _data The data to attach and generate the chart */ function exports(_selection) { _selection.each(function(_data){ chartWidth = width - margin.left - margin.right; chartHeight = height - margin.top - margin.bottom; data = cleanData(_data); dataByDate = d3Collection.nest() .key( getDate ) .entries( _(_data).sortBy('date') ); buildLayers(); buildScales(); buildAxis(); buildSVG(this); drawAxis(); drawStackedAreas(); if(shouldShowTooltip()){ drawHoverOverlay(); drawVerticalMarker(); addMouseEvents(); } }); } /** * Adds events to the container group if the environment is not mobile * Adding: mouseover, mouseout and mousemove */ function addMouseEvents() { svg .on('mouseover', handleMouseOver) .on('mouseout', handleMouseOut) .on('mousemove', handleMouseMove); } /** * Calculates the maximum number of ticks for the x axis * @param {Number} width Chart width * @param {Number} dataPointNumber Number of entries on the data * @return {Number} Number of ticks to render */ function getMaxNumOfHorizontalTicks(width, dataPointNumber) { let singleTickWidth = 30, spacing = 30, ticksForWidth = Math.ceil(width / (singleTickWidth + spacing)); return Math.min(dataPointNumber, ticksForWidth); } /** * Creates the d3 x and y axis, setting orientations * @private */ function buildAxis() { let dataTimeSpan = xScale.domain()[1] - xScale.domain()[0]; let xMonthTicks = dataTimeSpan &gt; ONE_AND_A_HALF_YEARS ? defaultNumMonths : d3Time.timeMonth; let xMainFormat = xTickDateFormat; let xSecondaryFormat = xTickMonthFormat; if (dataTimeSpan &lt; ONE_DAY) { xMainFormat = xTickHourFormat; xSecondaryFormat = xTickDateFormat; } xAxis = d3Axis.axisBottom(xScale) .ticks(getMaxNumOfHorizontalTicks(chartWidth, dataByDate.length)) .tickSize(10, 0) .tickPadding(tickPadding) .tickFormat(xMainFormat); //TODO: Review this axis with real data xMonthAxis = d3Axis.axisBottom(xScale) .ticks(xMonthTicks) .tickSize(0, 0) .tickFormat(xSecondaryFormat); yAxis = d3Axis.axisRight(yScale) .ticks(numVerticalTicks) .tickFormat(yTickNumberFormat) .tickSize(chartWidth + yTickTextXOffset, 0, 0) .tickPadding(tickPadding); } /** * Builds containers for the chart, the axis and a wrapper for all of them * NOTE: The order of drawing of this group elements is really important, * as everything else will be drawn on top of them * @private */ function buildContainerGroups(){ let container = svg.append('g') .classed('container-group', true) .attr('transform', `translate(${margin.left},${margin.top})`); container .append('g').classed('x-axis-group', true) .append('g').classed('x axis', true); container.selectAll('.x-axis-group') .append('g').classed('month-axis', true); container .append('g').classed('y-axis-group axis', true); container .append('g').classed('chart-group', true); container .append('g').classed('metadata-group', true); } /** * Builds the stacked layers layout * @return {D3Layout} Layout for drawing the chart * @private */ function buildLayers(){ dataByDateFormatted = _.chain(dataByDate) .map((d) =&gt; _.extend(d, d.values)) .map((d) =&gt; { _(d).each((entry) =&gt; { if(entry['name']) { d[entry['name']] = entry.value; } }); d['date'] = new Date(d['key']); return d; }) .value(); dataByDateZeroed = _.chain(JSON.parse(JSON.stringify(dataByDate))) .map((d) =&gt; _.extend(d, d.values)) .map((d) =&gt; { _(d).each((entry) =&gt; { if(entry['name']) { d[entry['name']] = 0; } }); d['date'] = new Date(d['key']); return d; }) .value(); let keys = uniq(_(data).pluck('name')); let stack3 = d3Shape.stack() .keys(keys) .order(d3Shape.stackOrderNone) .offset(d3Shape.stackOffsetNone); layersInitial = stack3(dataByDateZeroed); layers = stack3(dataByDateFormatted); } /** * Creates the x, y and color scales of the chart * @private */ function buildScales() { xScale = d3Scale.scaleTime() .domain(d3Array.extent(data, ({date}) =&gt; date)) .range([0, chartWidth]); yScale = d3Scale.scaleLinear() .domain([0, getMaxValueByDate()]) .range([chartHeight, 0]) .nice([numVerticalTicks + 1]); colorScale = d3Scale.scaleOrdinal() .range(colorSchema) .domain(data.map(getName)); // TODO add spread and rest operators to britecharts /* let range = colorScale.range(); categoryColorMap = colorScale.domain().reduce((memo, item, i) =&gt; ({...memo, [item]: range[i], }), {}); */ let range = colorScale.range(); categoryColorMap = colorScale .domain() .reduce((memo, item, i) =&gt; { memo[item] = range[i]; return memo; }, {}); } /** * @param {HTMLElement} container DOM element that will work as the container of the graph * @private */ function buildSVG(container) { if (!svg) { svg = d3Selection.select(container) .append('svg') .classed('britechart stacked-area', true); buildContainerGroups(); } svg .attr('width', width) .attr('height', height); } /** * Parses dates and values into JS Date objects and numbers * @param {obj} data Raw data from JSON file * @return {obj} Parsed data with values and dates */ function cleanData(data) { // could be rewritten using spread operator /* return data.map((d) =&gt; {...d, date: parseUTC(d[dateLabel], [valueLabel] : +d[valueLabel]}) */ return data.map((d) =&gt; { d.date = parseUTC(d[dateLabel]); d.value = +d[valueLabel]; return d; }); } /** * Draws the x and y axis on the svg object within their * respective groups * @private */ function drawAxis(){ svg.select('.x-axis-group .axis.x') .attr('transform', `translate( 0, ${chartHeight} )`) .call(xAxis); svg.select('.x-axis-group .month-axis') .attr('transform', `translate(0, ${(chartHeight + monthAxisPadding)})`) .call(xMonthAxis); svg.select('.y-axis-group.axis') .attr('transform', `translate( ${-yTickTextXOffset}, 0)`) .call(yAxis); // Moving the YAxis tick labels to the right side d3Selection.selectAll('.y-axis-group .tick text') .attr('transform', `translate( ${-chartWidth - yTickTextXOffset}, ${yTickTextYOffset})` ); } /** * Creates SVG dot elements for each data entry and draws them * TODO: Plug */ function drawDataReferencePoints() { // Creates Dots on Data points var points = svg.select('.chart-group').selectAll('.dots') .data(layers) .enter().append('g') .attr('class', 'dots') .attr('d', ({values}) =&gt; area(values)) .attr('clip-path', 'url(#clip)') // Processes the points // TODO: Optimize this code points.selectAll('.dot') .data(({values}, index) =&gt; values.map((point) =&gt; ({index, point}))) .enter() .append('circle') .attr('class','dot') .attr('r', () =&gt; pointsSize) .attr('fill', () =&gt; pointsColor) .attr('stroke-width', '0') .attr('stroke', pointsBorderColor) .attr('transform', function(d) { let {point} = d; let key = xScale(point.date); dataPoints[key] = dataPoints[key] || []; dataPoints[key].push(d); let {date, y, y0} = point; return `translate( ${xScale(date)}, ${yScale(y + y0)} )`; }); } /** * Draws an overlay element over the graph * @private */ function drawHoverOverlay(){ overlay = svg.select('.metadata-group') .append('rect') .attr('class', 'overlay') .attr('y1', 0) .attr('y2', chartHeight) .attr('height', chartHeight) .attr('width', chartWidth) .attr('fill', 'rgba(0,0,0,0)') .style('display', 'none'); } /** * Draws the different areas into the chart-group element * @private */ function drawStackedAreas(){ // Creating Area function area = d3Shape.area() .curve(d3Shape.curveCardinal) .x( ({data}) =&gt; xScale(data.date) ) .y0( (d) =&gt; yScale(d[0]) ) .y1( (d) =&gt; yScale(d[1]) ); let series = svg.select('.chart-group').selectAll('.layer') .data(layersInitial) .enter() .append('g') .classed('layer-container', true); series .append('path') .attr('class', 'layer') .attr('d', area) .style('fill', ({key}) =&gt; categoryColorMap[key]); // Update svg.select('.chart-group').selectAll('.layer') .data(layers) .transition() .delay( (_, i) =&gt; areaAnimationDelays[i]) .duration(areaAnimationDuration) .ease(ease) .attr('d', area) .style('opacity', areaOpacity) .style('fill', ({key}) =&gt; categoryColorMap[key]); // Exit series.exit() .transition() .style('opacity', 0) .remove(); } /** * Creates the vertical marker * @return void */ function drawVerticalMarker(){ verticalMarkerContainer = svg.select('.metadata-group') .append('g') .attr('class', 'vertical-marker-container') .attr('transform', 'translate(9999, 0)'); verticalMarker = verticalMarkerContainer.selectAll('path') .data([{ x1: 0, y1: 0, x2: 0, y2: 0 }]) .enter() .append('line') .classed('vertical-marker', true) .attr('x1', 0) .attr('y1', chartHeight) .attr('x2', 0) .attr('y2', 0); } /** * Removes all the datapoints highlighter circles added to the marker container * @return void */ function eraseDataPointHighlights() { verticalMarkerContainer.selectAll('.circle-container').remove(); } /** * Computes the maximum sum of values for any date * * @return {Number} Max value */ function getMaxValueByDate() { let keys = uniq(_(data).pluck('name')); let maxValueByDate = d3Array.max(dataByDateFormatted, function(d){ let vals = keys.map((key) =&gt; d[key]); return d3Array.sum(vals); }); return maxValueByDate; } /** * Extract X position on the chart from a given mouse event * @param {obj} event D3 mouse event * @return {Number} Position on the x axis of the mouse * @private */ function getMouseXPosition(event) { return d3Selection.mouse(event)[0]; } /** * Finds out the data entry that is closer to the given position on pixels * @param {Number} mouseX X position of the mouse * @return {obj} Data entry that is closer to that x axis position */ function getNearestDataPoint(mouseX) { let epsilon, nearest; //could use spread operator, would prevent mutation of original data /* let dataByDateParsed = dataByDate.map((item) =&gt; ({...item, key: new Date(item.key)})) */ let dataByDateParsed = dataByDate.map((item) =&gt; { item.key = new Date(item.key); return item; }); epsilon = (xScale(dataByDateParsed[1].key) - xScale(dataByDateParsed[0].key)) / 2; nearest = dataByDateParsed.find(({key}) =&gt; Math.abs(xScale(key) - mouseX) &lt;= epsilon); return nearest; } /** * MouseMove handler, calculates the nearest dataPoint to the cursor * and updates metadata related to it * @private */ function handleMouseMove(){ let dataPoint = getNearestDataPoint(getMouseXPosition(this) - margin.left), dataPointXPosition; if(dataPoint) { dataPointXPosition = xScale(new Date( dataPoint.key )); // Move verticalMarker to that datapoint moveVerticalMarker(dataPointXPosition); // Add data points highlighting highlightDataPoints(dataPoint); // Emit event with xPosition for tooltip or similar feature dispatcher.call('customMouseMove', this, dataPoint, categoryColorMap, dataPointXPosition); } } /** * MouseOut handler, hides overlay and removes active class on verticalMarkerLine * It also resets the container of the vertical marker * @private */ function handleMouseOut(data){ overlay.style('display', 'none'); verticalMarker.classed('bc-is-active', false); verticalMarkerContainer.attr('transform', 'translate(9999, 0)'); dispatcher.call('customMouseOut', this, data); } /** * Mouseover handler, shows overlay and adds active class to verticalMarkerLine * @private */ function handleMouseOver(data){ overlay.style('display', 'block'); verticalMarker.classed('bc-is-active', true); dispatcher.call('customMouseOver', this, data); } /** * Creates coloured circles marking where the exact data y value is for a given data point * @param {obj} dataPoint Data point to extract info from * @private */ function highlightDataPoints({values}) { let accumulator = 0; eraseDataPointHighlights(); // sorting the values based on the order of the colors, // so that the order always stays constant values = values .filter(v =&gt; !!v) .sort((a, b) =&gt; colorOrder[a.el] &gt; colorOrder[b.el]); values.forEach(({name}, index) =&gt; { let marker = verticalMarkerContainer .append('g') .classed('circle-container', true), circleSize = 12; accumulator = accumulator + values[index][valueLabel]; marker.append('circle') .classed('data-point-highlighter', true) .attr('cx', circleSize) .attr('cy', 0) .attr('r', 5) .style('stroke-width', 2) .style('stroke', categoryColorMap[name]); marker.attr('transform', `translate( ${(- circleSize)}, ${(yScale(accumulator))} )` ); }); } /** * Helper method to update the x position of the vertical marker * @param {obj} dataPoint Data entry to extract info * @return void */ function moveVerticalMarker(verticalMarkerXPosition){ verticalMarkerContainer.attr('transform', `translate(${verticalMarkerXPosition},0)`); } /** * Determines if we should add the tooltip related logic depending on the * size of the chart and the tooltipThreshold variable value * @return {boolean} Should we build the tooltip? * @private */ function shouldShowTooltip() { return width &gt; tooltipThreshold; } // Accessors /** * Gets or Sets the height of the chart * @param {Number} _x Desired width for the graph * @return { height | module} Current height or Area Chart module to chain calls * @public */ exports.height = function(_x) { if (!arguments.length) { return height; } height = _x; return this; }; /** * Gets or Sets the margin of the chart * @param {Object} _x Margin object to get/set * @return { margin | module} Current margin or Area Chart module to chain calls * @public */ exports.margin = function(_x) { if (!arguments.length) { return margin; } margin = _x; return this; }; /** * Gets or Sets the tooltipThreshold of the chart * @param {Object} _x Margin object to get/set * @return { tooltipThreshold | module} Current tooltipThreshold or Area Chart module to chain calls * @public */ exports.tooltipThreshold = function(_x) { if (!arguments.length) { return tooltipThreshold; } tooltipThreshold = _x; return this; }; /** * Gets or Sets the width of the chart * @param {Number} _x Desired width for the graph * @return { width | module} Current width or Area Chart module to chain calls * @public */ exports.width = function(_x) { if (!arguments.length) { return width; } width = _x; return this; }; /** * Gets or Sets the valueLabel of the chart * @param {Number} _x Desired valueLabel for the graph * @return { valueLabel | module} Current valueLabel or Chart module to chain calls * @public */ exports.valueLabel = function(_x) { if (!arguments.length) { return valueLabel; } valueLabel = _x; return this; }; /** * Gets or Sets the dateLabel of the chart * @param {Number} _x Desired dateLabel for the graph * @return { dateLabel | module} Current dateLabel or Chart module to chain calls * @public */ exports.dateLabel = function(_x) { if (!arguments.length) { return dateLabel; } dateLabel = _x; return this; }; /** * Gets or Sets the colorSchema of the chart * @param {String[]} _x Desired colorSchema for the graph * @return { colorSchema | module} Current colorSchema or Chart module to chain calls * @public */ exports.colorSchema = function(_x) { if (!arguments.length) { return colorSchema; } colorSchema = _x; return this; }; /** * Chart exported to png and a download action is fired * @public */ exports.exportChart = function(filename, title) { exportChart.call(exports, svg, filename, title); }; /** * Exposes an 'on' method that acts as a bridge with the event dispatcher * We are going to expose this events: * customMouseOver, customMouseMove and customMouseOut * * @return {module} Bar Chart * @public */ exports.on = function() { let value = dispatcher.on.apply(dispatcher, arguments); return value === dispatcher ? exports : value; }; return exports; }; }); × Search results Close "},"step.js.html":{"id":"step.js.html","title":"Source: step.js","body":" API BarBrushDonutLegendLineMini-tooltipSparklineStacked-areaStepTooltip Demos _CONTRIBUTING_GETTINGSTARTEDbarbrushdonutkitchen-sinklinesparklinestacked-areastep Global Global Source: step.js define(function(require) { 'use strict'; const d3Array = require('d3-array'); const d3Axis = require('d3-axis'); const d3Dispatch = require('d3-dispatch'); const d3Ease = require('d3-ease'); const d3Format = require('d3-format'); const d3Scale = require('d3-scale'); const d3Selection = require('d3-selection'); const d3Transition = require('d3-transition'); const exportChart = require('./helpers/exportChart'); /** * @typedef StepChartData * @type Object[] * * @property {String} key Key we measure (required) * @property {Number} value value of the key (required) * * @example * [ * { * value: 1, * key: 'glittering' * }, * { * value: 1, * key: 'luminous' * } * ] */ /** * Step Chart reusable API class that renders a * simple and configurable step chart. * * @module Step * @tutorial step * @requires d3-array, d3-axis, d3-dispatch, d3-format, d3-scale, d3-selection, d3-transition * * @example * var stepChart= step(); * * stepChart * .height(500) * .width(800); * * d3Selection.select('.css-selector') * .datum(dataset) * .call(stepChart); * */ return function module() { let margin = {top: 20, right: 20, bottom: 30, left: 40}, width = 960, height = 500, ease = d3Ease.easeQuadInOut, data, chartWidth, chartHeight, xScale, yScale, numOfVerticalTicks = 6, xAxis, xAxisLabel, yAxis, yAxisLabel, xAxisLabelOffset = 45, yAxisLabelOffset = -20, xAxisPadding = { top: 0, left: 0, bottom: 0, right: 0 }, yTickPadding = 8, svg, valueLabel = 'value', nameLabel = 'key', maskGridLines, baseLine, // Dispatcher object to broadcast the mouse events // Ref: https://github.com/mbostock/d3/wiki/Internals#d3_dispatch dispatcher = d3Dispatch.dispatch('customMouseOver', 'customMouseOut', 'customMouseMove'), // Formats yAxisTickFormat = d3Format.format('.3'), // extractors getKey = ({key}) =&gt; key, getValue = ({value}) =&gt; value; /** * This function creates the graph using the selection as container * @param {D3Selection} _selection A d3 selection that represents * the container(s) where the chart(s) will be rendered * @param {StepChartData} _data The data to attach and generate the chart */ function exports(_selection){ _selection.each(function(_data){ // Make space on the left of the graph for the y axis label chartWidth = width - margin.left - margin.right; chartHeight = height - margin.top - margin.bottom; data = cleanData(_data); buildScales(); buildAxis(); buildSVG(this); drawGridLines(); drawSteps(); drawAxis(); }); } /** * Creates the d3 x and y axis, setting orientations * @private */ function buildAxis(){ xAxis = d3Axis.axisBottom(xScale); yAxis = d3Axis.axisLeft(yScale) .ticks(numOfVerticalTicks) .tickPadding(yTickPadding) .tickFormat(yAxisTickFormat); } /** * Builds containers for the chart, the axis and a wrapper for all of them * Also applies the Margin convention * @private */ function buildContainerGroups(){ let container = svg .append('g') .classed('container-group', true) .attr('transform', `translate(${margin.left}, ${margin.top})`); container .append('g') .classed('grid-lines-group', true); container .append('g') .classed('chart-group', true); container .append('g') .classed('x-axis-group axis', true) .append('g') .classed('x-axis-label', true); container .append('g') .classed('y-axis-group axis', true) .append('g') .classed('y-axis-label', true); container .append('g').classed('metadata-group', true); } /** * Creates the x and y scales of the graph * @private */ function buildScales(){ xScale = d3Scale.scaleBand() .domain(data.map(getKey)) .rangeRound([0, chartWidth]) .paddingInner(0); yScale = d3Scale.scaleLinear() .domain([0, d3Array.max(data, getValue)]) .rangeRound([chartHeight, 0]); } /** * Builds the SVG element that will contain the chart * @param {HTMLElement} container DOM element that will work as the container of the graph * @private */ function buildSVG(container){ if (!svg) { svg = d3Selection.select(container) .append('svg') .classed('britechart step-chart', true); buildContainerGroups(); } svg .transition() .ease(ease) .attr('width', width + margin.left + margin.right) .attr('height', height + margin.top + margin.bottom); } /** * Cleaning data adding the proper format * @param {StepChartData} data Data * @private */ function cleanData(data) { return data.map((d) =&gt; { d.value = +d[valueLabel]; d.key = String(d[nameLabel]); return d; }); } /** * Draws the x and y axis on the svg object within their * respective groups * @private */ function drawAxis(){ svg.select('.x-axis-group.axis') .attr('transform', `translate(0, ${chartHeight})`) .call(xAxis); if (xAxisLabel) { svg.select('.x-axis-label') .append('text') .attr('text-anchor', 'middle') .attr('x', chartWidth / 2) .attr('y', xAxisLabelOffset) .text(xAxisLabel); } svg.select('.y-axis-group.axis') .call(yAxis); if (yAxisLabel) { svg.select('.y-axis-label') .append('text') .attr('x', -chartHeight / 2) .attr('y', yAxisLabelOffset) .attr('text-anchor', 'middle') .attr('transform', 'rotate(270 0 0)') .text(yAxisLabel); } } /** * Draws the step elements within the chart group * @private */ function drawSteps(){ let steps = svg.select('.chart-group').selectAll('.step').data(data); // Enter steps.enter() .append('rect') .classed('step', true) .attr('x', chartWidth) // Initially drawing the steps at the end of Y axis .attr('y', ({value}) =&gt; yScale(value)) .attr('width', xScale.bandwidth()) .attr('height', (d) =&gt; (chartHeight - yScale(d.value))) .on('mouseover', function() { dispatcher.call('customMouseOver', this); }) .on('mousemove', function(d) { dispatcher.call('customMouseMove', this, d, d3Selection.mouse(this), [chartWidth, chartHeight]); }) .on('mouseout', function() { dispatcher.call('customMouseOut', this); }) .merge(steps) .transition() .ease(ease) .attr('x', ({key}) =&gt; xScale(key)) .attr('y', function(d) { return yScale(d.value); }) .attr('width', xScale.bandwidth()) .attr('height', function(d) { return chartHeight - yScale(d.value); }); // Exit steps.exit() .transition() .style('opacity', 0) .remove(); } /** * Draws grid lines on the background of the chart * @return void */ function drawGridLines(){ maskGridLines = svg.select('.grid-lines-group') .selectAll('line.horizontal-grid-line') .data(yScale.ticks(numOfVerticalTicks)) .enter() .append('line') .attr('class', 'horizontal-grid-line') .attr('x1', (xAxisPadding.left)) .attr('x2', chartWidth) .attr('y1', (d) =&gt; yScale(d)) .attr('y2', (d) =&gt; yScale(d)); //draw a horizontal line to extend x-axis till the edges baseLine = svg.select('.grid-lines-group') .selectAll('line.extended-x-line') .data([0]) .enter() .append('line') .attr('class', 'extended-x-line') .attr('x1', (xAxisPadding.left)) .attr('x2', chartWidth) .attr('y1', height - margin.bottom - margin.top) .attr('y2', height - margin.bottom - margin.top); } /** * Chart exported to png and a download action is fired * @public */ exports.exportChart = function(filename) { exportChart.call(exports, svg, filename); }; /** * Gets or Sets the margin of the chart * @param {object} _x Margin object to get/set * @return { margin | module} Current margin or Step Chart module to chain calls * @public */ exports.margin = function(_x) { if (!arguments.length) { return margin; } margin = _x; return this; }; /** * Gets or Sets the width of the chart * @param {number} _x Desired width for the graph * @return { width | module} Current width or step Chart module to chain calls * @public */ exports.width = function(_x) { if (!arguments.length) { return width; } width = _x; return this; }; /** * Gets or Sets the height of the chart * @param {number} _x Desired width for the graph * @return { height | module} Current height or Step Chart module to chain calls * @public */ exports.height = function(_x) { if (!arguments.length) { return height; } height = _x; return this; }; /** * Gets or Sets the number of vertical ticks on the chart * @param {number} _x Desired width for the graph * @return { height | module} Current height or Step Chart module to chain calls * @public */ exports.numOfVerticalTicks = function(_x) { if (!arguments.length) { return numOfVerticalTicks; } numOfVerticalTicks = _x; return this; }; /** * Gets or Sets the text of the xAxisLabel on the chart * @param {text} _x Desired text for the label * @return { text | module} label or Step Chart module to chain calls * @public */ exports.xAxisLabel = function(_x) { if (!arguments.length) { return xAxisLabel; } xAxisLabel = _x; return this; }; /** * Gets or Sets the offset of the xAxisLabel on the chart * @param {integer} _x Desired offset for the label * @return { integer | module} label or Step Chart module to chain calls * @public */ exports.xAxisLabelOffset = function(_x) { if (!arguments.length) { return xAxisLabelOffset; } xAxisLabelOffset = _x; return this; }; /** * Gets or Sets the text of the yAxisLabel on the chart * @param {text} _x Desired text for the label * @return { text | module} label or Step Chart module to chain calls * @public */ exports.yAxisLabel = function(_x) { if (!arguments.length) { return yAxisLabel; } yAxisLabel = _x; return this; }; /** * Gets or Sets the offset of the yAxisLabel on the chart * @param {integer} _x Desired offset for the label * @return { integer | module} label or Step Chart module to chain calls * @public */ exports.yAxisLabelOffset = function(_x) { if (!arguments.length) { return yAxisLabelOffset; } yAxisLabelOffset = _x; return this; }; /** * Exposes an 'on' method that acts as a bridge with the event dispatcher * We are going to expose this events: * customMouseOver, customMouseMove and customMouseOut * * @return {module} Bar Chart * @public */ exports.on = function() { let value = dispatcher.on.apply(dispatcher, arguments); return value === dispatcher ? exports : value; }; /** * Chart exported to png and a download action is fired * @public */ exports.exportChart = function(filename, title) { exportChart.call(exports, svg, filename, title); }; return exports; }; }); × Search results Close "},"tooltip.js.html":{"id":"tooltip.js.html","title":"Source: tooltip.js","body":" API BarBrushDonutLegendLineMini-tooltipSparklineStacked-areaStepTooltip Demos _CONTRIBUTING_GETTINGSTARTEDbarbrushdonutkitchen-sinklinesparklinestacked-areastep Global Global Source: tooltip.js define(function(require){ 'use strict'; const d3Format = require('d3-format'); const d3Selection = require('d3-selection'); const d3Transition = require('d3-transition'); const d3TimeFormat = require('d3-time-format'); const { axisTimeCombinations } = require('./helpers/constants.js'); /** * Tooltip Component reusable API class that renders a * simple and configurable tooltip element for Britechart's * line chart or stacked area chart. * * @module Tooltip * @tutorial tooltip * @requires d3-array, d3-axis, d3-dispatch, d3-format, d3-scale, d3-selection, d3-transition * * @example * var lineChart = line(), * tooltip = tooltip(); * * tooltip * .title('Tooltip title'); * * lineChart * .width(500) * .on('customMouseOver', function() { * tooltip.show(); * }) * .on('customMouseMove', function(dataPoint, topicColorMap, dataPointXPosition) { * tooltip.update(dataPoint, topicColorMap, dataPointXPosition); * }) * .on('customMouseOut', function() { * tooltip.hide(); * }); * * d3Selection.select('.css-selector') * .datum(dataset) * .call(lineChart); * * d3Selection.select('.metadata-group .hover-marker') * .datum([]) * .call(tooltip); * */ return function module() { let margin = { top: 2, right: 2, bottom: 2, left: 2 }, width = 250, height = 45, title = 'Tooltip title', // tooltip tooltip, tooltipOffset = { y: -55, x: 0 }, tooltipMaxTopicLength = 170, tooltipTextContainer, tooltipDivider, tooltipBody, tooltipTitle, tooltipWidth = 250, tooltipHeight = 48, ttTextX = 0, ttTextY = 37, textSize, entryLineLimit = 3, circleYOffset = 8, colorMap, bodyFillColor = '#FFFFFF', borderStrokeColor = '#D2D6DF', titleFillColor = '#6D717A', textFillColor = '#282C35', tooltipTextColor = '#000000', dateLabel = 'date', valueLabel = 'value', topicLabel = 'topics', defaultAxisSettings = axisTimeCombinations.DAY_MONTH, forceAxisSettings = null, // formats monthDayYearFormat = d3TimeFormat.timeFormat('%b %d, %Y'), monthDayHourFormat = d3TimeFormat.timeFormat('%b %d, %I %p'), valueRangeLimits = { small: 10, medium: 100 }, integerValueFormats = { small: d3Format.format(''), medium: d3Format.format(''), large: d3Format.format('.2s') }, decimalValueFormats = { small: d3Format.format('.3f'), medium: d3Format.format('.1f'), large: d3Format.format('.2s') }, chartWidth, chartHeight, data, svg; /** * This function creates the graph using the selection as container * @param {D3Selection} _selection A d3 selection that represents * the container(s) where the chart(s) will be rendered * @param {Object} _data The data to attach and generate the chart */ function exports(_selection) { _selection.each(function(_data){ chartWidth = width - margin.left - margin.right; chartHeight = height - margin.top - margin.bottom; data = _data; buildSVG(this); }); } /** * Builds containers for the tooltip * Also applies the Margin convention * @private */ function buildContainerGroups() { var container = svg.append('g') .classed('tooltip-container-group', true) .attr('transform', `translate( ${margin.left}, ${margin.top})`); container.append('g').classed('tooltip-group', true); } /** * Builds the SVG element that will contain the chart * @param {HTMLElement} container DOM element that will work as the container of the graph * @private */ function buildSVG(container) { if (!svg) { svg = d3Selection.select(container) .append('g') .classed('britechart britechart-tooltip', true); buildContainerGroups(); drawTooltip(); } svg.transition() .attr('width', width + margin.left + margin.right) .attr('height', height + margin.top + margin.bottom); // Hidden by default exports.hide(); } /** * Resets the tooltipBody content * @return void */ function cleanContent(){ tooltipBody.selectAll('text').remove(); tooltipBody.selectAll('circle').remove(); } /** * Draws the different elements of the Tooltip box * @return void */ function drawTooltip(){ tooltipTextContainer = svg.selectAll('.tooltip-group') .append('g') .classed('tooltip-text', true); tooltip = tooltipTextContainer .append('rect') .classed('tooltip-text-container', true) .attr('x', -tooltipWidth / 4 + 8) .attr('y', 0) .attr('width', tooltipWidth) .attr('height', tooltipHeight) .attr('rx', 3) .attr('ry', 3) .style('fill', bodyFillColor) .style('stroke', borderStrokeColor) .style('stroke-width', 1); tooltipTitle = tooltipTextContainer .append('text') .classed('tooltip-title', true) .attr('x', -tooltipWidth / 4 + 17) .attr('dy', '.35em') .attr('y', 16) .style('fill', titleFillColor); tooltipDivider = tooltipTextContainer .append('line') .classed('tooltip-divider', true) .attr('x1', -tooltipWidth / 4 + 15) .attr('y1', 31) .attr('x2', 265) .attr('y2', 31) .style('stroke', borderStrokeColor); tooltipBody = tooltipTextContainer .append('g') .classed('tooltip-body', true) .style('transform', 'translateY(8px)') .style('fill', textFillColor); } /** * Formats a floating point value depending on its value range * @param {Number} value Decimal point value to format * @return {Number} Formatted value to show */ function formatDecimalValue(value) { let size = 'large'; if (value &lt; valueRangeLimits.small) { size = 'small'; } else if (value &lt; valueRangeLimits.medium) { size = 'medium'; } return decimalValueFormats[size](value); } /** * Formats an integer value depending on its value range * @param {Number} value Decimal point value to format * @return {Number} Formatted value to show */ function formatIntegerValue(value) { let size = 'large'; if (value &lt; valueRangeLimits.small) { size = 'small'; } if (value &lt; valueRangeLimits.medium) { size = 'medium'; } return integerValueFormats[size](value); } /** * Formats the value depending on its characteristics * @param {Number} value Value to format * @return {Number} Formatted value */ function getFormattedValue(value) { if (!value) { return 0; } if (isInteger(value)) { value = formatIntegerValue(value); } else { value = formatDecimalValue(value); } return value; } /** * Extracts the value from the data object * @param {Object} data Data value containing the info * @return {String} Value to show */ function getValueText(data) { let value = data[valueLabel]; let valueText; if (data.missingValue) { valueText = '-'; } else { valueText = getFormattedValue(value).toString(); } return valueText; } /** * Checks if a number is an integer of has decimal values * @param {Number} value Value to check * @return {Boolean} If it is an iteger */ function isInteger(value) { return value % 1 === 0; } /** * Resets the height of the tooltip and the pointer for the text * position */ function resetSizeAndPositionPointers() { tooltipHeight = 48; ttTextY = 37; ttTextX = 0; } /** * Draws the data entries inside the tooltip for a given topic * @param {Object} topic Topic to extract data from * @return void */ function updateContent(topic){ let name = topic.name, tooltipRight, tooltipLeftText, tooltipRightText, elementText; tooltipLeftText = topic.topicName || name; tooltipRightText = getValueText(topic); elementText = tooltipBody .append('text') .classed('tooltip-left-text', true) .attr('dy', '1em') .attr('x', ttTextX - 20) .attr('y', ttTextY) .style('fill', tooltipTextColor) .text(tooltipLeftText) .call(textWrap, tooltipMaxTopicLength, -25); tooltipRight = tooltipBody .append('text') .classed('tooltip-right-text', true) .attr('dy', '1em') .attr('x', ttTextX + 8) .attr('y', ttTextY) .style('fill', tooltipTextColor) .text(tooltipRightText); textSize = elementText.node().getBBox(); tooltipHeight += textSize.height + 5; // Not sure if necessary tooltipRight.attr('x', tooltipWidth - tooltipRight.node().getBBox().width - 10 - tooltipWidth / 4) tooltipBody .append('circle') .classed('tooltip-circle', true) .attr('cx', 23 - tooltipWidth / 4) .attr('cy', (ttTextY + circleYOffset)) .attr('r', 5) .style('fill', colorMap[name]) .style('stroke-width', 1); ttTextY += textSize.height + 7; } /** * Updates size and position of tooltip depending on the side of the chart we are in * @param {Object} dataPoint DataPoint of the tooltip * @param {Number} xPosition DataPoint's x position in the chart * @return void */ function updatePositionAndSize(dataPoint, xPosition){ tooltip .attr('width', tooltipWidth) .attr('height', tooltipHeight + 10); // show tooltip to the right if ((xPosition - tooltipWidth) &lt; 0) { // Tooltip on the right tooltipTextContainer .attr('transform', 'translate(' + (tooltipWidth - 185) + ',' + tooltipOffset.y + ')'); } else { // Tooltip on the left tooltipTextContainer .attr('transform', 'translate(' + (-205) + ',' + tooltipOffset.y + ')'); } tooltipDivider .attr('x2', tooltipWidth - 60); } /** * Updates value of tooltipTitle with the data meaning and the date * @param {Object} dataPoint Point of data to use as source * @return void */ function updateTitle(dataPoint) { var date = new Date(dataPoint[dateLabel]), tooltipTitleText = title + ' - ' + formatDate(date); tooltipTitle.text(tooltipTitleText); } /** * Figures out which date format to use when showing the date of the current data entry * @return {Function} The proper date formatting function */ function formatDate(date) { let settings = forceAxisSettings || defaultAxisSettings; let format = null; if (settings === axisTimeCombinations.DAY_MONTH || settings === axisTimeCombinations.MONTH_YEAR) { format = monthDayYearFormat; } else if (settings === axisTimeCombinations.HOUR_DAY || settings === axisTimeCombinations.MINUTE_HOUR) { format = monthDayHourFormat; } return format(date); } /** * Updates tooltip title, content, size and position * * @param {lineChartPointByDate} dataPoint Current datapoint to show info about * @param {Number} xPosition Position of the mouse on the X axis * @return void */ function updateTooltip(dataPoint, xPosition) { var topics = dataPoint[topicLabel]; cleanContent(); resetSizeAndPositionPointers(); updateTitle(dataPoint); topics.forEach(updateContent); updatePositionAndSize(dataPoint, xPosition); } /** * Wraps a text given the text, width, x position and textFormatter function * @param {D3Selection} text Selection with the text to wrap inside * @param {Number} width Desired max width for that line * @param {Number} xpos Initial x position of the text * * REF: http://bl.ocks.org/mbostock/7555321 * More discussions on https://github.com/mbostock/d3/issues/1642 */ function textWrap(text, width, xpos) { xpos = xpos || 0; text.each(function() { var words, word, line, lineNumber, lineHeight, y, dy, tspan; text = d3Selection.select(this); words = text.text().split(/\\s+/).reverse(); line = []; lineNumber = 0; lineHeight = 1.2; y = text.attr('y'); dy = parseFloat(text.attr('dy')); tspan = text .text(null) .append('tspan') .attr('x', xpos) .attr('y', y) .attr('dy', dy + 'em'); while ((word = words.pop())) { line.push(word); tspan.text(line.join(' ')); if (tspan.node().getComputedTextLength() &gt; width) { line.pop(); tspan.text(line.join(' ')); if (lineNumber &lt; entryLineLimit - 1) { line = [word]; tspan = text.append('tspan') .attr('x', xpos) .attr('y', y) .attr('dy', ++lineNumber * lineHeight + dy + 'em') .text(word); } } } }); } /** * Gets or Sets the dateLabel of the data * @param {Number} _x Desired dateLabel * @return { dateLabel | module} Current dateLabel or Chart module to chain calls * @public */ exports.dateLabel = function(_x) { if (!arguments.length) { return dateLabel; } dateLabel = _x; return this; }; /** * Gets or Sets the valueLabel of the data * @param {Number} _x Desired valueLabel * @return { valueLabel | module} Current valueLabel or Chart module to chain calls * @public */ exports.valueLabel = function(_x) { if (!arguments.length) { return valueLabel; } valueLabel = _x; return this; }; /** * Gets or Sets the topicLabel of the data * @param {Number} _x Desired topicLabel * @return { topicLabel | module} Current topicLabel or Chart module to chain calls * @public */ exports.topicLabel = function(_x) { if (!arguments.length) { return topicLabel; } topicLabel = _x; return this; }; /** * Hides the tooltip * @return {Module} Tooltip module to chain calls * @public */ exports.hide = function() { svg.style('display', 'none'); return this; }; /** * Shows the tooltip * @return {Module} Tooltip module to chain calls * @public */ exports.show = function() { svg.style('display', 'block'); return this; }; /** * Gets or Sets the title of the tooltip * @param {string} _x Desired title * @return { string | module} Current title or module to chain calls * @public */ exports.title = function(_x) { if (!arguments.length) { return title; } title = _x; return this; }; /** * Updates the position and content of the tooltip * @param {Object} dataPoint Datapoint to represent * @param {Object} colorMapping Color scheme of the topics * @param {Number} position X-scale position in pixels * @return {Module} Tooltip module to chain calls * @public */ exports.update = function(dataPoint, colorMapping, position) { colorMap = colorMapping; updateTooltip(dataPoint, position); return this; }; /** * Exposes the ability to force the tooltip to use a certain date format * @param {String} _x Desired format * @return { (String|Module) } Current format or module to chain calls */ exports.forceDateRange = function(_x) { if (!arguments.length) { return forceAxisSettings || defaultAxisSettings; } forceAxisSettings = _x; return this; }; /** * constants to be used to force the x axis to respect a certain granularity * current options: HOUR_DAY, DAY_MONTH, MONTH_YEAR * @example tooltip.forceDateRange(tooltip.axisTimeCombinations.HOUR_DAY) */ exports.axisTimeCombinations = axisTimeCombinations; return exports; }; }); × Search results Close "},"global.html":{"id":"global.html","title":"Global","body":" API BarBrushDonutLegendLineMini-tooltipSparklineStacked-areaStepTooltip Demos _CONTRIBUTING_GETTINGSTARTEDbarbrushdonutkitchen-sinklinesparklinestacked-areastep Global Global Global Type Definitions BarChartData Type: Array.&lt;Object&gt; Properties: Name Type Description value Number Value of the group (required) name String Name of the group (required) Source: bar.js Example [ { value: 1, name: 'glittering' }, { value: 1, name: 'luminous' } ] BrushChartData Type: Array.&lt;Object&gt; Properties: Name Type Description value Number Value to chart (required) date Date Date of the value (required) Source: brush.js Example [ { value: 1, date: '2011-01-06T00:00:00Z' }, { value: 2, date: '2011-01-07T00:00:00Z' } ] D3Selection Type: Array.&lt;Array&gt; Properties: Name Type Description length Number Size of the selection parentNode DOMElement Parent of the selection Source: line.js DonutChartData Type: Array.&lt;Object&gt; Properties: Name Type Description quantity Number Quantity of the group (required) percentage Number Percentage of the total (required) name String Name of the group (required) id Number Identifier for the group required for legend feature (optional) Source: donut.js Example [ { quantity: 1, percentage: 50, name: 'glittering', id: 1 }, { quantity: 1, percentage: 50, name: 'luminous', id: 2 } ] LegendChartData Type: Array.&lt;Object&gt; Properties: Name Type Description id Number Id of the group (required) quantity Number Quantity of the group (required) name String Name of the group (required) Source: legend.js Example [ { id: 1, quantity: 2, name: 'glittering' }, { id: 2, quantity: 3, name: 'luminous' } LineChartData Type: Array.&lt;Object&gt; Properties: Name Type Description data Array.&lt;lineChartPointByTopic&gt; Data values to chart (required) dataByDate Array.&lt;lineChartPointByDate&gt; Data values to chart ordered by date (required) Source: line.js Example { data: [ { Data: [ { date: '', fullDate: '2017-01-16T16:00:00-08:00', value: 1 }, { date: '', fullDate: '2017-01-16T17:00:00-08:00', value: 2 } ], topic: 123, topicName: 'San Francisco' }, { Data: [ {...}, {...} ], topic: 345, topicName: 'Other' } ], dataByDate: [ { date: '2017-01-16T16:00:00-08:00', topics: [ { name: 123, topicName: 'San Francisco', value: 1 }, { name: 345, topicName: 'Other', value: 2 } ] }, {...} ] } lineChartPointByDate Type: Object Properties: Name Type Description date Date Date value (required) topics Array.&lt;Object&gt; Data entries for that day (required) Source: line.js Example { date: '2017-01-16T16:00:00-08:00' topics: [ { name: 123, topicName: 'San Francisco', value: 1 }, { name: 345, topicName: 'Other', value: 2 } ] } lineChartPointByTopic Type: Object Properties: Name Type Description Data Array.&lt;Object&gt; All data entries for a given topic (required) topic Number Topic identifier (required) topicName String Topic name (required) Source: line.js Example { Data: [ { date: '', fullDate: '2017-01-16T16:00:00-08:00', value: 1 }, { date: '', fullDate: '2017-01-16T17:00:00-08:00', value: 2 } ], topic: 123, topicName: 'San Francisco' } SparklineChartData Type: Array.&lt;Object&gt; Properties: Name Type Description value Number Value of the group (required) name String Name of the group (required) Source: sparkline.js Example [ { value: 1, date: '2011-01-06T00:00:00Z' }, { value: 2, date: '2011-01-07T00:00:00Z' } StepChartData Type: Array.&lt;Object&gt; Properties: Name Type Description key String Key we measure (required) value Number value of the key (required) Source: step.js Example [ { value: 1, key: 'glittering' }, { value: 1, key: 'luminous' } ] × Search results Close "},"modules.list.html":{"id":"modules.list.html","title":"API","body":" API BarBrushDonutLegendLineMini-tooltipSparklineStacked-areaStepTooltip Demos _CONTRIBUTING_GETTINGSTARTEDbarbrushdonutkitchen-sinklinesparklinestacked-areastep Global Global API × Search results Close "},"tutorials.list.html":{"id":"tutorials.list.html","title":"Demos","body":" API BarBrushDonutLegendLineMini-tooltipSparklineStacked-areaStepTooltip Demos _CONTRIBUTING_GETTINGSTARTEDbarbrushdonutkitchen-sinklinesparklinestacked-areastep Global Global Demos × Search results Close "},"index.html":{"id":"index.html","title":"Index","body":" API BarBrushDonutLegendLineMini-tooltipSparklineStacked-areaStepTooltip Demos _CONTRIBUTING_GETTINGSTARTEDbarbrushdonutkitchen-sinklinesparklinestacked-areastep Global Global Britecharts Britecharts is a client-side reusable Charting Library based on D3.js v4 that allows easy and intuitive use of charts and components that can be composed together creating amazing visualizations. Britecharts components have been written in ES2015 with a Test Driven methodology so they are fully tested, and we are commited to keep them that way. Key FeaturesThe main characteristics of this library are: Reusability Composability Fully tested ES6 source (transpiled to ES5 with Babel) UsageThe typical use of Britecharts involves creating a chart using it's simple API, and rendering it on a container which has previously been applied some data. The code will look like this: barChart .width(500) .height(300); barContainer.datum(dataset).call(barChart);APIAll the components expose some basic API methods like width, height and margin. Additionally, each chart or component can expose more methods. They will be ready to check in the documentation of the modules: Bar Chart: API - Demo Line Chart: API - Demo Donut Chart: API - Demo Brush Chart: API - Demo Sparkline Chart: API - Demo Stacked Area Chart: API - Demo Tooltip Chart: API - Demo Mini Tooltip Chart: API - Demo Legend Chart: API - Demo Step Chart: API - Demo InstallBritecharts components are distributed in UMD modules, each one exposing a D3.js component written with the Reusable API pattern. In order to use any of the Britecharts modules, you will need to require the chart in your JS file using AMD/CommonJS modules. They also provide some minimal CSS styling, that can be loaded independently or as a bundle. RoadmapThis project is in active development. Check the issues page for more info in what's coming. See Also Getting Started Guide Documentation Release Notes Contributing Guide Github Repo AcknowledgmentsBritecharts was inspired by two books, Developing a D3.js Edge and Mastering D3.js. It also leveraged a great number of examples and articles from the D3.js community overall. LicenseCopyright 2017 Eventbrite Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0 Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an &quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License. Read more in the license document × Search results Close "},"module-Bar.html":{"id":"module-Bar.html","title":"API: Bar","body":" API BarBrushDonutLegendLineMini-tooltipSparklineStacked-areaStepTooltip Demos _CONTRIBUTING_GETTINGSTARTEDbarbrushdonutkitchen-sinklinesparklinestacked-areastep Global Global API: Bar Bar Chart reusable API class that renders a simple and configurable bar chart. (require(&quot;Bar&quot;))(_selection, _data) This function creates the graph using the selection as container Parameters: Name Type Description _selection D3Selection A d3 selection that represents the container(s) where the chart(s) will be rendered _data BarChartData The data to attach and generate the chart Source: bar.js Requires module:d3-array, Methods module:Bar(_selection, _data) This function creates the graph using the selection as container Parameters: Name Type Description _selection D3Selection A d3 selection that represents the container(s) where the chart(s) will be rendered _data BarChartData The data to attach and generate the chart Source: bar.js &lt;static&gt; exportChart() Chart exported to png and a download action is fired Source: bar.js &lt;static&gt; exportChart() Chart exported to png and a download action is fired Source: bar.js &lt;static&gt; height(_x) Gets or Sets the height of the chart Parameters: Name Type Description _x number Desired width for the graph Source: bar.js Returns: Current height or Bar Chart module to chain calls Type height | module &lt;static&gt; horizontal(_x) Gets or Sets the horizontal direction of the chart Parameters: Name Type Description _x number Desired horizontal direction for the graph Source: bar.js Returns: Current horizontal direction or Bar Chart module to chain calls Type horizontal | module &lt;static&gt; margin(_x) Gets or Sets the margin of the chart Parameters: Name Type Description _x object Margin object to get/set Source: bar.js Returns: Current margin or Bar Chart module to chain calls Type margin | module &lt;static&gt; on() Exposes an 'on' method that acts as a bridge with the event dispatcher We are going to expose this events: customMouseOver, customMouseMove and customMouseOut Source: bar.js Returns: Bar Chart Type module &lt;static&gt; width(_x) Gets or Sets the width of the chart Parameters: Name Type Description _x number Desired width for the graph Source: bar.js Returns: Current width or Bar Chart module to chain calls Type width | module × Search results Close "},"module-Brush.html":{"id":"module-Brush.html","title":"API: Brush","body":" API BarBrushDonutLegendLineMini-tooltipSparklineStacked-areaStepTooltip Demos _CONTRIBUTING_GETTINGSTARTEDbarbrushdonutkitchen-sinklinesparklinestacked-areastep Global Global API: Brush Brush Chart reusable API class that renders a simple and configurable brush chart. (require(&quot;Brush&quot;))(_selection, _data) This function creates the graph using the selection as container Parameters: Name Type Description _selection D3Selection A d3 selection that represents the container(s) where the chart(s) will be rendered _data BrushChartData The data to attach and generate the chart Source: brush.js Requires module:d3-array, Methods module:Brush(_selection, _data) This function creates the graph using the selection as container Parameters: Name Type Description _selection D3Selection A d3 selection that represents the container(s) where the chart(s) will be rendered _data BrushChartData The data to attach and generate the chart Source: brush.js &lt;static&gt; gradient(_x) Gets or Sets the gradient of the chart Parameters: Name Type Description _x Array.&lt;String&gt; Desired gradient for the graph Source: brush.js Returns: Current gradient or Chart module to chain calls Type gradient | module &lt;static&gt; height(_x) Gets or Sets the height of the chart Parameters: Name Type Description _x number Desired width for the graph Source: brush.js Returns: Current height or Chart module to chain calls Type height | module &lt;static&gt; margin(_x) Gets or Sets the margin of the chart Parameters: Name Type Description _x object Margin object to get/set Source: brush.js Returns: Current margin or Chart module to chain calls Type margin | module &lt;static&gt; onBrush(_x) Gets or Sets the callback that will be called when the user brushes over the area Parameters: Name Type Description _x function Callback to call Source: brush.js Returns: Current callback function or the Chart Module Type function | module &lt;static&gt; width(_x) Gets or Sets the width of the chart Parameters: Name Type Description _x number Desired width for the graph Source: brush.js Returns: Current width or Chart module to chain calls Type width | module × Search results Close "},"module-Donut.html":{"id":"module-Donut.html","title":"API: Donut","body":" API BarBrushDonutLegendLineMini-tooltipSparklineStacked-areaStepTooltip Demos _CONTRIBUTING_GETTINGSTARTEDbarbrushdonutkitchen-sinklinesparklinestacked-areastep Global Global API: Donut Reusable Donut Chart API class that renders a simple and configurable donut chart. (require(&quot;Donut&quot;))(_selection, _data) This function creates the graph using the selection as container Parameters: Name Type Description _selection D3Selection A d3 selection that represents the container(s) where the chart(s) will be rendered _data DonutChartData The data to attach and generate the chart Source: donut.js Requires module:d3-dispatch, Methods module:Donut(_selection, _data) This function creates the graph using the selection as container Parameters: Name Type Description _selection D3Selection A d3 selection that represents the container(s) where the chart(s) will be rendered _data DonutChartData The data to attach and generate the chart Source: donut.js &lt;static&gt; colorSchema(_x) Gets or Sets the colorSchema of the chart Parameters: Name Type Description _x Array.&lt;String&gt; Desired colorSchema for the graph Source: donut.js Returns: Current colorSchema or Chart module to chain calls Type colorSchema | module &lt;static&gt; exportChart() Chart exported to png and a download action is fired Source: donut.js &lt;static&gt; externalRadius(_x) Gets or Sets the externalRadius of the chart Parameters: Name Type Description _x Number ExternalRadius number to get/set Source: donut.js Returns: Current externalRadius or Donut Chart module to chain calls Type Number | Module &lt;static&gt; height(_x) Gets or Sets the height of the chart Parameters: Name Type Description _x Number Desired width for the graph Source: donut.js Returns: Current height or Donut Chart module to chain calls Type Number | Module &lt;static&gt; internalRadius(_x) Gets or Sets the internalRadius of the chart Parameters: Name Type Description _x Number InternalRadius number to get/set Source: donut.js Returns: Current internalRadius or Donut Chart module to chain calls Type Number | Module &lt;static&gt; margin(_x) Gets or Sets the margin of the chart Parameters: Name Type Description _x Object Margin object to get/set Source: donut.js Returns: Current margin or Donut Chart module to chain calls Type Number | Module &lt;static&gt; on() Exposes an 'on' method that acts as a bridge with the event dispatcher We are going to expose this events: customMouseOver, customMouseMove and customMouseOut Source: donut.js Returns: Bar Chart Type module &lt;static&gt; width(_x) Gets or Sets the width of the chart Parameters: Name Type Description _x Number Desired width for the graph Source: donut.js Returns: Current width or Donut Chart module to chain calls Type Number | Module × Search results Close "},"module-Legend.html":{"id":"module-Legend.html","title":"API: Legend","body":" API BarBrushDonutLegendLineMini-tooltipSparklineStacked-areaStepTooltip Demos _CONTRIBUTING_GETTINGSTARTEDbarbrushdonutkitchen-sinklinesparklinestacked-areastep Global Global API: Legend Legend Component reusable API class that renders a simple and configurable legend element. (require(&quot;Legend&quot;))(_selection, _data) This function creates the graph using the selection as container Parameters: Name Type Description _selection D3Selection A d3 selection that represents the container(s) where the chart(s) will be rendered _data object The data to attach and generate the chart Source: legend.js Requires module:d3 Methods module:Legend(_selection, _data) This function creates the graph using the selection as container Parameters: Name Type Description _selection D3Selection A d3 selection that represents the container(s) where the chart(s) will be rendered _data object The data to attach and generate the chart Source: legend.js &lt;static&gt; clearHighlight() Clears the highlighted line entry Source: legend.js &lt;static&gt; colorSchema(_x) Gets or Sets the colorSchema of the chart Parameters: Name Type Description _x Array Color scheme array to get/set Source: legend.js Returns: Current colorSchema or Donut Chart module to chain calls Type Number | Module &lt;static&gt; height(_x) Gets or Sets the height of the legend chart Parameters: Name Type Description _x number Desired width for the chart Source: legend.js Returns: Current height or Legend module to chain calls Type height | module &lt;static&gt; highlight(entryId) Highlights a line entry by fading the rest of lines Parameters: Name Type Description entryId number ID of the entry line Source: legend.js &lt;static&gt; margin(_x) Gets or Sets the margin of the legend chart Parameters: Name Type Description _x object Margin object to get/set Source: legend.js Returns: Current margin or Legend module to chain calls Type margin | module &lt;static&gt; width(_x) Gets or Sets the width of the legend chart Parameters: Name Type Description _x number Desired width for the graph Source: legend.js Returns: Current width or Legend module to chain calls Type width | module × Search results Close "},"module-Line.html":{"id":"module-Line.html","title":"API: Line","body":" API BarBrushDonutLegendLineMini-tooltipSparklineStacked-areaStepTooltip Demos _CONTRIBUTING_GETTINGSTARTEDbarbrushdonutkitchen-sinklinesparklinestacked-areastep Global Global API: Line Line Chart reusable API module that allows us rendering a multi line and configurable chart. (require(&quot;Line&quot;))(_selection, _data) This function creates the graph using the selection and data provided Parameters: Name Type Description _selection D3Selection A d3 selection that represents the container(s) where the chart(s) will be rendered _data LineChartData The data to attach and generate the chart Source: line.js Requires module:d3-array, Members &lt;static&gt; axisTimeCombinations constants to be used to force the x axis to respect a certain granularity current options: HOUR_DAY, DAY_MONTH, MONTH_YEAR Source: line.js Example line.forceAxisFormat(line.axisTimeCombinations.HOUR_DAY) Methods module:Line(_selection, _data) This function creates the graph using the selection and data provided Parameters: Name Type Description _selection D3Selection A d3 selection that represents the container(s) where the chart(s) will be rendered _data LineChartData The data to attach and generate the chart Source: line.js &lt;static&gt; aspectRatio(_x) Gets or Sets the aspect ratio of the chart Parameters: Name Type Description _x Number Desired aspect ratio for the graph Source: line.js Returns: Current aspect ratio or Line Chart module to chain calls Type Number | Module &lt;static&gt; colorSchema(_x) Gets or Sets the colorSchema of the chart Parameters: Name Type Description _x Array.&lt;String&gt; Desired colorSchema for the graph Source: line.js Returns: Current colorSchema or Chart module to chain calls Type colorSchema | module &lt;static&gt; exportChart() Chart exported to png and a download action is fired Source: line.js &lt;static&gt; forceAxisFormat(_x) Exposes the ability to force the chart to show a certain x axis grouping Parameters: Name Type Description _x String Desired format Source: line.js Returns: Current format or module to chain calls Type String | Module &lt;static&gt; height(_x) Gets or Sets the height of the chart Parameters: Name Type Description _x Number Desired width for the graph Source: line.js Returns: Current height or Line Chart module to chain calls Type Number | Module &lt;static&gt; margin(_x) Gets or Sets the margin of the chart Parameters: Name Type Description _x Object Margin object to get/set Source: line.js Returns: Current margin or Line Chart module to chain calls Type Number | Module &lt;static&gt; on() Exposes an 'on' method that acts as a bridge with the event dispatcher We are going to expose this events: customMouseHover, customMouseMove and customMouseOut Source: line.js Returns: Bar Chart Type module &lt;static&gt; tooltipThreshold(_x) Gets or Sets the minimum width of the graph in order to show the tooltip NOTE: This could also depend on the aspect ratio Parameters: Name Type Description _x Number Desired tooltip threshold for the graph Source: line.js Returns: Current tooltip threshold or Line Chart module to chain calls Type Number | Module &lt;static&gt; width(_x) Gets or Sets the width of the chart Parameters: Name Type Description _x Number Desired width for the graph Source: line.js Returns: Current width or Line Chart module to chain calls Type Number | Module × Search results Close "},"module-Mini-tooltip.html":{"id":"module-Mini-tooltip.html","title":"API: Mini-tooltip","body":" API BarBrushDonutLegendLineMini-tooltipSparklineStacked-areaStepTooltip Demos _CONTRIBUTING_GETTINGSTARTEDbarbrushdonutkitchen-sinklinesparklinestacked-areastep Global Global API: Mini-tooltip Mini Tooltip Component reusable API class that renders a simple and configurable tooltip element for Britechart's bar and step chart. (require(&quot;Mini-tooltip&quot;))(_selection, _data) This function creates the graph using the selection as container Parameters: Name Type Description _selection D3Selection A d3 selection that represents the container(s) where the chart(s) will be rendered _data Array The data to attach and generate the chart (usually an empty array) Source: mini-tooltip.js Requires module:d3 Methods module:Mini-tooltip(_selection, _data) This function creates the graph using the selection as container Parameters: Name Type Description _selection D3Selection A d3 selection that represents the container(s) where the chart(s) will be rendered _data Array The data to attach and generate the chart (usually an empty array) Source: mini-tooltip.js &lt;static&gt; hide() Hides the tooltip Source: mini-tooltip.js Returns: Tooltip module to chain calls Type Module &lt;static&gt; nameLabel(_x) Gets or Sets data's nameLabel Parameters: Name Type Description _x text Desired nameLabel Source: mini-tooltip.js Returns: nameLabel or Step Chart module to chain calls Type text | module &lt;static&gt; show() Shows the tooltip Source: mini-tooltip.js Returns: Tooltip module to chain calls Type Module &lt;static&gt; title(_x) Gets or Sets the title of the tooltip Parameters: Name Type Description _x string Desired title Source: mini-tooltip.js Returns: Current title or module to chain calls Type string | module &lt;static&gt; update(dataPoint, mousePosition, chartSize) Updates the position and content of the tooltip Parameters: Name Type Description dataPoint Object Datapoint of the hovered element mousePosition Array Mouse position relative to the parent chart [x, y] chartSize Array Parent chart size [x, y] Source: mini-tooltip.js Returns: Current component Type module × Search results Close "},"module-Sparkline.html":{"id":"module-Sparkline.html","title":"API: Sparkline","body":" API BarBrushDonutLegendLineMini-tooltipSparklineStacked-areaStepTooltip Demos _CONTRIBUTING_GETTINGSTARTEDbarbrushdonutkitchen-sinklinesparklinestacked-areastep Global Global API: Sparkline Sparkline Chart reusable API module that allows us rendering a sparkline configurable chart. (require(&quot;Sparkline&quot;))(_selection, _data) This function creates the graph using the selection and data provided Parameters: Name Type Description _selection D3Selection A d3 selection that represents the container(s) where the chart(s) will be rendered _data SparklineChartData The data to attach and generate the chart Source: sparkline.js Requires module:d3 Methods module:Sparkline(_selection, _data) This function creates the graph using the selection and data provided Parameters: Name Type Description _selection D3Selection A d3 selection that represents the container(s) where the chart(s) will be rendered _data SparklineChartData The data to attach and generate the chart Source: sparkline.js &lt;static&gt; areaGradient(_x) Gets or Sets the areaGradient of the chart Parameters: Name Type Description _x Array.&lt;String&gt; Desired areaGradient for the graph Source: sparkline.js Returns: Current areaGradient or Chart module to chain calls Type areaGradient | module &lt;static&gt; dateLabel(_x) Gets or Sets the dateLabel of the chart Parameters: Name Type Description _x Number Desired dateLabel for the graph Source: sparkline.js Returns: Current dateLabel or Chart module to chain calls Type dateLabel | module &lt;static&gt; duration(_x) Gets or Sets the duration of the animation Parameters: Name Type Description _x Number Desired animation duration for the graph Source: sparkline.js Returns: Current animation duration or Chart module to chain calls Type dateLabel | module &lt;static&gt; exportChart() Chart exported to png and a download action is fired Source: sparkline.js &lt;static&gt; height(_x) Gets or Sets the height of the chart Parameters: Name Type Description _x Number Desired width for the graph Source: sparkline.js Returns: Current height or Chart module to chain calls Type height | module &lt;static&gt; isAnimated(_x) Gets or Sets the isAnimated property of the chart Parameters: Name Type Description _x Boolean Desired animation flag Source: sparkline.js Returns: Current isAnimated flag or Chart module Type isAnimated | module &lt;static&gt; lineGradient(_x) Gets or Sets the lineGradient of the chart Parameters: Name Type Description _x Array.&lt;String&gt; Desired lineGradient for the graph Source: sparkline.js Returns: Current lineGradient or Chart module to chain calls Type lineGradient | module &lt;static&gt; margin(_x) Gets or Sets the margin of the chart Parameters: Name Type Description _x Object Margin object to get/set Source: sparkline.js Returns: Current margin or Chart module to chain calls Type margin | module &lt;static&gt; valueLabel(_x) Gets or Sets the valueLabel of the chart Parameters: Name Type Description _x Number Desired valueLabel for the graph Source: sparkline.js Returns: Current valueLabel or Chart module to chain calls Type valueLabel | module &lt;static&gt; width(_x) Gets or Sets the width of the chart Parameters: Name Type Description _x Number Desired width for the graph Source: sparkline.js Returns: Current width or Chart module to chain calls Type width | module × Search results Close "},"module-Stacked-area.html":{"id":"module-Stacked-area.html","title":"API: Stacked-area","body":" API BarBrushDonutLegendLineMini-tooltipSparklineStacked-areaStepTooltip Demos _CONTRIBUTING_GETTINGSTARTEDbarbrushdonutkitchen-sinklinesparklinestacked-areastep Global Global API: Stacked-area Stacked Area Chart reusable API module that allows us rendering a multi area and configurable chart. (require(&quot;Stacked-area&quot;))(_selection, _data) This function creates the graph using the selection and data provided Parameters: Name Type Description _selection D3Selection A d3 selection that represents the container(s) where the chart(s) will be rendered _data Object The data to attach and generate the chart Source: stacked-area.js Requires module:d3-array, Methods module:Stacked-area(_selection, _data) This function creates the graph using the selection and data provided Parameters: Name Type Description _selection D3Selection A d3 selection that represents the container(s) where the chart(s) will be rendered _data Object The data to attach and generate the chart Source: stacked-area.js &lt;static&gt; colorSchema(_x) Gets or Sets the colorSchema of the chart Parameters: Name Type Description _x Array.&lt;String&gt; Desired colorSchema for the graph Source: stacked-area.js Returns: Current colorSchema or Chart module to chain calls Type colorSchema | module &lt;static&gt; dateLabel(_x) Gets or Sets the dateLabel of the chart Parameters: Name Type Description _x Number Desired dateLabel for the graph Source: stacked-area.js Returns: Current dateLabel or Chart module to chain calls Type dateLabel | module &lt;static&gt; exportChart() Chart exported to png and a download action is fired Source: stacked-area.js &lt;static&gt; height(_x) Gets or Sets the height of the chart Parameters: Name Type Description _x Number Desired width for the graph Source: stacked-area.js Returns: Current height or Area Chart module to chain calls Type height | module &lt;static&gt; margin(_x) Gets or Sets the margin of the chart Parameters: Name Type Description _x Object Margin object to get/set Source: stacked-area.js Returns: Current margin or Area Chart module to chain calls Type margin | module &lt;static&gt; on() Exposes an 'on' method that acts as a bridge with the event dispatcher We are going to expose this events: customMouseOver, customMouseMove and customMouseOut Source: stacked-area.js Returns: Bar Chart Type module &lt;static&gt; tooltipThreshold(_x) Gets or Sets the tooltipThreshold of the chart Parameters: Name Type Description _x Object Margin object to get/set Source: stacked-area.js Returns: Current tooltipThreshold or Area Chart module to chain calls Type tooltipThreshold | module &lt;static&gt; valueLabel(_x) Gets or Sets the valueLabel of the chart Parameters: Name Type Description _x Number Desired valueLabel for the graph Source: stacked-area.js Returns: Current valueLabel or Chart module to chain calls Type valueLabel | module &lt;static&gt; width(_x) Gets or Sets the width of the chart Parameters: Name Type Description _x Number Desired width for the graph Source: stacked-area.js Returns: Current width or Area Chart module to chain calls Type width | module × Search results Close "},"module-Step.html":{"id":"module-Step.html","title":"API: Step","body":" API BarBrushDonutLegendLineMini-tooltipSparklineStacked-areaStepTooltip Demos _CONTRIBUTING_GETTINGSTARTEDbarbrushdonutkitchen-sinklinesparklinestacked-areastep Global Global API: Step Step Chart reusable API class that renders a simple and configurable step chart. (require(&quot;Step&quot;))(_selection, _data) This function creates the graph using the selection as container Parameters: Name Type Description _selection D3Selection A d3 selection that represents the container(s) where the chart(s) will be rendered _data StepChartData The data to attach and generate the chart Source: step.js Requires module:d3-array, Methods module:Step(_selection, _data) This function creates the graph using the selection as container Parameters: Name Type Description _selection D3Selection A d3 selection that represents the container(s) where the chart(s) will be rendered _data StepChartData The data to attach and generate the chart Source: step.js &lt;static&gt; exportChart() Chart exported to png and a download action is fired Source: step.js &lt;static&gt; exportChart() Chart exported to png and a download action is fired Source: step.js &lt;static&gt; height(_x) Gets or Sets the height of the chart Parameters: Name Type Description _x number Desired width for the graph Source: step.js Returns: Current height or Step Chart module to chain calls Type height | module &lt;static&gt; margin(_x) Gets or Sets the margin of the chart Parameters: Name Type Description _x object Margin object to get/set Source: step.js Returns: Current margin or Step Chart module to chain calls Type margin | module &lt;static&gt; numOfVerticalTicks(_x) Gets or Sets the number of vertical ticks on the chart Parameters: Name Type Description _x number Desired width for the graph Source: step.js Returns: Current height or Step Chart module to chain calls Type height | module &lt;static&gt; on() Exposes an 'on' method that acts as a bridge with the event dispatcher We are going to expose this events: customMouseOver, customMouseMove and customMouseOut Source: step.js Returns: Bar Chart Type module &lt;static&gt; width(_x) Gets or Sets the width of the chart Parameters: Name Type Description _x number Desired width for the graph Source: step.js Returns: Current width or step Chart module to chain calls Type width | module &lt;static&gt; xAxisLabel(_x) Gets or Sets the text of the xAxisLabel on the chart Parameters: Name Type Description _x text Desired text for the label Source: step.js Returns: label or Step Chart module to chain calls Type text | module &lt;static&gt; xAxisLabelOffset(_x) Gets or Sets the offset of the xAxisLabel on the chart Parameters: Name Type Description _x integer Desired offset for the label Source: step.js Returns: label or Step Chart module to chain calls Type integer | module &lt;static&gt; yAxisLabel(_x) Gets or Sets the text of the yAxisLabel on the chart Parameters: Name Type Description _x text Desired text for the label Source: step.js Returns: label or Step Chart module to chain calls Type text | module &lt;static&gt; yAxisLabelOffset(_x) Gets or Sets the offset of the yAxisLabel on the chart Parameters: Name Type Description _x integer Desired offset for the label Source: step.js Returns: label or Step Chart module to chain calls Type integer | module × Search results Close "},"module-Tooltip.html":{"id":"module-Tooltip.html","title":"API: Tooltip","body":" API BarBrushDonutLegendLineMini-tooltipSparklineStacked-areaStepTooltip Demos _CONTRIBUTING_GETTINGSTARTEDbarbrushdonutkitchen-sinklinesparklinestacked-areastep Global Global API: Tooltip Tooltip Component reusable API class that renders a simple and configurable tooltip element for Britechart's line chart or stacked area chart. (require(&quot;Tooltip&quot;))(_selection, _data) This function creates the graph using the selection as container Parameters: Name Type Description _selection D3Selection A d3 selection that represents the container(s) where the chart(s) will be rendered _data Object The data to attach and generate the chart Source: tooltip.js Requires module:d3-array, Members &lt;static&gt; axisTimeCombinations constants to be used to force the x axis to respect a certain granularity current options: HOUR_DAY, DAY_MONTH, MONTH_YEAR Source: tooltip.js Example tooltip.forceDateRange(tooltip.axisTimeCombinations.HOUR_DAY) Methods module:Tooltip(_selection, _data) This function creates the graph using the selection as container Parameters: Name Type Description _selection D3Selection A d3 selection that represents the container(s) where the chart(s) will be rendered _data Object The data to attach and generate the chart Source: tooltip.js &lt;static&gt; dateLabel(_x) Gets or Sets the dateLabel of the data Parameters: Name Type Description _x Number Desired dateLabel Source: tooltip.js Returns: Current dateLabel or Chart module to chain calls Type dateLabel | module &lt;static&gt; forceDateRange(_x) Exposes the ability to force the tooltip to use a certain date format Parameters: Name Type Description _x String Desired format Source: tooltip.js Returns: Current format or module to chain calls Type String | Module &lt;static&gt; hide() Hides the tooltip Source: tooltip.js Returns: Tooltip module to chain calls Type Module &lt;static&gt; show() Shows the tooltip Source: tooltip.js Returns: Tooltip module to chain calls Type Module &lt;static&gt; title(_x) Gets or Sets the title of the tooltip Parameters: Name Type Description _x string Desired title Source: tooltip.js Returns: Current title or module to chain calls Type string | module &lt;static&gt; topicLabel(_x) Gets or Sets the topicLabel of the data Parameters: Name Type Description _x Number Desired topicLabel Source: tooltip.js Returns: Current topicLabel or Chart module to chain calls Type topicLabel | module &lt;static&gt; update(dataPoint, colorMapping, position) Updates the position and content of the tooltip Parameters: Name Type Description dataPoint Object Datapoint to represent colorMapping Object Color scheme of the topics position Number X-scale position in pixels Source: tooltip.js Returns: Tooltip module to chain calls Type Module &lt;static&gt; valueLabel(_x) Gets or Sets the valueLabel of the data Parameters: Name Type Description _x Number Desired valueLabel Source: tooltip.js Returns: Current valueLabel or Chart module to chain calls Type valueLabel | module × Search results Close "},"tutorial--_CONTRIBUTING.html":{"id":"tutorial--_CONTRIBUTING.html","title":"Tutorial: _CONTRIBUTING","body":" API BarBrushDonutLegendLineMini-tooltipSparklineStacked-areaStepTooltip Demos _CONTRIBUTING_GETTINGSTARTEDbarbrushdonutkitchen-sinklinesparklinestacked-areastep Global Global _CONTRIBUTING Pull Requests####Disclaimer While it is true that Britecharts is currently live in Eventbrite production, this project is not being monitored closely for open source contributions. Please have patience and we will get to any issues and pull requests as soon as we can. Chart DocumentationIn order to generate and see the documentation for the library you would need to: Download and install node (note we need npm version 2.X) Install the grunt task runner (if you don't have it yet) with: npm install -g grunt-cli Clone the repository with: git clone git@github.com:eventbrite/britecharts.git Change directory into the repository root and install its dependencies: npm install In the root or the repository folder, run: npm run demos:watch In another terminal, run: npm run demos:serve In a third terminal window, run: npm run docs This process will generate the docs with its current contents and open the interface where you will be able to navigate the API of each chart. You can also see some use examples under the &quot;Tutorials&quot; dropdown section. Getting setup to contribute1- Fork repository by clicking the fork button on github 2- Clone repository with git clone https://github.com/&lt;your handle&gt;/britecharts.git 3- Navigate to the repository folder and install dependencies with: npm install Cutting feature branches1- in local master, set upstream to https://github.com/eventbrite/britecharts.git git remote add upstream https://github.com/eventbrite/britecharts.git 2- pull the most recent changesgit pull upstream master 3- branch name should be prefixed with either fix-or feat- depending on pr content. Create a new branch git co -b [fix|feat]-&lt;your branch name&gt; Making pull requests1- when you're finished coding, git checkout master 2- git pull upstream master (note that your local master should always reflect upstream master) 3- git checkout &lt;your branch&gt; 4- git rebase master &amp; reconcile all conflicts 5- git push origin &lt;your branch&gt; 6- make your pr with a link to the original issue filed (if you see &quot;unable to merge&quot;, please pull from your upstream and rebase again) 7- be patient :) Reporting an Issue/Feature RequestsPlease use the issues section of the Britecharts github profile to submit any bugs found. Please be descriptive and feel free to add pictures or links to docs to make your point as clear as possible. StandardsWe have followed a couple of standards outside of the regular Eventbrite workflow in this project: JSDoc comments and Test Driven Development. Test Driven DevelopmentD3 charts are complex systems. As other Software Development projects, they start simple and become really bloated at the end of the process. To overcome this, we have followed a component approach that allows us to create easily testable units. We have chosen Karma as our test runner, and Jasmine as our unit-testing library. To install Karma and start running test you would need to follow this steps: 1- Fork repository by clicking the fork button on github 2- Clone repository with: git clone https://github.com/&lt;your handle&gt;/britecharts.git3- Get into the repository folder and install dependencies with: npm install4- Run the tests with: npm run testThis process will watch the test and spec files, re-running the tests when those change. JSDocJSDoc is an API documentation generator. It allows us to follow a methodology when commenting our code, so that later we can automatically generate documentation from these comments. Check it's getting started guide to know more about it. We are also using Grunt and a grunt task to generate the documentation. The WorkflowES6 transpilingBritecharts modules are written in ES6, so we would need to create an ES5-compatible version of the charts before releasing a new version. In order to work with the development version of the charts, we just need to run: npm run devHowever, if you want to use the production version of the charts, you should run: npm run build:allNPM TasksThe build sequence consists of a small set of Node tasks. While you'll probably only need npm run test and npm run prod most of the time, the other tasks can be called independently or combined in order to see the docs. Task Description npm run prod Build everything and generate the distribution version of the charts. npm run release Create a new release of the library. npm run test Start the Karma runner that will test the project and keep watching for changes. npm run demos:compile Compiles our demo files. npm run demos:watch Watches for changes in our demo files. npm run demos:serve Serves the demos for our tutorials. npm run docs Compiles the docs with JSDoc and opens a browser showing them. **Note that for running npm run docs, you will need to first have npm run demos:watch and npm run demos:serve in two different terminal windows. Project StructureThe default directory structure looks something like this: britecharts ├── demos ├── dist ├── docs ├── src │ ├── charts │ ├── doc │ ├── fonts │ └── tasks └── test ├── fixtures ├── json ├── specs └── tools Folder Description demos Where we keep demo files for each of our charts and some extra docs dist Where the production ready versions of our charts will be placed docs Where the generated documentation website lives src Where we will place the code we create src/charts Where our charts live src/doc Where the templates and configuration for our docs are src/fonts Our fonts src/tasks Some of our grunt tasks configuration test Where our test related files live test/fixtures Tools for generate data for our charts demos and tests test/json Raw data for our charts test/specs Our tests for the charts test/tools Miscelaneous tools × Search results Close "},"tutorial--_GETTINGSTARTED.html":{"id":"tutorial--_GETTINGSTARTED.html","title":"Tutorial: _GETTINGSTARTED","body":" API BarBrushDonutLegendLineMini-tooltipSparklineStacked-areaStepTooltip Demos _CONTRIBUTING_GETTINGSTARTEDbarbrushdonutkitchen-sinklinesparklinestacked-areastep Global Global _GETTINGSTARTED Getting Started with BritechartsIn this document, we show you the 3 main use cases you as developer will find when working with Britecharts: Using Britecharts in your projectIn order to use a Britecharts chart in your project you would need to: Add Britecharts as a dependency in your package.json (not needed in core). &quot;britecharts&quot;: &quot;http://packages:8889/package/britecharts/1.0.13&quot; Require the proper chart as a requirejs module, for example, in core we do: LineChart = require('britecharts/umd/line.min') Require D3 as a dependency too. d3 = require('d3') Call the chart with a container and data attached to the container. var container = d3.select(config.containerSelector), lineChart = new LineChart(); if (container.node()) { lineChart .tooltipThreshold(config.tooltipShouldShowThreshold) .margin(config.chartMargin) .height(config.chartHeight) .width(config.chartWidth); } // This line mixes together container, data and chart container.datum(data).call(lineChart);And that would generate your britechart! You will probably want to set up a listener for the resize event to re-render the chart. Modifying a chartWe have created this charts with Tests First, and we encourage you to do the same. However, you can also write tests later. For a TDD workflow, the process would look like this: Create a new branch for your modification Find the test of the chart you want to modify in /test/specs/*.spec.js Write a failing test for the API accessor or the feature you want to add Check that it fails Write the code that would make that test pass Make the test pass Update the comments so that the proper documentation gets generated when runningnpm run docs Check the demos to see the code in action (you can also add a new demo there if necessary) Create a pull request and ask people of the team to review it Once you have a shipit, merge it! If you are using it on core, you will need to release a new version of Britecharts:npm run release Update the new version number on npm.json and npm-shinkwrap.json Build your core-frontend container and reload your environment Creating a new chartAdding a new chart is a bunch of work, but we hope the current code and documentation will help you in the process. Create a new branch for your new chart Create a file for the tests and the chart (on src/charts and test/specs) Create a file for the demo too, and it's corresponding html (find them on demos/) Using the bar chart tests as a jumpstart, add one test and make it fail Write the code that makes that test pass and keep on adding tests Once you think you are close to have something working, start adding JSDoc comments to your code Generate your docs with: npm run docs Create a pull request with your branch and ping one of the core authors to get it reviewed Once you have a shipit, merge it If you are using it on core, you will need to release a new version of Britecharts: npm run release Update the new version number on npm.json and npm-shinkwrap.json Build your core-frontend container and reload your environment × Search results Close "},"tutorial-bar.html":{"id":"tutorial-bar.html","title":"Tutorial: bar","body":" Bar Chart with Tooltip The code barChart .width(containerWidth) .height(300) .on('customMouseHover', tooltip.show) .on('customMouseMove', tooltip.update); .on('customMouseOut', tooltip.hide); barContainer.datum(dataset).call(barChart); tooltipContainer = d3.select('.bar-chart .metadata-group'); tooltipContainer.datum([]).call(tooltip); Export Chart You can also export this chart by pressing Horizontal Bar Chart The code barChart .horizontal(true) .width(containerWidth) .height(300); barContainer.datum(dataset).call(barChart); Simple Bar Chart The code barChart .width(containerWidth) .height(300); barContainer.datum(dataset).call(barChart); × Search results Close "},"tutorial-brush.html":{"id":"tutorial-brush.html","title":"Tutorial: brush","body":" Simple Brush Chart Selected from to Brush chart to use with other charts as a time range selector. The code brushChart .width(containerWidth) .height(300) .onBrush(function(brushExtent) { // Do something with the brushExtent }); brushContainer.datum(dataset).call(brushChart); × Search results Close "},"tutorial-donut.html":{"id":"tutorial-donut.html","title":"Tutorial: donut","body":" Donut Chart with Legend The code donutChart .width(containerWidth) .height(containerWidth) .externalRadius(containerWidth/2.5) .internalRadius(containerWidth/5) .colorScheme(briteChartsColors) .on('customMouseOver', function(data) { legendChart.highlight(data.data.id); }) .on('customMouseOut', function() { legendChart.clearHighlight(); }); donutContainer.datum(dataset).call(donutChart); legendContainer.datum(dataset).call(legendChart); Colors You can also check other color schemas: Export Chart You can also export this chart by pressing: Simple Donut Chart The code donutChart .width(containerWidth) .height(containerWidth) .externalRadius(containerWidth/4) .internalRadius(containerWidth/8); donutContainer.datum(dataset).call(donutChart); × Search results Close "},"tutorial-kitchen-sink.html":{"id":"tutorial-kitchen-sink.html","title":"Tutorial: kitchen-sink","body":" Bar Chart Horizontal Bar Chart Line Chart Donut Chart Brush Chart Selected from to Step Chart Stacked Area Chart × Search results Close "},"tutorial-line.html":{"id":"tutorial-line.html","title":"Tutorial: line","body":" Line Chart with fixed Aspect Ratio The code lineChart .aspectRatio(0.5) .tooltipThreshold(600) .width(containerWidth); container.datum(dataset).call(lineChart); Colors You can also check other color schemas: Export Chart You can also export this chart by pressing: Line Chart with a single data source This is the same chart as above, but when there is a single data source we apply a gradient to the line to give it a little flair. This chart has a fixed height like the one below. The code lineChart .tooltipThreshold(600) .height(300) .width(containerWidth); container.datum(dataset).call(lineChart); Export Chart You can also export this chart by pressing: Line Chart with Fixed Height In this case, we have set a fixed height on the chart, as we are currently doing on the Sales report: The code lineChart .tooltipThreshold(600) .height(300) .width(containerWidth); container.datum(dataset).call(lineChart); × Search results Close "},"tutorial-sparkline.html":{"id":"tutorial-sparkline.html","title":"Tutorial: sparkline","body":" Sparkline Chart This is the sparkline chart used for showing trends in data over time. We have included a resize listener to show how the different charts respond to changes on the viewport. The code sparklineChart .dateLabel('dateUTC') .isAnimated(true) .duration(2500) .height(containerWidth / 3) .width(containerWidth / 2); container.datum(dataset) .call(sparklineChart); Export Chart You can also export this chart by pressing: × Search results Close "},"tutorial-stacked-area.html":{"id":"tutorial-stacked-area.html","title":"Tutorial: stacked-area","body":" Stacked Area Chart with Tooltip The code // StackedAreChart Setup and start stackedArea .tooltipThreshold(400) .width(containerWidth) .on('customMouseOver', function() { chartTooltip.show(); }) .on('customMouseMove', function(dataPoint, topicColorMap, dataPointXPosition) { chartTooltip.update(dataPoint, topicColorMap, dataPointXPosition); }) .on('customMouseOut', function() { chartTooltip.hide(); }); container.datum(dataset.data).call(stackedArea); // Tooltip Setup and start chartTooltip .title('Testing tooltip'); // Note that if the viewport width is less than the tooltipThreshold value, // this container won't exist, and the tooltip won't show up tooltipContainer = d3.select('.metadata-group .vertical-marker-container'); tooltipContainer.datum([]).call(chartTooltip); Colors You can also check other color schemas: Export Chart You can also export this chart by pressing: × Search results Close "},"tutorial-step.html":{"id":"tutorial-step.html","title":"Tutorial: step","body":" Step Chart The code // StepChart without Axis Labels: stepChart .width(500) .height(300); stepContainer.datum(dataset).call(stepChart); // StepChart with Axis Labels: // If the labels get cutoff when added, it's a good idea // to tweak the left margin to get the look you want stepChart .width(500) .height(300) .xAxisLabel('Fruit Type') .xAxisLabelOffset(45) .yAxisLabel('Quantity') .yAxisLabelOffset(-45) .margin({ top: 20, right: 20, bottom: 30, left: 65 }); stepContainer.datum(dataset).call(stepChart); Export Chart You can also export this chart by pressing: × Search results Close "}}
    </script>

    <script type="text/javascript">
        $(document).ready(function() {
            Searcher.init();
        });

        $(window).on("message", function(msg) {
            var msgData = msg.originalEvent.data;

            if (msgData.msgid != "docstrap.quicksearch.start") {
                return;
            }

            var results = Searcher.search(msgData.searchTerms);

            window.parent.postMessage({"results": results, "msgid": "docstrap.quicksearch.done"}, "*");
        });
    </script>
</body>
</html>
