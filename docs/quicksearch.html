<html>
<head>
</head>
<body style="background: transparent;">
    <script src="scripts/docstrap.lib.js"></script>
    <script src="scripts/lunr.min.js"></script>
    <script src="scripts/fulltext-search.js"></script>

    <script type="text/x-docstrap-searchdb">
    {"stacked-area.js.html":{"id":"stacked-area.js.html","title":"Source: stacked-area.js","body":" Getting started Demos Bar Chart Brush Chart Donut Chart Grouped Bar Chart Kitchen Sink Line Chart Sparkline Chart Stacked Area Chart Stacked Bar Chart Step Chart API Bar Brush Donut Grouped-bar Legend Line Mini-tooltip Sparkline Stacked-area Stacked-bar Step Tooltip Types Github Twitter Source: stacked-area.js define(function(require){ 'use strict'; const d3Array = require('d3-array'); const d3Axis = require('d3-axis'); const d3Collection = require('d3-collection'); const d3Dispatch = require('d3-dispatch'); const d3Ease = require('d3-ease'); const d3Scale = require('d3-scale'); const d3Shape = require('d3-shape'); const d3Selection = require('d3-selection'); const d3Transition = require('d3-transition'); const d3TimeFormat = require('d3-time-format'); const assign = require('lodash.assign'); const {exportChart} = require('./helpers/exportChart'); const colorHelper = require('./helpers/colors'); const { getXAxisSettings, getLocaleDateFormatter } = require('./helpers/timeAxis'); const {isInteger} = require('./helpers/common'); const {axisTimeCombinations} = require('./helpers/constants'); const { formatIntegerValue, formatDecimalValue } = require('./helpers/formatHelpers'); const { addDays, diffDays } = require('./helpers/common'); const uniq = (arrArg) =&gt; arrArg.filter((elem, pos, arr) =&gt; arr.indexOf(elem) === pos); /** * @typdef D3Layout * @type function */ /** * @typedef areaChartData * @type {Object} * @property {Object[]} data All data entries * @property {String} date Date of the entry * @property {String} name Name of the entry * @property {Number} value Value of the entry * * @example * { * 'data': [ * { * &quot;date&quot;: &quot;2011-01-05T00:00:00Z&quot;, * &quot;name&quot;: &quot;Direct&quot;, * &quot;value&quot;: 0 * } * ] * } */ /** * Stacked Area Chart reusable API module that allows us * rendering a multi area and configurable chart. * * @module Stacked-area * @tutorial stacked-area * @requires d3-array, d3-axis, d3-collection, d3-ease, d3-scale, d3-shape, d3-selection, d3-time, d3-time-format * * @example * let stackedArea = stackedArea(); * * stackedArea * .width(containerWidth); * * d3Selection.select('.css-selector') * .datum(dataset.data) * .call(stackedArea); * */ return function module() { let margin = { top: 70, right: 30, bottom: 60, left: 70 }, width = 960, height = 500, xScale, xAxis, xMonthAxis, yScale, yAxis, aspectRatio = null, monthAxisPadding = 30, yTicks = 5, yTickTextYOffset = -8, yTickTextXOffset = -20, tickPadding = 5, colorSchema = colorHelper.colorSchemas.britecharts, lineGradient = colorHelper.colorGradients.greenBlue, areaOpacity = 0.24, highlightCircleSize = 12, highlightCircleRadius = 5, highlightCircleStroke = 2, categoryColorMap, order, topicsOrder, xAxisFormat = null, xTicks = null, xAxisCustomFormat = null, locale, baseLine, layers, series, layersInitial, area, areaOutline, // Area Animation maxAreaNumber = 8, areaAnimationDelayStep = 20, areaAnimationDelays = d3Array.range(areaAnimationDelayStep, maxAreaNumber* areaAnimationDelayStep, areaAnimationDelayStep), overlay, overlayColor = 'rgba(0, 0, 0, 0)', verticalMarkerContainer, verticalMarkerLine, epsilon, dataPoints = {}, pointsSize = 1.5, pointsColor = '#c0c6cc', pointsBorderColor = '#ffffff', isAnimated = false, ease = d3Ease.easeQuadInOut, areaAnimationDuration = 1000, svg, chartWidth, chartHeight, data, dataByDate, dataByDateFormatted, dataByDateZeroed, verticalGridLines, horizontalGridLines, grid = null, tooltipThreshold = 480, xAxisPadding = { top: 0, left: 15, bottom: 0, right: 0 }, dateLabel = 'date', valueLabel = 'value', keyLabel = 'name', emptyDataConfig = { minDate: new Date(new Date().setDate(new Date().getDate()-30)), maxDate: new Date(), maxY: 500 }, isUsingFakeData = false, // getters getName = ({name}) =&gt; name, getDate = ({date}) =&gt; date, // events dispatcher = d3Dispatch.dispatch('customMouseOver', 'customMouseOut', 'customMouseMove', 'customDataEntryClick'); /** * This function creates the graph using the selection and data provided * @param {D3Selection} _selection A d3 selection that represents * the container(s) where the chart(s) will be rendered * @param {areaChartData} _data The data to attach and generate the chart */ function exports(_selection) { _selection.each(function(_data) { chartWidth = width - margin.left - margin.right; chartHeight = height - margin.top - margin.bottom; data = cleanData(_data); dataByDate = getDataByDate(data); buildLayers(); buildScales(); buildSVG(this); buildAxis(); drawAxis(); drawStackedAreas(); if (shouldShowTooltip()) { drawHoverOverlay(); drawVerticalMarker(); addMouseEvents(); } }); } /** * Adds events to the container group if the environment is not mobile * Adding: mouseover, mouseout and mousemove */ function addMouseEvents() { svg .on('mouseover', function(d) { handleMouseOver(this, d); }) .on('mouseout', function(d) { handleMouseOut(this, d); }) .on('mousemove', function(d) { handleMouseMove(this, d); }); } /** * Formats the value depending on its characteristics * @param {Number} value Value to format * @return {Number} Formatted value */ function getFormattedValue(value) { let format; if (isInteger(value)) { format = formatIntegerValue; } else { format = formatDecimalValue; } return format(value); } /** * Creates the d3 x and y axis, setting orientations * @private */ function buildAxis() { let dataSpan = yScale.domain()[1] - yScale.domain()[0]; let yTickNumber = dataSpan &lt; yTicks - 1 ? dataSpan : yTicks; let minor, major; if (xAxisFormat === 'custom' &amp;&amp; typeof xAxisCustomFormat === 'string') { minor = { tick: xTicks, format: d3TimeFormat.timeFormat(xAxisCustomFormat) }; major = null; } else { ({minor, major} = getXAxisSettings(dataByDate, width, xAxisFormat, locale)); xMonthAxis = d3Axis.axisBottom(xScale) .ticks(major.tick) .tickSize(0, 0) .tickFormat(major.format); } xAxis = d3Axis.axisBottom(xScale) .ticks(minor.tick) .tickSize(10, 0) .tickPadding(tickPadding) .tickFormat(minor.format); yAxis = d3Axis.axisRight(yScale) .ticks(yTickNumber) .tickSize([0]) .tickPadding(tickPadding) .tickFormat(getFormattedValue); drawGridLines(minor.tick, yTickNumber); } /** * Builds containers for the chart, the axis and a wrapper for all of them * NOTE: The order of drawing of this group elements is really important, * as everything else will be drawn on top of them * @private */ function buildContainerGroups() { let container = svg .append('g') .classed('container-group', true) .attr('transform', `translate(${margin.left},${margin.top})`); container .append('g').classed('x-axis-group', true) .append('g').classed('x axis', true); container.selectAll('.x-axis-group') .append('g').classed('month-axis', true); container .append('g').classed('y-axis-group axis', true); container .append('g').classed('grid-lines-group', true); container .append('g').classed('chart-group', true); container .append('g').classed('metadata-group', true); } /** * Builds the stacked layers layout * @return {D3Layout} Layout for drawing the chart * @private */ function buildLayers() { dataByDateFormatted = dataByDate .map(d =&gt; assign({}, d, d.values)) .map(d =&gt; { Object.keys(d).forEach(k =&gt; { const entry = d[k]; if (entry &amp;&amp; entry.name) { d[entry.name] = entry.value; } }); return assign({}, d, { date: new Date(d['key']) }); }); dataByDateZeroed = dataByDate .map(d =&gt; assign({}, d, d.values)) .map(d =&gt; { Object.keys(d).forEach(k =&gt; { const entry = d[k]; if (entry &amp;&amp; entry.name) { d[entry.name] = 0; } }); return assign({}, d, { date: new Date(d['key']) }); }); let initialTotalsObject = uniq(data.map(getName)) .reduce((memo, key) =&gt; ( assign({}, memo, {[key]: 0}) ), {}); let totals = data .reduce((memo, item) =&gt; ( assign({}, memo, {[item.name]: memo[item.name] += item.value}) ), initialTotalsObject); order = topicsOrder || formatOrder(totals); let stack3 = d3Shape.stack() .keys(order) .order(d3Shape.stackOrderNone) .offset(d3Shape.stackOffsetNone); layersInitial = stack3(dataByDateZeroed); layers = stack3(dataByDateFormatted); } /** * Takes an object with all topics as keys and their aggregate totals as values, * sorts them into a list by descending total value and * moves &quot;Other&quot; to the end * @param {Object} totals Keys of all the topics and their corresponding totals * @return {Array} List of topic names in aggregate order */ function formatOrder(totals) { let order = Object.keys(totals) .sort((a, b) =&gt; { if (totals[a] &gt; totals[b]) return -1; if (totals[a] === totals[b]) return 0; return 1; }); let otherIndex = order.indexOf('Other'); if (otherIndex &gt;= 0) { let other = order.splice(otherIndex, 1); order = order.concat(other); } return order; } /** * Creates the x, y and color scales of the chart * @private */ function buildScales() { const maxValueByDate = isUsingFakeData ? emptyDataConfig.maxY : getMaxValueByDate(); xScale = d3Scale.scaleTime() .domain(d3Array.extent(dataByDate, ({date}) =&gt; date)) .rangeRound([0, chartWidth]); yScale = d3Scale.scaleLinear() .domain([0, maxValueByDate]) .rangeRound([chartHeight, 0]) .nice(); categoryColorMap = order.reduce((memo, topic, index) =&gt; ( assign({}, memo, {[topic]: colorSchema[index]}) ), {}); } /** * @param {HTMLElement} container DOM element that will work as the container of the graph * @private */ function buildSVG(container) { if (!svg) { svg = d3Selection.select(container) .append('svg') .classed('britechart stacked-area', true); buildContainerGroups(); } svg .attr('width', width) .attr('height', height); } /** * Creates fake data for when data is an empty array * @return {array} Fake data built from emptyDataConfig settings */ function createFakeData() { const numDays = diffDays(emptyDataConfig.minDate, emptyDataConfig.maxDate) const emptyArray = Array.apply(null, Array(numDays)); isUsingFakeData = true; return [ ...emptyArray.map((el, i) =&gt; ({ [dateLabel]: addDays(emptyDataConfig.minDate, i), [valueLabel]: 0, [keyLabel]: '1', })), ...emptyArray.map((el, i) =&gt; ({ [dateLabel]: addDays(emptyDataConfig.minDate, i), [valueLabel]: 0, [keyLabel]: '2', })) ]; } /** * Cleaning data casting the values and dates to the proper type while keeping * the rest of properties on the data. It creates fake data is the data is empty. * @param {areaChartData} originalData Raw data from the container * @return {areaChartData} Parsed data with values and dates * @private */ function cleanData(originalData) { originalData = originalData.length === 0 ? createFakeData() : originalData; return originalData.reduce((acc, d) =&gt; { d.date = new Date(d[dateLabel]), d.value = +d[valueLabel] return [...acc, d]; }, []); } /** * Draws the x and y axis on the svg object within their * respective groups * @private */ function drawAxis() { svg.select('.x-axis-group .axis.x') .attr('transform', `translate( 0, ${chartHeight} )`) .call(xAxis); if (xAxisFormat !== 'custom') { svg.select('.x-axis-group .month-axis') .attr('transform', `translate(0, ${(chartHeight + monthAxisPadding)})`) .call(xMonthAxis); } svg.select('.y-axis-group.axis') .attr('transform', `translate( ${-xAxisPadding.left}, 0)`) .call(yAxis) .call(adjustYTickLabels); // Moving the YAxis tick labels to the right side // d3Selection.selectAll('.y-axis-group .tick text') // .attr('transform', `translate( ${-chartWidth - yTickTextXOffset}, ${yTickTextYOffset})` ); } /** * Adjusts the position of the y axis' ticks * @param {D3Selection} selection Y axis group * @return void */ function adjustYTickLabels(selection) { selection.selectAll('.tick text') .attr('transform', `translate(${yTickTextXOffset}, ${yTickTextYOffset})`); } /** * Creates SVG dot elements for each data entry and draws them * TODO: Plug */ function drawDataReferencePoints() { // Creates Dots on Data points var points = svg.select('.chart-group').selectAll('.dots') .data(layers) .enter() .append('g') .attr('class', 'dots') .attr('d', ({values}) =&gt; area(values)) .attr('clip-path', 'url(#clip)'); // Processes the points // TODO: Optimize this code points.selectAll('.dot') .data(({values}, index) =&gt; values.map((point) =&gt; ({index, point}))) .enter() .append('circle') .attr('class','dot') .attr('r', () =&gt; pointsSize) .attr('fill', () =&gt; pointsColor) .attr('stroke-width', '0') .attr('stroke', pointsBorderColor) .attr('transform', function(d) { let {point} = d; let key = xScale(point.date); dataPoints[key] = dataPoints[key] || []; dataPoints[key].push(d); let {date, y, y0} = point; return `translate( ${xScale(date)}, ${yScale(y + y0)} )`; }); } /** * Draws grid lines on the background of the chart * @return void */ function drawGridLines(xTicks, yTicks) { if (grid === 'horizontal' || grid === 'full') { horizontalGridLines = svg.select('.grid-lines-group') .selectAll('line.horizontal-grid-line') .data(yScale.ticks(yTicks)) .enter() .append('line') .attr('class', 'horizontal-grid-line') .attr('x1', (-xAxisPadding.left - 30)) .attr('x2', chartWidth) .attr('y1', (d) =&gt; yScale(d)) .attr('y2', (d) =&gt; yScale(d)); } if (grid === 'vertical' || grid === 'full') { verticalGridLines = svg.select('.grid-lines-group') .selectAll('line.vertical-grid-line') .data(xScale.ticks(xTicks)) .enter() .append('line') .attr('class', 'vertical-grid-line') .attr('y1', 0) .attr('y2', chartHeight) .attr('x1', (d) =&gt; xScale(d)) .attr('x2', (d) =&gt; xScale(d)); } //draw a horizontal line to extend x-axis till the edges baseLine = svg.select('.grid-lines-group') .selectAll('line.extended-x-line') .data([0]) .enter() .append('line') .attr('class', 'extended-x-line') .attr('x1', (-xAxisPadding.left - 30)) .attr('x2', chartWidth) .attr('y1', height - margin.bottom - margin.top) .attr('y2', height - margin.bottom - margin.top); } /** * Draws an overlay element over the graph * @private */ function drawHoverOverlay() { // Not ideal, we need to figure out how to call exit for nested elements if (overlay) { svg.selectAll('.overlay').remove(); } overlay = svg.select('.metadata-group') .append('rect') .attr('class', 'overlay') .attr('y1', 0) .attr('y2', chartHeight) .attr('height', chartHeight) .attr('width', chartWidth) .attr('fill', overlayColor) .style('display', 'none'); } /** * Draws an empty line when the data is all zero * @private */ function drawEmptyDataLine() { let emptyDataLine = d3Shape.line() .x( (d) =&gt; xScale(d.date) ) .y( () =&gt; yScale(0) - 1 ); let chartGroup = svg.select('.chart-group'); chartGroup .append('path') .attr('class', 'empty-data-line') .attr('d', emptyDataLine(dataByDateFormatted)) .style('stroke', 'url(#empty-data-line-gradient)'); chartGroup .append('linearGradient') .attr('id', 'empty-data-line-gradient') .attr('gradientUnits', 'userSpaceOnUse') .attr('x1', 0) .attr('x2', xScale(data[data.length - 1].date)) .attr('y1', 0) .attr('y2', 0) .selectAll('stop') .data([ {offset: '0%', color: lineGradient[0]}, {offset: '100%', color: lineGradient[1]} ]) .enter() .append('stop') .attr('offset', ({offset}) =&gt; offset) .attr('stop-color', ({color}) =&gt; color); } /** * Draws the different areas into the chart-group element * @private */ function drawStackedAreas() { // Not ideal, we need to figure out how to call exit for nested elements if (series) { svg.selectAll('.layer-container').remove(); svg.selectAll('.layer').remove(); svg.selectAll('.area-outline').remove(); } if (isUsingFakeData) { drawEmptyDataLine(); return; } area = d3Shape.area() .curve(d3Shape.curveMonotoneX) .x( ({data}) =&gt; xScale(data.date) ) .y0( (d) =&gt; yScale(d[0]) ) .y1( (d) =&gt; yScale(d[1]) ); areaOutline = d3Shape.line() .curve(area.curve()) .x( ({data}) =&gt; xScale(data.date) ) .y( (d) =&gt; yScale(d[1]) ); if (isAnimated) { series = svg.select('.chart-group').selectAll('.layer') .data(layersInitial, getName) .enter() .append('g') .classed('layer-container', true); series .append('path') .attr('class', 'layer') .attr('d', area) .style('opacity', areaOpacity) .style('fill', ({key}) =&gt; categoryColorMap[key]); series .append('path') .attr('class', 'area-outline') .attr('d', areaOutline) .style('stroke', ({key}) =&gt; categoryColorMap[key]); // Update svg.select('.chart-group').selectAll('.layer') .data(layers) .transition() .delay( (_, i) =&gt; areaAnimationDelays[i]) .duration(areaAnimationDuration) .ease(ease) .attr('d', area) .style('opacity', areaOpacity) .style('fill', ({key}) =&gt; categoryColorMap[key]); svg.select('.chart-group').selectAll('.area-outline') .data(layers) .transition() .delay( (_, i) =&gt; areaAnimationDelays[i]) .duration(areaAnimationDuration) .ease(ease) .attr('d', areaOutline); } else { series = svg.select('.chart-group').selectAll('.layer') .data(layers) .enter() .append('g') .classed('layer-container', true); series .append('path') .attr('class', 'layer') .attr('d', area) .style('opacity', areaOpacity) .style('fill', ({key}) =&gt; categoryColorMap[key]); series .append('path') .attr('class', 'area-outline') .attr('d', areaOutline) .style('stroke', ({key}) =&gt; categoryColorMap[key]); // Update svg.select('.chart-group').selectAll('.layer') .attr('d', area) .style('opacity', areaOpacity) .style('fill', ({key}) =&gt; categoryColorMap[key]); svg.select('.chart-group').selectAll('.area-outline') .attr('class', 'area-outline') .attr('d', areaOutline) .style('stroke', ({key}) =&gt; categoryColorMap[key]); } // Exit series.exit() .transition() .style('opacity', 0) .remove(); } /** * Creates the vertical marker * @return void */ function drawVerticalMarker() { // Not ideal, we need to figure out how to call exit for nested elements if (verticalMarkerContainer) { svg.selectAll('.vertical-marker-container').remove(); } verticalMarkerContainer = svg.select('.metadata-group') .append('g') .attr('class', 'vertical-marker-container') .attr('transform', 'translate(9999, 0)'); verticalMarkerLine = verticalMarkerContainer.selectAll('path') .data([{ x1: 0, y1: 0, x2: 0, y2: 0 }]) .enter() .append('line') .classed('vertical-marker', true) .attr('x1', 0) .attr('y1', chartHeight) .attr('x2', 0) .attr('y2', 0); } /** * Removes all the datapoints highlighter circles added to the marker container * @return void * @private */ function cleanDataPointHighlights() { verticalMarkerContainer.selectAll('.circle-container').remove(); } /** * Orders the data by date for consumption on the chart tooltip * @param {areaChartData} data Chart data * @return {Object[]} Chart data ordered by date * @private */ function getDataByDate(data) { return d3Collection.nest() .key(getDate) .entries( data.sort((a, b) =&gt; a.date - b.date) ) .map(d =&gt; { return assign({}, d, { date: new Date(d.key) }); }); // let b = d3Collection.nest() // .key(getDate).sortKeys(d3Array.ascending) // .entries(data); } /** * Computes the maximum sum of values for any date * * @return {Number} Max value */ function getMaxValueByDate() { let keys = uniq(data.map(o =&gt; o.name)); let maxValueByDate = d3Array.max(dataByDateFormatted, function(d){ let vals = keys.map((key) =&gt; d[key]); return d3Array.sum(vals); }); return maxValueByDate; } /** * Finds out the data entry that is closer to the given position on pixels * @param {Number} mouseX X position of the mouse * @return {obj} Data entry that is closer to that x axis position */ function getNearestDataPoint(mouseX) { let points = dataByDate.filter(({date}) =&gt; Math.abs(xScale(date) - mouseX) &lt;= epsilon); if (points.length) { return points[0]; } } /** * Epsilon is the value given to the number representing half of the distance in * pixels between two date data points * @return {Number} half distance between any two points */ function setEpsilon() { let dates = dataByDate.map(({date}) =&gt; date); epsilon = (xScale(dates[1]) - xScale(dates[0])) / 2; } /** * MouseMove handler, calculates the nearest dataPoint to the cursor * and updates metadata related to it * @private */ function handleMouseMove(e) { epsilon || setEpsilon(); let [xPosition, yPosition] = d3Selection.mouse(e), dataPoint = getNearestDataPoint(xPosition - margin.left), dataPointXPosition; if (dataPoint) { dataPointXPosition = xScale(new Date( dataPoint.key )); // Move verticalMarker to that datapoint moveVerticalMarker(dataPointXPosition); // Add data points highlighting highlightDataPoints(dataPoint); // Emit event with xPosition for tooltip or similar feature dispatcher.call('customMouseMove', e, dataPoint, categoryColorMap, dataPointXPosition, yPosition); } } /** * MouseOut handler, hides overlay and removes active class on verticalMarkerLine * It also resets the container of the vertical marker * @private */ function handleMouseOut(e, d) { overlay.style('display', 'none'); verticalMarkerLine.classed('bc-is-active', false); verticalMarkerContainer.attr('transform', 'translate(9999, 0)'); dispatcher.call('customMouseOut', e, d, d3Selection.mouse(e)); } /** * Mouseover handler, shows overlay and adds active class to verticalMarkerLine * @private */ function handleMouseOver(e, d) { overlay.style('display', 'block'); verticalMarkerLine.classed('bc-is-active', true); dispatcher.call('customMouseOver', e, d, d3Selection.mouse(e)); } /** * Mouseclick handler over one of the highlight points * It will only pass the information with the event * @private */ function handleHighlightClick(e, d) { dispatcher.call('customDataEntryClick', e, d, d3Selection.mouse(e)); } /** * Creates coloured circles marking where the exact data y value is for a given data point * @param {obj} dataPoint Data point to extract info from * @private */ function highlightDataPoints({values}) { let accumulator = 0; cleanDataPointHighlights(); // ensure order stays constant values = values .filter(v =&gt; !!v) .sort((a,b) =&gt; order.indexOf(a.name) &gt; order.indexOf(b.name)); values.forEach((d, index) =&gt; { let marker = verticalMarkerContainer .append('g') .classed('circle-container', true) .append('circle') .classed('data-point-highlighter', true) .attr('cx', highlightCircleSize) .attr('cy', 0) .attr('r', highlightCircleRadius) .style('stroke-width', highlightCircleStroke) .style('stroke', categoryColorMap[d.name]) .on('touchstart click', function() { handleHighlightClick(this, d); }); accumulator = accumulator + values[index][valueLabel]; marker.attr('transform', `translate( ${(- highlightCircleSize)}, ${(yScale(accumulator))} )` ); }); } /** * Helper method to update the x position of the vertical marker * @param {obj} dataPoint Data entry to extract info * @return void */ function moveVerticalMarker(verticalMarkerXPosition) { verticalMarkerContainer.attr('transform', `translate(${verticalMarkerXPosition},0)`); } /** * Determines if we should add the tooltip related logic depending on the * size of the chart and the tooltipThreshold variable value * @return {boolean} Should we build the tooltip? * @private */ function shouldShowTooltip() { return width &gt; tooltipThreshold &amp;&amp; !isUsingFakeData; } // API /** * Gets or Sets the opacity of the stacked areas in the chart (all of them will have the same opacity) * @param {Object} _x Opacity to get/set * @return { opacity | module} Current opacity or Area Chart module to chain calls * @public */ exports.areaOpacity = function(_x) { if (!arguments.length) { return areaOpacity; } areaOpacity = _x; return this; }; /** * Gets or Sets the aspect ratio of the chart * @param {Number} _x Desired aspect ratio for the graph * @return { (Number | Module) } Current aspect ratio or Area Chart module to chain calls * @public */ exports.aspectRatio = function(_x) { if (!arguments.length) { return aspectRatio; } aspectRatio = _x; return this; }; /** * Gets or Sets the colorSchema of the chart * @param {String[]} _x Desired colorSchema for the graph * @return { colorSchema | module} Current colorSchema or Chart module to chain calls * @public */ exports.colorSchema = function(_x) { if (!arguments.length) { return colorSchema; } colorSchema = _x; return this; }; /** * Gets or Sets the dateLabel of the chart * @param {Number} _x Desired dateLabel for the graph * @return { dateLabel | module} Current dateLabel or Chart module to chain calls * @public */ exports.dateLabel = function(_x) { if (!arguments.length) { return dateLabel; } dateLabel = _x; return this; }; /** * Gets or Sets the emptyDataConfig of the chart * @param {Object} _x emptyDataConfig object to get/set * @return { Object | module} Current config for when chart data is an empty array * @public */ exports.emptyDataConfig = function(_x) { if (!arguments.length) { return emptyDataConfig; } emptyDataConfig = _x; return this; }; /** * Gets or Sets the grid mode. * * @param {String} _x Desired mode for the grid ('vertical'|'horizontal'|'full') * @return { String | module} Current mode of the grid or Area Chart module to chain calls * @public */ exports.grid = function(_x) { if (!arguments.length) { return grid; } grid = _x; return this; }; /** * Gets or Sets the height of the chart * @param {Number} _x Desired width for the graph * @return { height | module} Current height or Area Chart module to chain calls * @public */ exports.height = function(_x) { if (!arguments.length) { return height; } if (aspectRatio) { width = Math.ceil(_x / aspectRatio); } height = _x; return this; }; /** * Gets or Sets the isAnimated property of the chart, making it to animate when render. * By default this is 'false' * * @param {Boolean} _x Desired animation flag * @return { isAnimated | module} Current isAnimated flag or Chart module * @public */ exports.isAnimated = function(_x) { if (!arguments.length) { return isAnimated; } isAnimated = _x; return this; }; /** * Gets or Sets the keyLabel of the chart * @param {Number} _x Desired keyLabel for the graph * @return { keyLabel | module} Current keyLabel or Chart module to chain calls * @public */ exports.keyLabel = function(_x) { if (!arguments.length) { return keyLabel; } keyLabel = _x; return this; }; /** * Gets or Sets the margin of the chart * @param {Object} _x Margin object to get/set * @return { margin | module} Current margin or Area Chart module to chain calls * @public */ exports.margin = function(_x) { if (!arguments.length) { return margin; } margin = _x; return this; }; /** * Gets or Sets the minimum width of the graph in order to show the tooltip * NOTE: This could also depend on the aspect ratio * * @param {Object} _x Margin object to get/set * @return { tooltipThreshold | module} Current tooltipThreshold or Area Chart module to chain calls * @public */ exports.tooltipThreshold = function(_x) { if (!arguments.length) { return tooltipThreshold; } tooltipThreshold = _x; return this; }; /** * Pass an override for the ordering of the topics * @param {String[]} _x Array of the names of your tooltip items * @return { String[] | module} Current override order or Chart module to chain calls * @public */ exports.topicsOrder = function(_x) { if (!arguments.length) { return topicsOrder; } topicsOrder = _x; return this; }; /** * Pass language tag for the tooltip to localize the date. * Feature uses Intl.DateTimeFormat, for compatability and support, refer to * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DateTimeFormat * @param {String} _x must be a language tag (BCP 47) like 'en-US' or 'fr-FR' * @return { (String|Module) } Current locale or module to chain calls * @public */ exports.locale = function(_x) { if (!arguments.length) { return locale; } locale = _x; return this; }; /** * Chart exported to png and a download action is fired * @param {String} filename File title for the resulting picture * @param {String} title Title to add at the top of the exported picture * @public */ exports.exportChart = function(filename, title) { exportChart.call(exports, svg, filename, title); }; /** * Exposes an 'on' method that acts as a bridge with the event dispatcher * We are going to expose this events: * customMouseOver, customMouseMove, customMouseOut and customDataEntryClick * * @return {module} Bar Chart * @public */ exports.on = function() { let value = dispatcher.on.apply(dispatcher, arguments); return value === dispatcher ? exports : value; }; /** * Exposes the constants to be used to force the x axis to respect a certain granularity * current options: MINUTE_HOUR, HOUR_DAY, DAY_MONTH, MONTH_YEAR * @example * area.xAxisFormat(area.axisTimeCombinations.HOUR_DAY) */ exports.axisTimeCombinations = axisTimeCombinations; /** * Gets or Sets the valueLabel of the chart * @param {Number} _x Desired valueLabel for the graph * @return { valueLabel | module} Current valueLabel or Chart module to chain calls * @public */ exports.valueLabel = function(_x) { if (!arguments.length) { return valueLabel; } valueLabel = _x; return this; }; /** * Gets or Sets the width of the chart * @param {Number} _x Desired width for the graph * @return {Number | module} Current width or Area Chart module to chain calls * @public */ exports.width = function(_x) { if (!arguments.length) { return width; } if (aspectRatio) { height = Math.ceil(_x * aspectRatio); } width = _x; return this; }; /** * Exposes the ability to force the chart to show a certain x format * It requires a `xAxisFormat` of 'custom' in order to work. * NOTE: localization not supported * @param {String} _x Desired format for x axis * @return {String | Module} Current format or module to chain calls * @public */ exports.xAxisCustomFormat = function(_x) { if (!arguments.length) { return xAxisCustomFormat; } xAxisCustomFormat = _x; return this; }; /** * Exposes the ability to force the chart to show a certain x axis grouping * @param {String} _x Desired format * @return {String | Module} Current format or module to chain calls * @public * @example * area.xAxisFormat(area.axisTimeCombinations.HOUR_DAY) */ exports.xAxisFormat = function(_x) { if (!arguments.length) { return xAxisFormat; } xAxisFormat = _x; return this; }; /** * Exposes the ability to force the chart to show a certain x ticks. It requires a `xAxisFormat` of 'custom' in order to work. * NOTE: This value needs to be a multiple of 2, 5 or 10. They won't always work as expected, as D3 decides at the end * how many and where the ticks will appear. * * @param {Number} _x Desired number of x axis ticks (multiple of 2, 5 or 10) * @return {Number | Module} Current number or ticks or module to chain calls * @public */ exports.xTicks = function(_x) { if (!arguments.length) { return xTicks; } xTicks = _x; return this; }; /** * Gets or Sets the number of ticks of the y axis on the chart * (Default is 5) * @param {Number} _x Desired vertical ticks * @return {Number | module} Current vertical ticks or Chart module to chain calls * @public */ exports.yTicks = function(_x) { if (!arguments.length) { return yTicks; } yTicks = _x; return this; }; return exports; }; }); × Search results Close "},"bar.js.html":{"id":"bar.js.html","title":"Source: bar.js","body":" Getting started Demos Bar Chart Brush Chart Donut Chart Grouped Bar Chart Kitchen Sink Line Chart Sparkline Chart Stacked Area Chart Stacked Bar Chart Step Chart API Bar Brush Donut Grouped-bar Legend Line Mini-tooltip Sparkline Stacked-area Stacked-bar Step Tooltip Types Github Twitter Source: bar.js define(function(require) { 'use strict'; const d3Array = require('d3-array'); const d3Ease = require('d3-ease'); const d3Axis = require('d3-axis'); const d3Color = require('d3-color'); const d3Dispatch = require('d3-dispatch'); const d3Format = require('d3-format'); const d3Scale = require('d3-scale'); const d3Selection = require('d3-selection'); const d3Transition = require('d3-transition'); const textHelper = require('./helpers/text'); const {exportChart} = require('./helpers/exportChart'); const colorHelper = require('./helpers/colors'); const PERCENTAGE_FORMAT = '%'; const NUMBER_FORMAT = ',f'; /** * @typedef BarChartData * @type {Object[]} * @property {Number} value Value of the group (required) * @property {String} name Name of the group (required) * * @example * [ * { * value: 1, * name: 'glittering' * }, * { * value: 1, * name: 'luminous' * } * ] */ /** * Bar Chart reusable API class that renders a * simple and configurable bar chart. * * @module Bar * @tutorial bar * @requires d3-array, d3-axis, d3-dispatch, d3-scale, d3-selection * * @example * var barChart = bar(); * * barChart * .height(500) * .width(800); * * d3Selection.select('.css-selector') * .datum(dataset) * .call(barChart); * */ return function module() { let margin = { top: 20, right: 20, bottom: 30, left: 40 }, width = 960, height = 500, data, dataZeroed, chartWidth, chartHeight, xScale, yScale, colorSchema = colorHelper.singleColors.aloeGreen, colorList, colorMap, yTicks = 5, xTicks = 5, percentageAxisToMaxRatio = 1, enablePercentageLabels = false, percentageLabelMargin = 7, percentageLabelSize = 12, horizontalLabelFormat = '.0%', verticalLabelFormat = '.0f', valueLabelFormat = NUMBER_FORMAT, xAxis, yAxis, xAxisPadding = { top: 0, left: 0, bottom: 0, right: 0 }, yAxisPaddingBetweenChart = 10, yAxisLineWrapLimit = 1, isHorizontal = false, svg, isAnimated = false, ease = d3Ease.easeQuadInOut, animationDuration = 800, animationStepRatio = 70, interBarDelay = (d, i) =&gt; animationStepRatio * i, valueLabel = 'value', nameLabel = 'name', baseLine, maskGridLines, shouldReverseColorList = true, // Dispatcher object to broadcast the mouse events // Ref: https://github.com/mbostock/d3/wiki/Internals#d3_dispatch dispatcher = d3Dispatch.dispatch('customMouseOver', 'customMouseOut', 'customMouseMove'), // extractors getName = ({name}) =&gt; name, getValue = ({value}) =&gt; value, _percentageLabelHorizontalX = ({value}) =&gt; xScale(value) + percentageLabelMargin, _percentageLabelHorizontalY= ({name}) =&gt; yScale(name) + (yScale.bandwidth() / 2) + (percentageLabelSize * (3/8)), _percentageLabelVerticalX = ({name}) =&gt; xScale(name), _percentageLabelVerticalY = ({value}) =&gt; yScale(value) - percentageLabelMargin, _percentageLabelHorizontalFormatValue = ({value}) =&gt; d3Format.format(horizontalLabelFormat)(value), _percentageLabelVerticalFormatValue = ({value}) =&gt; d3Format.format(verticalLabelFormat)(parseFloat(value) * 100); /** * This function creates the graph using the selection as container * @param {D3Selection} _selection A d3 selection that represents * the container(s) where the chart(s) will be rendered * @param {BarChartData} _data The data to attach and generate the chart */ function exports(_selection) { _selection.each(function(_data) { chartWidth = width - margin.left - margin.right - (yAxisPaddingBetweenChart * 1.2); chartHeight = height - margin.top - margin.bottom; ({data, dataZeroed} = cleanData(_data)); buildScales(); buildAxis(); buildSVG(this); drawGridLines(); drawBars(); drawAxis(); if (enablePercentageLabels) { drawPercentageLabels(); } }); } /** * Creates the d3 x and y axis, setting orientations * @private */ function buildAxis() { if (isHorizontal) { xAxis = d3Axis.axisBottom(xScale) .ticks(xTicks, valueLabelFormat) .tickSizeInner([-chartHeight]); yAxis = d3Axis.axisLeft(yScale); } else { xAxis = d3Axis.axisBottom(xScale); yAxis = d3Axis.axisLeft(yScale) .ticks(yTicks, valueLabelFormat) } } /** * Builds containers for the chart, the axis and a wrapper for all of them * Also applies the Margin convention * @private */ function buildContainerGroups() { let container = svg .append('g') .classed('container-group', true) .attr('transform', `translate(${margin.left + yAxisPaddingBetweenChart}, ${margin.top})`); container .append('g').classed('grid-lines-group', true); container .append('g').classed('chart-group', true); container .append('g').classed('x-axis-group axis', true); container .append('g') .attr('transform', `translate(${-1 * (yAxisPaddingBetweenChart)}, 0)`) .classed('y-axis-group axis', true); container .append('g').classed('metadata-group', true); } /** * Creates the x and y scales of the graph * @private */ function buildScales() { let percentageAxis = Math.min(percentageAxisToMaxRatio * d3Array.max(data, getValue)) if (isHorizontal) { xScale = d3Scale.scaleLinear() .domain([0, percentageAxis]) .rangeRound([0, chartWidth]); yScale = d3Scale.scaleBand() .domain(data.map(getName)) .rangeRound([chartHeight, 0]) .padding(0.1); } else { xScale = d3Scale.scaleBand() .domain(data.map(getName)) .rangeRound([0, chartWidth]) .padding(0.1); yScale = d3Scale.scaleLinear() .domain([0, percentageAxis]) .rangeRound([chartHeight, 0]); } if (shouldReverseColorList) { colorList = data.map(d =&gt; d) .reverse() .map(({name}, i) =&gt; ({ name, color: colorSchema[i % colorSchema.length]} )); } else { colorList = data.map(d =&gt; d) .map(({name}, i) =&gt; ({ name, color: colorSchema[i % colorSchema.length]} )); } colorMap = (item) =&gt; colorList.filter(({name}) =&gt; name === item)[0].color; } /** * Builds the SVG element that will contain the chart * @param {HTMLElement} container DOM element that will work as the container of the graph * @private */ function buildSVG(container) { if (!svg) { svg = d3Selection.select(container) .append('svg') .classed('britechart bar-chart', true); buildContainerGroups(); } svg .attr('width', width) .attr('height', height); } /** * Cleaning data casting the values and names to the proper type while keeping * the rest of properties on the data * It also creates a set of zeroed data (for animation purposes) * @param {BarChartData} originalData Raw data as passed to the container * @return {BarChartData} Clean data * @private */ function cleanData(originalData) { let data = originalData.reduce((acc, d) =&gt; { d.value = +d[valueLabel]; d.name = String(d[nameLabel]); return [...acc, d]; }, []); let dataZeroed = data.map((d) =&gt; ({ value: 0, name: String(d[nameLabel]) })); return { data, dataZeroed }; } /** * Utility function that wraps a text into the given width * @param {D3Selection} text Text to write * @param {Number} containerWidth * @private */ function wrapText(text, containerWidth) { textHelper.wrapTextWithEllipses(text, containerWidth, 0, yAxisLineWrapLimit) } /** * Draws the x and y axis on the svg object within their * respective groups * @private */ function drawAxis() { svg.select('.x-axis-group.axis') .attr('transform', `translate(0, ${chartHeight})`) .call(xAxis); svg.select('.y-axis-group.axis') .call(yAxis); svg.selectAll('.y-axis-group .tick text') .call(wrapText, margin.left - yAxisPaddingBetweenChart) } /** * Draws the bars along the x axis * @param {D3Selection} bars Selection of bars * @return {void} */ function drawHorizontalBars(bars) { // Enter + Update bars.enter() .append('rect') .classed('bar', true) .attr('y', chartHeight) .attr('x', 0) .attr('height', yScale.bandwidth()) .attr('width', ({value}) =&gt; xScale(value)) .on('mouseover', function(d) { handleMouseOver(this, d, chartWidth, chartHeight); }) .on('mousemove', function(d) { handleMouseMove(this, d, chartWidth, chartHeight); }) .on('mouseout', function(d) { handleMouseOut(this, d, chartWidth, chartHeight); }) .merge(bars) .attr('x', 0) .attr('y', ({name}) =&gt; yScale(name)) .attr('height', yScale.bandwidth()) .attr('width', ({value}) =&gt; xScale(value)) .attr('fill', ({name}) =&gt; colorMap(name)); } /** * Draws and animates the bars along the x axis * @param {D3Selection} bars Selection of bars * @return {void} */ function drawAnimatedHorizontalBars(bars) { // Enter + Update bars.enter() .append('rect') .classed('bar', true) .attr('x', 0) .attr('y', chartHeight) .attr('height', yScale.bandwidth()) .attr('width', ({value}) =&gt; xScale(value)) .on('mouseover', function(d) { handleMouseOver(this, d, chartWidth, chartHeight); }) .on('mousemove', function(d) { handleMouseMove(this, d, chartWidth, chartHeight); }) .on('mouseout', function(d) { handleMouseOut(this, d, chartWidth, chartHeight); }); bars .attr('x', 0) .attr('y', ({name}) =&gt; yScale(name)) .attr('height', yScale.bandwidth()) .attr('fill', ({name}) =&gt; colorMap(name)) .transition() .duration(animationDuration) .delay(interBarDelay) .ease(ease) .attr('width', ({value}) =&gt; xScale(value)); } /** * Draws and animates the bars along the y axis * @param {D3Selection} bars Selection of bars * @return {void} */ function drawAnimatedVerticalBars(bars) { // Enter + Update bars.enter() .append('rect') .classed('bar', true) .attr('x', chartWidth) .attr('y', ({value}) =&gt; yScale(value)) .attr('width', xScale.bandwidth()) .attr('height', ({value}) =&gt; chartHeight - yScale(value)) .on('mouseover', function(d) { handleMouseOver(this, d, chartWidth, chartHeight); }) .on('mousemove', function(d) { handleMouseMove(this, d, chartWidth, chartHeight); }) .on('mouseout', function(d) { handleMouseOut(this, d, chartWidth, chartHeight); }) .merge(bars) .attr('x', ({name}) =&gt; xScale(name)) .attr('width', xScale.bandwidth()) .attr('fill', ({name}) =&gt; colorMap(name)) .transition() .duration(animationDuration) .delay(interBarDelay) .ease(ease) .attr('y', ({value}) =&gt; yScale(value)) .attr('height', ({value}) =&gt; chartHeight - yScale(value)); } /** * Draws the bars along the y axis * @param {D3Selection} bars Selection of bars * @return {void} */ function drawVerticalBars(bars) { // Enter + Update bars.enter() .append('rect') .classed('bar', true) .attr('x', chartWidth) .attr('y', ({value}) =&gt; yScale(value)) .attr('width', xScale.bandwidth()) .attr('height', ({value}) =&gt; chartHeight - yScale(value)) .on('mouseover', function(d) { handleMouseOver(this, d, chartWidth, chartHeight); }) .on('mousemove', function(d) { handleMouseMove(this, d, chartWidth, chartHeight); }) .on('mouseout', function(d) { handleMouseOut(this, d, chartWidth, chartHeight); }) .merge(bars) .attr('x', ({name}) =&gt; xScale(name)) .attr('y', ({value}) =&gt; yScale(value)) .attr('width', xScale.bandwidth()) .attr('height', ({value}) =&gt; chartHeight - yScale(value)) .attr('fill', ({name}) =&gt; colorMap(name)); } /** * Draws percentage labels at the end of each bar * @private * @return {void} */ function drawPercentageLabels() { let labelXPosition = isHorizontal ? _percentageLabelHorizontalX : _percentageLabelVerticalX; let labelYPosition = isHorizontal ? _percentageLabelHorizontalY : _percentageLabelVerticalY; let text = isHorizontal ? _percentageLabelHorizontalFormatValue : _percentageLabelVerticalFormatValue; let percentageLabels = svg.select('.metadata-group') .append('g') .classed('percentage-label-group', true) .selectAll('text') .data(data.reverse()) .enter() .append('text'); percentageLabels .classed('percentage-label', true) .attr('x', labelXPosition) .attr('y', labelYPosition) .text(text) .attr('font-size', percentageLabelSize + 'px') } /** * Draws the bar elements within the chart group * @private */ function drawBars() { let bars; if (isAnimated) { bars = svg.select('.chart-group').selectAll('.bar') .data(dataZeroed); if (isHorizontal) { drawHorizontalBars(bars); } else { drawVerticalBars(bars); } bars = svg.select('.chart-group').selectAll('.bar') .data(data); if (isHorizontal) { drawAnimatedHorizontalBars(bars); } else { drawAnimatedVerticalBars(bars); } } else { bars = svg.select('.chart-group').selectAll('.bar') .data(data); if (isHorizontal) { drawHorizontalBars(bars); } else { drawVerticalBars(bars); } } // Exit bars.exit() .transition() .style('opacity', 0) .remove(); } /** * Draws grid lines on the background of the chart * @return void */ function drawGridLines() { if (isHorizontal) { drawHorizontalGridLines(); } else { drawVerticalGridLines(); } } /** * Draws the grid lines for an horizontal bar chart * @return {void} */ function drawHorizontalGridLines() { maskGridLines = svg.select('.grid-lines-group') .selectAll('line.vertical-grid-line') .data(xScale.ticks(4)) .enter() .append('line') .attr('class', 'vertical-grid-line') .attr('y1', (xAxisPadding.left)) .attr('y2', chartHeight) .attr('x1', (d) =&gt; xScale(d)) .attr('x2', (d) =&gt; xScale(d)) drawVerticalExtendedLine(); } /** * Draws a vertical line to extend y-axis till the edges * @return {void} */ function drawVerticalExtendedLine() { baseLine = svg.select('.grid-lines-group') .selectAll('line.extended-y-line') .data([0]) .enter() .append('line') .attr('class', 'extended-y-line') .attr('y1', (xAxisPadding.bottom)) .attr('y2', chartHeight) .attr('x1', 0) .attr('x2', 0); } /** * Draws the grid lines for a vertical bar chart * @return {void} */ function drawVerticalGridLines() { maskGridLines = svg.select('.grid-lines-group') .selectAll('line.horizontal-grid-line') .data(yScale.ticks(4)) .enter() .append('line') .attr('class', 'horizontal-grid-line') .attr('x1', (xAxisPadding.left)) .attr('x2', chartWidth) .attr('y1', (d) =&gt; yScale(d)) .attr('y2', (d) =&gt; yScale(d)) drawHorizontalExtendedLine(); } /** * Draws a vertical line to extend x-axis till the edges * @return {void} */ function drawHorizontalExtendedLine() { baseLine = svg.select('.grid-lines-group') .selectAll('line.extended-x-line') .data([0]) .enter() .append('line') .attr('class', 'extended-x-line') .attr('x1', (xAxisPadding.left)) .attr('x2', chartWidth) .attr('y1', chartHeight) .attr('y2', chartHeight); } /** * Custom OnMouseOver event handler * @return {void} * @private */ function handleMouseOver(e, d, chartWidth, chartHeight) { dispatcher.call('customMouseOver', e, d, d3Selection.mouse(e), [chartWidth, chartHeight]); d3Selection.select(e).attr('fill', ({name}) =&gt; d3Color.color(colorMap(name)).darker()); } /** * Custom OnMouseMove event handler * @return {void} * @private */ function handleMouseMove(e, d, chartWidth, chartHeight) { dispatcher.call('customMouseMove', e, d, d3Selection.mouse(e), [chartWidth, chartHeight]); } /** * Custom OnMouseOver event handler * @return {void} * @private */ function handleMouseOut(e, d, chartWidth, chartHeight) { dispatcher.call('customMouseOut', e, d, d3Selection.mouse(e), [chartWidth, chartHeight]); d3Selection.select(e).attr('fill', ({name}) =&gt; colorMap(name)); } // API /** * Gets or Sets the colorSchema of the chart * @param {String[]} _x Desired colorSchema for the graph * @return { colorSchema | module} Current colorSchema or Chart module to chain calls * @public */ exports.colorSchema = function(_x) { if (!arguments.length) { return colorSchema; } colorSchema = _x; return this; }; /** * Default false. If true, adds percentage labels at the end of the bars * @param {Boolean} _x * @return {Boolean | module} Current value of enablePercentageLables or Chart module to chain calls */ exports.enablePercentageLabels = function(_x) { if (!arguments.length) { return enablePercentageLabels; } enablePercentageLabels = _x; return this; }; /** * Chart exported to png and a download action is fired * @param {String} filename File title for the resulting picture * @param {String} title Title to add at the top of the exported picture * @public */ exports.exportChart = function(filename, title) { exportChart.call(exports, svg, filename, title); }; /** * Gets or Sets the height of the chart * @param {number} _x Desired width for the graph * @return { height | module} Current height or Chart module to chain calls * @public */ exports.height = function(_x) { if (!arguments.length) { return height; } height = _x; return this; }; /** * Gets or Sets the isAnimated property of the chart, making it to animate when render. * By default this is 'false' * * @param {Boolean} _x Desired animation flag * @return { isAnimated | module} Current isAnimated flag or Chart module * @public */ exports.isAnimated = function(_x) { if (!arguments.length) { return isAnimated; } isAnimated = _x; return this; }; /** * Gets or Sets the horizontal direction of the chart * @param {number} _x Desired horizontal direction for the graph * @return { isHorizontal | module} If it is horizontal or Chart module to chain calls * @public */ exports.isHorizontal = function(_x) { if (!arguments.length) { return isHorizontal; } isHorizontal = _x; return this; }; /** * Gets or Sets the margin of the chart * @param {object} _x Margin object to get/set * @return { margin | module} Current margin or Chart module to chain calls * @public */ exports.margin = function(_x) { if (!arguments.length) { return margin; } margin = _x; return this; }; /** * Gets or Sets the nameLabel of the chart * @param {Number} _x Desired nameLabel for the graph * @return { nameLabel | module} Current nameLabel or Chart module to chain calls * @public */ exports.nameLabel = function(_x) { if (!arguments.length) { return nameLabel; } nameLabel = _x; return this; }; /** * Exposes an 'on' method that acts as a bridge with the event dispatcher * We are going to expose this events: * customMouseOver, customMouseMove and customMouseOut * * @return {module} Bar Chart * @public */ exports.on = function() { let value = dispatcher.on.apply(dispatcher, arguments); return value === dispatcher ? exports : value; }; /** * Configurable extension of the x axis * if your max point was 50% you might want to show x axis to 60%, pass 1.2 * @param {number} _x ratio to max data point to add to the x axis * @return { ratio | module} Current ratio or Chart module to chain calls * @public */ exports.percentageAxisToMaxRatio = function(_x) { if (!arguments.length) { return percentageAxisToMaxRatio; } percentageAxisToMaxRatio = _x; return this; } /** * Default 10px. Offset between end of bar and start of the percentage bars * @param {number} _x percentage margin offset from end of bar * @return {number | module} Currnet offset or Chart module to chain calls */ exports.percentageLabelMargin = function(_x) { if (!arguments.length) { return percentageLabelMargin; } percentageLabelMargin = _x; return this; } /** * Gets or Sets whether the color list should be reversed or not * @param {boolean} _x Should reverse the color list * @return { boolean | module} Is color list being reversed * @public */ exports.shouldReverseColorList = function(_x) { if (!arguments.length) { return shouldReverseColorList; } shouldReverseColorList = _x; return this; }; /** * Gets or Sets the hasPercentage status * @param {boolean} _x Should use percentage as value format * @return { boolean | module} Is percentage used or Chart module to chain calls * @public */ exports.hasPercentage = function(_x) { if (!arguments.length) { return valueLabelFormat === PERCENTAGE_FORMAT; } if (_x) { valueLabelFormat = PERCENTAGE_FORMAT; } else { valueLabelFormat = NUMBER_FORMAT; } return this; }; /** * Gets or Sets the valueLabelFormat to a percentage format if true (default false) * @param {boolean} _x Should use percentage as value format * @return { boolean | module} Is percentage the value format used or Chart module to chain calls * @public */ exports.usePercentage = function(_x) { if (!arguments.length) { return valueLabelFormat === PERCENTAGE_FORMAT; } if (_x) { valueLabelFormat = PERCENTAGE_FORMAT; } else { valueLabelFormat = NUMBER_FORMAT; } return this; }; /** * Gets or Sets the valueLabel of the chart * @param {Number} _x Desired valueLabel for the graph * @return { valueLabel | module} Current valueLabel or Chart module to chain calls * @public */ exports.valueLabel = function(_x) { if (!arguments.length) { return valueLabel; } valueLabel = _x; return this; }; /** * Gets or Sets the width of the chart * @param {number} _x Desired width for the graph * @return { width | module} Current width or Chart module to chain calls * @public */ exports.width = function(_x) { if (!arguments.length) { return width; } width = _x; return this; }; /** * Gets or Sets the number of ticks of the x axis on the chart * (Default is 5) * @param {Number} _x Desired horizontal ticks * @return {Number | module} Current xTicks or Chart module to chain calls * @public */ exports.xTicks = function (_x) { if (!arguments.length) { return xTicks; } xTicks = _x; return this; }; /** * Space between y axis and chart * (Default 10) * @param {Number} _x Space between y axis and chart * @return {Number| module} Current value of yAxisPaddingBetweenChart or Chart module to chain calls */ exports.yAxisPaddingBetweenChart = function(_x) { if (!arguments.length) { return yAxisPaddingBetweenChart; } yAxisPaddingBetweenChart = _x; return this; }; /** * Gets or Sets the number of vertical ticks on the chart * (Default is 6) * @param {Number} _x Desired number of vertical ticks for the graph * @return {Number | module} Current yTicks or Chart module to chain calls * @public */ exports.yTicks = function(_x) { if (!arguments.length) { return yTicks; } yTicks = _x; return this; }; return exports; }; }); × Search results Close "},"brush.js.html":{"id":"brush.js.html","title":"Source: brush.js","body":" Getting started Demos Bar Chart Brush Chart Donut Chart Grouped Bar Chart Kitchen Sink Line Chart Sparkline Chart Stacked Area Chart Stacked Bar Chart Step Chart API Bar Brush Donut Grouped-bar Legend Line Mini-tooltip Sparkline Stacked-area Stacked-bar Step Tooltip Types Github Twitter Source: brush.js define(function(require) { 'use strict'; const d3Array = require('d3-array'); const d3Axis = require('d3-axis'); const d3Brush = require('d3-brush'); const d3Ease = require('d3-ease'); const d3Scale = require('d3-scale'); const d3Shape = require('d3-shape'); const d3Dispatch = require('d3-dispatch'); const d3Selection = require('d3-selection'); const d3Time = require('d3-time'); const d3Transition = require('d3-transition'); const d3TimeFormat = require('d3-time-format'); const colorHelper = require('./helpers/colors'); const timeAxisHelper = require('./helpers/timeAxis'); const {axisTimeCombinations} = require('./helpers/constants'); /** * @typedef BrushChartData * @type {Object[]} * @property {Number} value Value to chart (required) * @property {Date} date Date of the value (required) * * @example * [ * { * value: 1, * date: '2011-01-06T00:00:00Z' * }, * { * value: 2, * date: '2011-01-07T00:00:00Z' * } * ] */ /** * Brush Chart reusable API class that renders a * simple and configurable brush chart. * * @module Brush * @tutorial brush * @requires d3-array, d3-axis, d3-brush, d3-ease, d3-scale, d3-shape, d3-selection, d3-time, d3-time-format * * @example * let brushChart = brush(); * * brushChart * .height(500) * .width(800); * * d3Selection.select('.css-selector') * .datum(dataset) * .call(brushChart); * */ return function module() { let margin = { top: 20, right: 20, bottom: 30, left: 20 }, width = 960, height = 500, data, svg, ease = d3Ease.easeQuadOut, dateLabel = 'date', valueLabel = 'value', dateRange = [null, null], chartWidth, chartHeight, xScale, yScale, xAxis, xAxisFormat = null, xTicks = null, xAxisCustomFormat = null, locale, brush, chartBrush, handle, tickPadding = 5, gradient = colorHelper.colorGradients.greenBlue, // Dispatcher object to broadcast the mouse events // Ref: https://github.com/mbostock/d3/wiki/Internals#d3_dispatch dispatcher = d3Dispatch.dispatch('customBrushStart', 'customBrushEnd'), // extractors getValue = ({value}) =&gt; value, getDate = ({date}) =&gt; date; /** * This function creates the graph using the selection as container * @param {D3Selection} _selection A d3 selection that represents * the container(s) where the chart(s) will be rendered * @param {BrushChartData} _data The data to attach and generate the chart */ function exports(_selection){ _selection.each(function(_data){ chartWidth = width - margin.left - margin.right; chartHeight = height - margin.top - margin.bottom; data = cleanData(cloneData(_data)); buildScales(); buildAxis(); buildSVG(this); buildGradient(); buildBrush(); drawArea(); drawAxis(); drawBrush(); drawHandles(); }); } /** * Creates the d3 x axis, setting orientation * @private */ function buildAxis(){ let minor, major; if (xAxisFormat === 'custom' &amp;&amp; typeof xAxisCustomFormat === 'string') { minor = { tick: xTicks, format: d3TimeFormat.timeFormat(xAxisCustomFormat) }; } else { ({minor, major} = timeAxisHelper.getXAxisSettings(data, width, xAxisFormat)); } xAxis = d3Axis.axisBottom(xScale) .ticks(minor.tick) .tickSize(10, 0) .tickPadding([tickPadding]) .tickFormat(minor.format); } /** * Creates the brush element and attaches a listener * @return {void} */ function buildBrush() { brush = d3Brush.brushX() .extent([[0, 0], [chartWidth, chartHeight]]) .on('brush', handleBrushStart) .on('end', handleBrushEnd); } /** * Builds containers for the chart, the axis and a wrapper for all of them * Also applies the Margin convention * @private */ function buildContainerGroups(){ let container = svg .append('g') .classed('container-group', true) .attr('transform', `translate(${margin.left}, ${margin.top})`); container .append('g') .classed('chart-group', true); container .append('g') .classed('metadata-group', true); container .append('g') .classed('x-axis-group', true); container .append('g') .classed('brush-group', true); } /** * Creates the gradient on the area * @return {void} */ function buildGradient() { let metadataGroup = svg.select('.metadata-group'); metadataGroup.append('linearGradient') .attr('id', 'brush-area-gradient') .attr('gradientUnits', 'userSpaceOnUse') .attr('x1', 0) .attr('x2', xScale(data[data.length - 1].date)) .attr('y1', 0) .attr('y2', 0) .selectAll('stop') .data([ {offset: '0%', color: gradient[0]}, {offset: '100%', color: gradient[1]} ]) .enter().append('stop') .attr('offset', ({offset}) =&gt; offset) .attr('stop-color', ({color}) =&gt; color); } /** * Creates the x and y scales of the graph * @private */ function buildScales(){ xScale = d3Scale.scaleTime() .domain(d3Array.extent(data, getDate )) .range([0, chartWidth]); yScale = d3Scale.scaleLinear() .domain([0, d3Array.max(data, getValue)]) .range([chartHeight, 0]); } /** * Builds the SVG element that will contain the chart * @param {HTMLElement} container DOM element that will work as the container of the graph * @private */ function buildSVG(container){ if (!svg) { svg = d3Selection.select(container) .append('svg') .classed('britechart brush-chart', true); buildContainerGroups(); } svg .attr('width', width) .attr('height', height); } /** * Cleaning data casting the values and dates to the proper type while keeping * the rest of properties on the data * @param {BrushChartData} originalData Raw data from the container * @return {BrushChartData} Clean data * @private */ function cleanData(originalData) { return originalData.reduce((acc, d) =&gt; { d.date = new Date(d[dateLabel]); d.value = +d[valueLabel]; return [...acc, d]; }, []); } /** * Clones the passed array of data * @param {Object[]} dataToClone Data to clone * @return {Object[]} Cloned data */ function cloneData(dataToClone) { return JSON.parse(JSON.stringify(dataToClone)); } /** * Draws the x axis on the svg object within its group * * @private */ function drawAxis(){ svg.select('.x-axis-group') .append('g') .attr('class', 'x axis') .attr('transform', `translate(0, ${chartHeight})`) .call(xAxis); } /** * Draws the area that is going to represent the data * * @return {void} */ function drawArea() { // Create and configure the area generator let area = d3Shape.area() .x(({date}) =&gt; xScale(date)) .y0(chartHeight) .y1(({value}) =&gt; yScale(value)) .curve(d3Shape.curveBasis); // Create the area path svg.select('.chart-group') .append('path') .datum(data) .attr('class', 'brush-area') .attr('d', area); } /** * Draws the Brush components on its group * @return {void} */ function drawBrush() { chartBrush = svg.select('.brush-group') .call(brush); // Update the height of the brushing rectangle chartBrush.selectAll('rect') .classed('brush-rect', true) .attr('height', chartHeight); } /** * Draws a handle for the Brush section * @return {void} */ function drawHandles() { let handleFillColor = colorHelper.colorSchemasHuman.grey[1]; // Styling handle = chartBrush .selectAll('.handle.brush-rect') .style('fill', handleFillColor); } /** * When a brush event starts, we can extract info from the extension * of the brush. * * @return {void} */ function handleBrushStart() { let s = d3Selection.event.selection, dateExtent = s.map(xScale.invert); dispatcher.call('customBrushStart', this, dateExtent); // updateHandlers(dateExtent); } /** * Processes the end brush event, snapping the boundaries to days * as showed on the example on https://bl.ocks.org/mbostock/6232537 * @return {void} * @private */ function handleBrushEnd() { if (!d3Selection.event.sourceEvent) return; // Only transition after input. if (!d3Selection.event.selection) return; // Ignore empty selections. let s = d3Selection.event.selection, dateExtent = s.map(xScale.invert), dateExtentRounded = dateExtent.map(d3Time.timeDay.round); // If empty when rounded, use floor &amp; ceil instead. if (dateExtentRounded[0] &gt;= dateExtentRounded[1]) { dateExtentRounded[0] = d3Time.timeDay.floor(dateExtent[0]); dateExtentRounded[1] = d3Time.timeDay.offset(dateExtentRounded[0]); } d3Selection.select(this) .transition() .call(d3Selection.event.target.move, dateExtentRounded.map(xScale)); dispatcher.call('customBrushEnd', this, dateExtentRounded); } /** * Sets a new brush extent within the passed percentage positions * @param {Number} a Percentage of data that the brush start with * @param {Number} b Percentage of data that the brush ends with * @example * setBrushByPercentages(0.25, 0.5) */ function setBrushByPercentages(a, b) { let x0 = a * chartWidth, x1 = b * chartWidth; brush .move(chartBrush, [x0, x1]); } /** * Sets a new brush extent within the passed dates * @param {String | Date} dateA Initial Date * @param {String | Date} dateB End Date */ function setBrushByDates(dateA, dateB) { let x0 = xScale(new Date(dateA)), x1 = xScale(new Date(dateB)); brush .move(chartBrush, [x0, x1]); } /** * Updates visibility and position of the brush handlers * @param {Number[]} dateExtent Date range * @return {void} */ function updateHandlers(dateExtent) { if (dateExtent === null) { handle.attr('display', 'none'); } else { handle .attr('display', null) .attr('transform', function(d, i) { return `translate(${dateExtent[i]},${chartHeight / 2})`; }); } } // API /** * Exposes the constants to be used to force the x axis to respect a certain granularity * current options: MINUTE_HOUR, HOUR_DAY, DAY_MONTH, MONTH_YEAR * @example * brush.xAxisCustomFormat(brush.axisTimeCombinations.HOUR_DAY) */ exports.axisTimeCombinations = axisTimeCombinations; /** * Gets or Sets the dateRange for the selected part of the brush * @param {String[]} _x Desired dateRange for the graph * @return { dateRange | module} Current dateRange or Chart module to chain calls * @public */ exports.dateRange = function(_x) { if (!arguments.length) { return dateRange; } dateRange = _x; if (Array.isArray(dateRange)) { setBrushByDates(...dateRange); } return this; }; /** * Gets or Sets the gradient of the chart * @param {String[]} _x Desired gradient for the graph * @return {String | Module} Current gradient or Chart module to chain calls * @public */ exports.gradient = function(_x) { if (!arguments.length) { return gradient; } gradient = _x; return this; }; /** * Gets or Sets the height of the chart * @param {Number} _x Desired width for the graph * @return {Number | Module} Current height or Chart module to chain calls * @public */ exports.height = function(_x) { if (!arguments.length) { return height; } height = _x; return this; }; /** * Pass language tag for the tooltip to localize the date. * Feature uses Intl.DateTimeFormat, for compatability and support, refer to * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DateTimeFormat * @param {String} _x must be a language tag (BCP 47) like 'en-US' or 'fr-FR' * @return { (String|Module) } Current locale or module to chain calls */ exports.locale = function(_x) { if (!arguments.length) { return locale; } locale = _x; return this; }; /** * Gets or Sets the margin of the chart * @param {Object} _x Margin object to get/set * @return {Object | Module} Current margin or Chart module to chain calls * @public */ exports.margin = function(_x) { if (!arguments.length) { return margin; } margin = _x; return this; }; /** * Exposes an 'on' method that acts as a bridge with the event dispatcher * We are going to expose this events: * customMouseOver, customMouseMove and customMouseOut * * @return {module} Bar Chart * @public */ exports.on = function() { let value = dispatcher.on.apply(dispatcher, arguments); return value === dispatcher ? exports : value; }; /** * Gets or Sets the width of the chart * @param {Number} _x Desired width for the graph * @return {Number | Module} Current width or Chart module to chain calls * @public */ exports.width = function(_x) { if (!arguments.length) { return width; } width = _x; return this; }; /** * Exposes the ability to force the chart to show a certain x format * It requires a `xAxisFormat` of 'custom' in order to work. * @param {String} _x Desired format for x axis * @return {String | Module} Current format or module to chain calls */ exports.xAxisCustomFormat = function(_x) { if (!arguments.length) { return xAxisCustomFormat; } xAxisCustomFormat = _x; return this; }; /** * Exposes the ability to force the chart to show a certain x axis grouping * @param {String} _x Desired format * @return {String | Module} Current format or module to chain calls * @example * brush.xAxisFormat(brush.axisTimeCombinations.HOUR_DAY) */ exports.xAxisFormat = function(_x) { if (!arguments.length) { return xAxisFormat; } xAxisFormat = _x; return this; }; /** * Exposes the ability to force the chart to show a certain x ticks. It requires a `xAxisCustomFormat` of 'custom' in order to work. * NOTE: This value needs to be a multiple of 2, 5 or 10. They won't always work as expected, as D3 decides at the end * how many and where the ticks will appear. * * @param {Number} _x Desired number of x axis ticks (multiple of 2, 5 or 10) * @return {Number | Module} Current number or ticks or module to chain calls */ exports.xTicks = function(_x) { if (!arguments.length) { return xTicks; } xTicks = _x; return this; }; return exports; }; }); × Search results Close "},"line.js.html":{"id":"line.js.html","title":"Source: line.js","body":" Getting started Demos Bar Chart Brush Chart Donut Chart Grouped Bar Chart Kitchen Sink Line Chart Sparkline Chart Stacked Area Chart Stacked Bar Chart Step Chart API Bar Brush Donut Grouped-bar Legend Line Mini-tooltip Sparkline Stacked-area Stacked-bar Step Tooltip Types Github Twitter Source: line.js define(function(require){ 'use strict'; const d3Array = require('d3-array'); const d3Axis = require('d3-axis'); const d3Collection = require('d3-collection'); const d3Dispatch = require('d3-dispatch'); const d3Ease = require('d3-ease'); const d3Scale = require('d3-scale'); const d3Shape = require('d3-shape'); const d3Selection = require('d3-selection'); const d3Transition = require('d3-transition'); const d3TimeFormat = require('d3-time-format'); const {exportChart} = require('./helpers/exportChart'); const colorHelper = require('./helpers/colors'); const {isInteger} = require('./helpers/common'); const { getXAxisSettings, getLocaleDateFormatter } = require('./helpers/timeAxis'); const { axisTimeCombinations, lineGradientId } = require('./helpers/constants'); const { formatIntegerValue, formatDecimalValue, } = require('./helpers/formatHelpers'); /** * @typedef D3Selection * @type {Array[]} * @property {Number} length Size of the selection * @property {DOMElement} parentNode Parent of the selection */ /** * @typedef lineChartDataByTopic * @type {Object} * @property {String} topicName Topic name (required) * @property {Number} topic Topic identifier (required) * @property {Object[]} dates All date entries with values for that topic (required) * * @example * { * topicName: 'San Francisco', * topic: 123, * dates: [ * { * date: '2017-01-16T16:00:00-08:00', * value: 1 * }, * { * date: '2017-01-16T17:00:00-08:00', * value: 2 * } * ] * } */ /** * @typedef LineChartData * @type {Object[]} * @property {lineChartDataByTopic[]} dataByTopic Data values to chart (required) * * @example * { * dataByTopic: [ * { * topicName: 'San Francisco', * topic: 123, * dates: [ * { * date: '2017-01-16T16:00:00-08:00', * value: 1 * }, * { * date: '2017-01-16T17:00:00-08:00', * value: 2 * } * ] * }, * { * topicName: 'Other', * topic: 345, * dates: [ * {...}, * {...} * ] * } * ] * } */ /** * Line Chart reusable API module that allows us * rendering a multi line and configurable chart. * * @module Line * @tutorial line * @requires d3-array, d3-axis, d3-brush, d3-ease, d3-format, d3-scale, d3-shape, d3-selection, d3-time, d3-time-format * * @example * let lineChart = line(); * * lineChart * .aspectRatio(0.5) * .width(500); * * d3Selection.select('.css-selector') * .datum(dataset) * .call(lineChart); * */ return function line() { let margin = { top: 60, right: 30, bottom: 40, left: 70 }, width = 960, height = 500, aspectRatio = null, tooltipThreshold = 480, svg, paths, chartWidth, chartHeight, xScale, yScale, colorScale, xAxis, xMonthAxis, yAxis, xAxisPadding = { top: 0, left: 15, bottom: 0, right: 0 }, monthAxisPadding = 28, tickPadding = 5, highlightCircleSize = 12, highlightCircleStroke = 2, colorSchema = colorHelper.colorSchemas.britecharts, singleLineGradientColors = colorHelper.colorGradients.greenBlue, topicColorMap, linearGradient, xAxisFormat = null, xTicks = null, xAxisCustomFormat = null, locale, isAnimated = false, ease = d3Ease.easeQuadInOut, animationDuration = 1500, maskingRectangle, lineCurve = 'linear', curveMap = { linear: d3Shape.curveLinear, basis: d3Shape.curveBasis, cardinal: d3Shape.curveCardinal, catmullRom: d3Shape.curveCatmullRom, monotoneX: d3Shape.curveMonotoneX, monotoneY: d3Shape.curveMonotoneY, natural: d3Shape.curveNatural, step: d3Shape.curveStep, stepAfter: d3Shape.curveStepAfter, stepBefore: d3Shape.curveStepBefore }, dataByTopic, dataByDate, dateLabel = 'date', valueLabel = 'value', topicLabel = 'topic', topicNameLabel = 'topicName', yTicks = 5, overlay, overlayColor = 'rgba(0, 0, 0, 0)', verticalMarkerContainer, verticalMarkerLine, verticalGridLines, horizontalGridLines, grid = null, baseLine, pathYCache = {}, // extractors getDate = ({date}) =&gt; date, getValue = ({value}) =&gt; value, getTopic = ({topic}) =&gt; topic, getLineColor = ({topic}) =&gt; colorScale(topic), // events dispatcher = d3Dispatch.dispatch('customMouseOver', 'customMouseOut', 'customMouseMove', 'customDataEntryClick'); /** * This function creates the graph using the selection and data provided * * @param {D3Selection} _selection A d3 selection that represents * the container(s) where the chart(s) will be rendered * @param {LineChartData} _data The data to attach and generate the chart */ function exports(_selection) { _selection.each(function(_data) { ({ dataByTopic, dataByDate } = cleanData(_data)); chartWidth = width - margin.left - margin.right; chartHeight = height - margin.top - margin.bottom; buildScales(); buildSVG(this); buildAxis(); drawAxis(); buildGradient(); drawLines(); createMaskingClip(); if (shouldShowTooltip()) { drawHoverOverlay(); drawVerticalMarker(); addMouseEvents(); } }); } /** * Adds events to the container group if the environment is not mobile * Adding: mouseover, mouseout and mousemove */ function addMouseEvents() { svg .on('mouseover', function(d) { handleMouseOver(this, d); }) .on('mouseout', function(d) { handleMouseOut(this, d); }) .on('mousemove', function(d) { handleMouseMove(this, d); }); } /** * Adjusts the position of the y axis' ticks * @param {D3Selection} selection Y axis group * @return void */ function adjustYTickLabels(selection) { selection.selectAll('.tick text') .attr('transform', 'translate(0, -7)'); } /** * Formats the value depending on its characteristics * @param {Number} value Value to format * @return {Number} Formatted value */ function getFormattedValue(value) { let format; if (isInteger(value)) { format = formatIntegerValue; } else { format = formatDecimalValue; } return format(value); } /** * Creates the d3 x and y axis, setting orientations * @private */ function buildAxis() { let dataTimeSpan = yScale.domain()[1] - yScale.domain()[0]; let yTickNumber = dataTimeSpan &lt; yTicks - 1 ? dataTimeSpan : yTicks; let minor, major; if (xAxisFormat === 'custom' &amp;&amp; typeof xAxisCustomFormat === 'string') { minor = { tick: xTicks, format: d3TimeFormat.timeFormat(xAxisCustomFormat) }; major = null; } else { ({minor, major} = getXAxisSettings(dataByDate, width, xAxisFormat, locale)); xMonthAxis = d3Axis.axisBottom(xScale) .ticks(major.tick) .tickSize(0, 0) .tickFormat(major.format); } xAxis = d3Axis.axisBottom(xScale) .ticks(minor.tick) .tickSize(10, 0) .tickPadding(tickPadding) .tickFormat(minor.format); yAxis = d3Axis.axisLeft(yScale) .ticks(yTickNumber) .tickSize([0]) .tickPadding(tickPadding) .tickFormat(getFormattedValue); drawGridLines(minor.tick, yTickNumber); } /** * Builds containers for the chart, the axis and a wrapper for all of them * NOTE: The order of drawing of this group elements is really important, * as everything else will be drawn on top of them * @private */ function buildContainerGroups(){ let container = svg .append('g') .classed('container-group', true) .attr('transform', `translate(${margin.left},${margin.top})`); container .append('g').classed('x-axis-group', true) .append('g').classed('axis x', true); container.selectAll('.x-axis-group') .append('g').classed('month-axis', true); container .append('g').classed('y-axis-group axis y', true); container .append('g').classed('grid-lines-group', true); container .append('g').classed('chart-group', true); container .append('g').classed('metadata-group', true); } /** * Builds the gradient element to be used later * @return {void} */ function buildGradient() { if(!linearGradient) { linearGradient = svg.select('.metadata-group') .append('linearGradient') .attr('id', lineGradientId) .attr('x1', '0%') .attr('y1', '0%') .attr('x2', '100%') .attr('y2', '0%') .selectAll('stop') .data([ {offset:'0%', color: singleLineGradientColors[0]}, {offset:'100%', color: singleLineGradientColors[1]} ]) .enter() .append('stop') .attr('offset', ({offset}) =&gt; offset) .attr('stop-color', ({color}) =&gt; color) } } /** * Creates the x and y scales of the graph * @private */ function buildScales(){ let minX = d3Array.min(dataByTopic, ({dates}) =&gt; d3Array.min(dates, getDate)), maxX = d3Array.max(dataByTopic, ({dates}) =&gt; d3Array.max(dates, getDate)), maxY = d3Array.max(dataByTopic, ({dates}) =&gt; d3Array.max(dates, getValue)), minY = d3Array.min(dataByTopic, ({dates}) =&gt; d3Array.min(dates, getValue)); let yScaleBottomValue = Math.abs(minY) &lt; 0 ? Math.abs(minY) : 0; xScale = d3Scale.scaleTime() .domain([minX, maxX]) .rangeRound([0, chartWidth]); yScale = d3Scale.scaleLinear() .domain([yScaleBottomValue, Math.abs(maxY)]) .rangeRound([chartHeight, 0]) .nice(); colorScale = d3Scale.scaleOrdinal() .range(colorSchema) .domain(dataByTopic.map(getTopic)); let range = colorScale.range(); topicColorMap = colorScale.domain().reduce((memo, item, i) =&gt; { memo[item] = range[i]; return memo; }, {}); } /** * Builds the SVG element that will contain the chart * * @param {HTMLElement} container DOM element that will work as the container of the graph * @private */ function buildSVG(container){ if (!svg) { svg = d3Selection.select(container) .append('svg') .classed('britechart line-chart', true); buildContainerGroups(); } svg .attr('width', width) .attr('height', height); } /** * Parses dates and values into JS Date objects and numbers * @param {obj} dataByTopic Raw data grouped by topic * @return {obj} Parsed data with dataByTopic and dataByDate */ function cleanData({dataByTopic, dataByDate}) { if (!dataByTopic) { throw new Error('Data needs to have a dataByTopic property'); } let flatData = []; dataByTopic.forEach((topic) =&gt; { topic.dates.forEach((date) =&gt; { flatData.push({ topicName: topic[topicNameLabel], name: topic[topicLabel], date: date[dateLabel], value: date[valueLabel] }); }); }); // Nest data by date and format dataByDate = d3Collection.nest() .key( getDate ) .entries(flatData) .map((d) =&gt; { return { date: new Date(d.key), topics: d.values } }); // Normalize dates in keys dataByDate = dataByDate.map((d) =&gt; { d.date = new Date(d.date); return d; }); // Normalize dataByTopic dataByTopic.forEach(function(kv) { kv.dates.forEach(function(d) { d.date = new Date(d[dateLabel]); d.value = +d[valueLabel]; }); }); return {dataByTopic, dataByDate}; } /** * Removes all the datapoints highlighter circles added to the marker container * @return void */ function cleanDataPointHighlights(){ verticalMarkerContainer.selectAll('.circle-container').remove(); } /** * Creates a masking clip that would help us fake an animation if the * proper flag is true * * @return {void} */ function createMaskingClip() { if (isAnimated) { // We use a white rectangle to simulate the line drawing animation maskingRectangle = svg.append('rect') .attr('class', 'masking-rectangle') .attr('width', width) .attr('height', height) .attr('x', 0) .attr('y', 0); maskingRectangle.transition() .duration(animationDuration) .ease(ease) .attr('x', width) .on('end', () =&gt; maskingRectangle.remove()); } } /** * Draws the x and y axis on the svg object within their * respective groups * @private */ function drawAxis(){ svg.select('.x-axis-group .axis.x') .attr('transform', `translate(0, ${chartHeight})`) .call(xAxis); if (xAxisFormat !== 'custom') { svg.select('.x-axis-group .month-axis') .attr('transform', `translate(0, ${(chartHeight + monthAxisPadding)})`) .call(xMonthAxis); } svg.select('.y-axis-group.axis.y') .transition() .ease(ease) .attr('transform', `translate(${-xAxisPadding.left}, 0)`) .call(yAxis) .call(adjustYTickLabels); } /** * Draws the line elements within the chart group * @private */ function drawLines(){ let lines, topicLine; topicLine = d3Shape.line() .curve(curveMap[lineCurve]) .x(({date}) =&gt; xScale(date)) .y(({value}) =&gt; yScale(value)); lines = svg.select('.chart-group').selectAll('.line') .data(dataByTopic, getTopic); paths = lines.enter() .append('g') .attr('class', 'topic') .append('path') .attr('class', 'line') .attr('id', ({topic}) =&gt; topic) .attr('d', ({dates}) =&gt; topicLine(dates)) .style('stroke', (d) =&gt; ( dataByTopic.length === 1 ? `url(#${lineGradientId})` : getLineColor(d) )); lines .exit() .remove(); } /** * Draws grid lines on the background of the chart * @return void */ function drawGridLines(xTicks, yTicks){ if (grid === 'horizontal' || grid === 'full') { horizontalGridLines = svg.select('.grid-lines-group') .selectAll('line.horizontal-grid-line') .data(yScale.ticks(yTicks)) .enter() .append('line') .attr('class', 'horizontal-grid-line') .attr('x1', (-xAxisPadding.left - 30)) .attr('x2', chartWidth) .attr('y1', (d) =&gt; yScale(d)) .attr('y2', (d) =&gt; yScale(d)); } if (grid === 'vertical' || grid === 'full') { verticalGridLines = svg.select('.grid-lines-group') .selectAll('line.vertical-grid-line') .data(xScale.ticks(xTicks)) .enter() .append('line') .attr('class', 'vertical-grid-line') .attr('y1', 0) .attr('y2', chartHeight) .attr('x1', (d) =&gt; xScale(d)) .attr('x2', (d) =&gt; xScale(d)); } if (baseLine) { svg.selectAll('.extended-x-line').remove(); } //draw a horizontal line to extend x-axis till the edges baseLine = svg.select('.grid-lines-group') .selectAll('line.extended-x-line') .data([0]) .enter() .append('line') .attr('class', 'extended-x-line') .attr('x1', (-xAxisPadding.left - 30)) .attr('x2', chartWidth) .attr('y1', height - margin.bottom - margin.top) .attr('y2', height - margin.bottom - margin.top); } /** * Draws an overlay element over the graph * @inner * @return void */ function drawHoverOverlay(){ if(!overlay) { overlay = svg.select('.metadata-group') .append('rect') .attr('class','overlay') .attr('y1', 0) .attr('y2', height) .attr('height', chartHeight) .attr('width', chartWidth) .attr('fill', overlayColor) .style('display', 'none'); } } /** * Creates the vertical marker * @return void */ function drawVerticalMarker(){ if (!verticalMarkerContainer) { verticalMarkerContainer = svg.select('.metadata-group') .append('g') .attr('class', 'hover-marker vertical-marker-container') .attr('transform', 'translate(9999, 0)'); verticalMarkerLine = verticalMarkerContainer.selectAll('path') .data([{ x1: 0, y1: 0, x2: 0, y2: 0 }]) .enter() .append('line') .classed('vertical-marker', true) .attr('x1', 0) .attr('y1', chartHeight) .attr('x2', 0) .attr('y2', 0); } } /** * Finds out which datapoint is closer to the given x position * @param {Number} x0 Date value for data point * @param {Object} d0 Previous datapoint * @param {Object} d1 Next datapoint * @return {Object} d0 or d1, the datapoint with closest date to x0 */ function findOutNearestDate(x0, d0, d1){ return (new Date(x0).getTime() - new Date(d0.date).getTime()) &gt; (new Date(d1.date).getTime() - new Date(x0).getTime()) ? d0 : d1; } /** * Finds out the data entry that is closer to the given position on pixels * @param {Number} mouseX X position of the mouse * @return {Object} Data entry that is closer to that x axis position */ function getNearestDataPoint(mouseX) { let dateFromInvertedX = xScale.invert(mouseX); let bisectDate = d3Array.bisector(getDate).left; let dataEntryIndex = bisectDate(dataByDate, dateFromInvertedX, 1); let dataEntryForXPosition = dataByDate[dataEntryIndex]; let previousDataEntryForXPosition = dataByDate[dataEntryIndex - 1]; let nearestDataPoint; if (previousDataEntryForXPosition &amp;&amp; dataEntryForXPosition) { nearestDataPoint = findOutNearestDate(dateFromInvertedX, dataEntryForXPosition, previousDataEntryForXPosition); } else { nearestDataPoint = dataEntryForXPosition; } return nearestDataPoint; } /** * MouseMove handler, calculates the nearest dataPoint to the cursor * and updates metadata related to it * @private */ function handleMouseMove(e){ let [xPosition, yPosition] = d3Selection.mouse(e), xPositionOffset = -margin.left, //Arbitrary number, will love to know how to assess it dataPoint = getNearestDataPoint(xPosition + xPositionOffset), dataPointXPosition; if (dataPoint) { dataPointXPosition = xScale(new Date(dataPoint.date)); // More verticalMarker to that datapoint moveVerticalMarker(dataPointXPosition); // Add data points highlighting highlightDataPoints(dataPoint); // Emit event with xPosition for tooltip or similar feature dispatcher.call('customMouseMove', e, dataPoint, topicColorMap, dataPointXPosition, yPosition); } } /** * MouseOut handler, hides overlay and removes active class on verticalMarkerLine * It also resets the container of the vertical marker * @private */ function handleMouseOut(e, d){ overlay.style('display', 'none'); verticalMarkerLine.classed('bc-is-active', false); verticalMarkerContainer.attr('transform', 'translate(9999, 0)'); dispatcher.call('customMouseOut', e, d, d3Selection.mouse(e)); } /** * Mouseover handler, shows overlay and adds active class to verticalMarkerLine * @private */ function handleMouseOver(e, d){ overlay.style('display', 'block'); verticalMarkerLine.classed('bc-is-active', true); dispatcher.call('customMouseOver', e, d, d3Selection.mouse(e)); } /** * Mouseclick handler over one of the highlight points * It will only pass the information with the event * @private */ function handleHighlightClick(e, d) { dispatcher.call('customDataEntryClick', e, d, d3Selection.mouse(e)); } /** * Creates coloured circles marking where the exact data y value is for a given data point * @param {Object} dataPoint Data point to extract info from * @private */ function highlightDataPoints(dataPoint) { cleanDataPointHighlights(); const nodes = paths.nodes() const nodesById = nodes.reduce((acc, node) =&gt; { acc[node.id] = node return acc; }, {}); // Group corresponding path node with its topic, and // sorting the topics based on the order of the colors, // so that the order always stays constant const topicsWithNode = dataPoint.topics .map(topic =&gt; ({ topic, node: nodesById[topic.name] })) .filter(({topic}) =&gt; !!topic) .sort((a, b) =&gt; topicColorMap[a.topic.name] &lt; topicColorMap[b.topic.name]) dataPoint.topics = topicsWithNode.map(({topic}) =&gt; topic); dataPoint.topics.forEach((d, index) =&gt; { let marker = verticalMarkerContainer .append('g') .classed('circle-container', true) .append('circle') .classed('data-point-highlighter', true) .attr('cx', highlightCircleSize) .attr('cy', 0) .attr('r', 5) .style('stroke-width', highlightCircleStroke) .style('stroke', topicColorMap[d.name]) .on('touchstart click', function() { handleHighlightClick(this, d); }); const path = topicsWithNode[index].node; const x = xScale(new Date(dataPoint.topics[index].date)); const y = getPathYFromX(x, path, d.name); marker.attr('transform', `translate( ${(-highlightCircleSize)}, ${y} )` ); }); } /** * Finds the y coordinate of a path given an x coordinate and the line's path node. * @param {number} x The x coordinate * @param {node} path The path node element * @param {*} name - The name identifier of the topic * @param {number} error The margin of error from the actual x coordinate. Default 0.01 * @private */ function getPathYFromX(x, path, name, error) { const key = `${name}-${x}`; if (key in pathYCache) { return pathYCache[key]; } error = error || 0.01; const maxIterations = 100; let lengthStart = 0; let lengthEnd = path.getTotalLength(); let point = path.getPointAtLength((lengthEnd + lengthStart) / 2); let iterations = 0; while (x &lt; point.x - error || x &gt; point.x + error) { const midpoint = (lengthStart + lengthEnd) / 2; point = path.getPointAtLength(midpoint); if (x &lt; point.x) { lengthEnd = midpoint; } else { lengthStart = midpoint; } iterations += 1; if (maxIterations &lt; iterations) { break; } } pathYCache[key] = point.y return pathYCache[key] } /** * Helper method to update the x position of the vertical marker * @param {Object} dataPoint Data entry to extract info * @return void */ function moveVerticalMarker(verticalMarkerXPosition){ verticalMarkerContainer.attr('transform', `translate(${verticalMarkerXPosition},0)`); } /** * Determines if we should add the tooltip related logic depending on the * size of the chart and the tooltipThreshold variable value * @return {Boolean} Should we build the tooltip? */ function shouldShowTooltip() { return width &gt; tooltipThreshold; } // API /** * Gets or Sets the aspect ratio of the chart * @param {Number} _x Desired aspect ratio for the graph * @return { (Number | Module) } Current aspect ratio or Line Chart module to chain calls * @public */ exports.aspectRatio = function(_x) { if (!arguments.length) { return aspectRatio; } aspectRatio = _x; return this; }; /** * Gets or Sets the colorSchema of the chart * @param {String[]} _x Desired colorSchema for the graph * @return { colorSchema | module} Current colorSchema or Chart module to chain calls * @public */ exports.colorSchema = function(_x) { if (!arguments.length) { return colorSchema; } colorSchema = _x; return this; }; /** * Gets or Sets the dateLabel of the chart * @param {Number} _x Desired dateLabel for the graph * @return { dateLabel | module} Current dateLabel or Chart module to chain calls * @public */ exports.dateLabel = function(_x) { if (!arguments.length) { return dateLabel; } dateLabel = _x; return this; }; /** * Exposes the ability to force the chart to show a certain x axis grouping * @param {String} _x Desired format * @return { (String|Module) } Current format or module to chain calls * @public * @example * line.xAxisFormat(line.axisTimeCombinations.HOUR_DAY) */ exports.xAxisFormat = function(_x) { if (!arguments.length) { return xAxisFormat; } xAxisFormat = _x; return this; }; /** * Exposes the ability to force the chart to show a certain x format * It requires a `xAxisFormat` of 'custom' in order to work. * NOTE: localization not supported * @param {String} _x Desired format for x axis * @return { (String|Module) } Current format or module to chain calls * @public */ exports.xAxisCustomFormat = function(_x) { if (!arguments.length) { return xAxisCustomFormat; } xAxisCustomFormat = _x; return this; }; /** * Exposes the ability to force the chart to show a certain x ticks. It requires a `xAxisFormat` of 'custom' in order to work. * NOTE: This value needs to be a multiple of 2, 5 or 10. They won't always work as expected, as D3 decides at the end * how many and where the ticks will appear. * * @param {Number} _x Desired number of x axis ticks (multiple of 2, 5 or 10) * @return { (Number|Module) } Current number or ticks or module to chain calls * @public */ exports.xTicks = function(_x) { if (!arguments.length) { return xTicks; } xTicks = _x; return this; }; /** * Gets or Sets the grid mode. * * @param {String} _x Desired mode for the grid ('vertical'|'horizontal'|'full') * @return { String | module} Current mode of the grid or Line Chart module to chain calls * @public */ exports.grid = function(_x) { if (!arguments.length) { return grid; } grid = _x; return this; }; /** * Gets or Sets the height of the chart * @param {Number} _x Desired width for the graph * @return { (Number | Module) } Current height or Line Chart module to chain calls * @public */ exports.height = function(_x) { if (!arguments.length) { return height; } if (aspectRatio) { width = Math.ceil(_x / aspectRatio); } height = _x; return this; }; /** * Gets or Sets the isAnimated property of the chart, making it to animate when render. * By default this is 'false' * * @param {Boolean} _x Desired animation flag * @return { isAnimated | module} Current isAnimated flag or Chart module * @public */ exports.isAnimated = function(_x) { if (!arguments.length) { return isAnimated; } isAnimated = _x; return this; }; /** * Gets or Sets the margin of the chart * @param {Object} _x Margin object to get/set * @return { (Number | Module) } Current margin or Line Chart module to chain calls * @public */ exports.margin = function(_x) { if (!arguments.length) { return margin; } margin = _x; return this; }; /** * Gets or Sets the curve of the line chart * @param {curve} _x Desired curve for the lines, default 'linear'. Other options are: * basis, natural, monotoneX, monotoneY, step, stepAfter, stepBefore, cardinal, and * catmullRom. Visit https://github.com/d3/d3-shape#curves for more information. * @return { (curve | Module) } Current line curve or Line Chart module to chain calls * @public */ exports.lineCurve = function(_x) { if (!arguments.length) { return lineCurve; } lineCurve = _x; return this; }; /** * Gets or Sets the gradient colors of the line chart when there is only one line * @param {String[]} _x Desired color gradient for the line (array of two hexadecimal numbers) * @return { (Number | Module) } Current color gradient or Line Chart module to chain calls * @public */ exports.lineGradient = function(_x) { if (!arguments.length) { return singleLineGradientColors; } singleLineGradientColors = _x; return this; }; /** * Gets or Sets the minimum width of the graph in order to show the tooltip * NOTE: This could also depend on the aspect ratio * @param {Number} _x Desired tooltip threshold for the graph * @return { (Number | Module) } Current tooltip threshold or Line Chart module to chain calls * @public */ exports.tooltipThreshold = function(_x) { if (!arguments.length) { return tooltipThreshold; } tooltipThreshold = _x; return this; }; /** * Gets or Sets the topicLabel of the chart * @param {Number} _x Desired topicLabel for the graph * @return { topicLabel | module} Current topicLabel or Chart module to chain calls * @public */ exports.topicLabel = function(_x) { if (!arguments.length) { return topicLabel; } topicLabel = _x; return this; }; /** * Gets or Sets the valueLabel of the chart * @param {Number} _x Desired valueLabel for the graph * @return { valueLabel | module} Current valueLabel or Chart module to chain calls * @public */ exports.valueLabel = function(_x) { if (!arguments.length) { return valueLabel; } valueLabel = _x; return this; }; /** * Gets or Sets the number of ticks of the y axis on the chart * (Default is 5) * @param {Number} _x Desired yTicks * @return {Number | module} Current yTicks or Chart module to chain calls * @public */ exports.yTicks = function(_x) { if (!arguments.length) { return yTicks; } yTicks = _x; return this; }; /** * Gets or Sets the width of the chart * @param {Number} _x Desired width for the graph * @return {Number | Module} Current width or Line Chart module to chain calls * @public */ exports.width = function(_x) { if (!arguments.length) { return width; } if (aspectRatio) { height = Math.ceil(_x * aspectRatio); } width = _x; return this; }; /** * Pass language tag for the tooltip to localize the date. * Feature uses Intl.DateTimeFormat, for compatability and support, refer to * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DateTimeFormat * @param {String} _x must be a language tag (BCP 47) like 'en-US' or 'fr-FR' * @return { (String|Module) } Current locale or module to chain calls * @public */ exports.locale = function(_x) { if (!arguments.length) { return locale; } locale = _x; return this; }; /** * Chart exported to png and a download action is fired * @param {String} filename File title for the resulting picture * @param {String} title Title to add at the top of the exported picture * @public */ exports.exportChart = function(filename, title) { exportChart.call(exports, svg, filename, title); }; /** * Exposes an 'on' method that acts as a bridge with the event dispatcher * We are going to expose this events: * customMouseHover, customMouseMove, customMouseOut and customDataEntryClick * * @return {module} Bar Chart * @public */ exports.on = function() { let value = dispatcher.on.apply(dispatcher, arguments); return value === dispatcher ? exports : value; }; /** * Exposes the constants to be used to force the x axis to respect a certain granularity * current options: MINUTE_HOUR, HOUR_DAY, DAY_MONTH, MONTH_YEAR * @example * line.xAxisCustomFormat(line.axisTimeCombinations.HOUR_DAY) */ exports.axisTimeCombinations = axisTimeCombinations; return exports; }; }); × Search results Close "},"donut.js.html":{"id":"donut.js.html","title":"Source: donut.js","body":" Getting started Demos Bar Chart Brush Chart Donut Chart Grouped Bar Chart Kitchen Sink Line Chart Sparkline Chart Stacked Area Chart Stacked Bar Chart Step Chart API Bar Brush Donut Grouped-bar Legend Line Mini-tooltip Sparkline Stacked-area Stacked-bar Step Tooltip Types Github Twitter Source: donut.js define(function(require) { 'use strict'; const d3Dispatch = require('d3-dispatch'); const d3Ease = require('d3-ease'); const d3Interpolate = require('d3-interpolate'); const d3Scale = require('d3-scale'); const d3Shape = require('d3-shape'); const d3Selection = require('d3-selection'); const d3Transition = require('d3-transition'); const {exportChart} = require('./helpers/exportChart'); const textHelper = require('./helpers/text'); const colorHelper = require('./helpers/colors'); const {calculatePercent} = require('./helpers/common'); /** * @typedef DonutChartData * @type {Object[]} * @property {Number} quantity Quantity of the group (required) * @property {Number} percentage Percentage of the total (optional) * @property {String} name Name of the group (required) * @property {Number} id Identifier for the group required for legend feature (optional) * * @example * [ * { * quantity: 1, * percentage: 50, * name: 'glittering', * id: 1 * }, * { * quantity: 1, * percentage: 50, * name: 'luminous', * id: 2 * } * ] */ /** * Reusable Donut Chart API class that renders a * simple and configurable donut chart. * * @module Donut * @tutorial donut * @requires d3-dispatch, d3-ease, d3-interpolate, d3-scale, d3-shape, d3-selection * * @example * var donutChart = donut(); * * donutChart * .externalRadius(500) * .internalRadius(200); * * d3Selection.select('.css-selector') * .datum(dataset) * .call(donutChart); * */ return function module() { let margin = { top: 0, right: 0, bottom: 0, left: 0 }, width = 300, height = 300, ease = d3Ease.easeCubicInOut, arcTransitionDuration = 750, pieDrawingTransitionDuration = 1200, pieHoverTransitionDuration = 150, radiusHoverOffset = 12, paddingAngle = 0, data, chartWidth, chartHeight, externalRadius = 140, internalRadius = 45.5, legendWidth = externalRadius + internalRadius, layout, shape, slices, svg, isAnimated = false, highlightedSliceId, highlightedSlice, hasFixedHighlightedSlice = false, quantityLabel = 'quantity', nameLabel = 'name', percentageLabel = 'percentage', percentageFormat = '.1f', // colors colorScale, colorSchema = colorHelper.colorSchemas.britecharts, // utils storeAngle = function(d) { this._current = d; }, reduceOuterRadius = d =&gt; { d.outerRadius = externalRadius - radiusHoverOffset; }, sortComparator = (a, b) =&gt; b.quantity - a.quantity, sumValues = (data) =&gt; data.reduce((total, d) =&gt; d.quantity + total, 0), // extractors getQuantity = ({quantity}) =&gt; quantity, getSliceFill = ({data}) =&gt; colorScale(data.name), // events dispatcher = d3Dispatch.dispatch('customMouseOver', 'customMouseOut', 'customMouseMove'); /** * This function creates the graph using the selection as container * * @param {D3Selection} _selection A d3 selection that represents * the container(s) where the chart(s) will be rendered * @param {DonutChartData} _data The data to attach and generate the chart */ function exports(_selection) { _selection.each(function(_data) { chartWidth = width - margin.left - margin.right; chartHeight = height - margin.top - margin.bottom; data = cleanData(_data); buildLayout(); buildColorScale(); buildShape(); buildSVG(this); drawSlices(); initTooltip(); if (highlightedSliceId) { initHighlightSlice(); } }); } /** * Builds color scale for chart, if any colorSchema was defined * @private */ function buildColorScale() { if (colorSchema) { colorScale = d3Scale.scaleOrdinal().range(colorSchema); } } /** * Builds containers for the chart, the legend and a wrapper for all of them * @private */ function buildContainerGroups() { let container = svg .append('g') .classed('container-group', true); container .append('g') .classed('chart-group', true); container .append('g') .classed('legend-group', true); } /** * Builds the pie layout that will produce data ready to draw * @private */ function buildLayout() { layout = d3Shape.pie() .padAngle(paddingAngle) .value(getQuantity) .sort(sortComparator); } /** * Builds the shape function * @private */ function buildShape() { shape = d3Shape.arc() .innerRadius(internalRadius) .padRadius(externalRadius); } /** * Builds the SVG element that will contain the chart * * @param {HTMLElement} container DOM element that will work as the container of the graph * @private */ function buildSVG(container) { if (!svg) { svg = d3Selection.select(container) .append('svg') .classed('britechart donut-chart', true); buildContainerGroups(); } // Updates Container Group position svg .select('.container-group') .attr('transform', `translate(${width / 2}, ${height / 2})`); // Updates SVG size svg .attr('width', width) .attr('height', height); } /** * Cleaning data casting the quantities, names and percentages to the proper type while keeping * the rest of properties on the data. It also calculates the percentages if not present. * @param {DonutChartData} data Data as passed to the container * @return {DonutChartData} Clean data with percentages * @private */ function cleanData(data) { let cleanData = data.reduce((acc, d) =&gt; { // Skip data without quantity if (d[quantityLabel] === undefined || d[quantityLabel] === null) { return acc; } d.quantity = +d[quantityLabel]; d.name = String(d[nameLabel]); d.percentage = d[percentageLabel] || null; return [...acc, d]; }, []); let totalQuantity = sumValues(cleanData); let dataWithPercentages = cleanData.map((d) =&gt; { d.percentage = String(d.percentage || calculatePercent(d[quantityLabel], totalQuantity, percentageFormat)); return d; }); return dataWithPercentages; } /** * Cleans any value that could be on the legend text element * @private */ function cleanLegend() { svg.select('.donut-text').text(''); } /** * Draws the values on the donut slice inside the text element * * @param {Object} obj Data object * @private */ function drawLegend(obj) { if (obj.data) { svg.select('.donut-text') .text(() =&gt; `${obj.data.percentage}% ${ obj.data.name}`) .attr('dy', '.2em') .attr('text-anchor', 'middle'); svg.select('.donut-text').call(wrapText, legendWidth); } } /** * Draws the slices of the donut * @private */ function drawSlices() { // Not ideal, we need to figure out how to call exit for nested elements if (slices) { svg.selectAll('g.arc').remove(); } slices = svg.select('.chart-group') .selectAll('g.arc') .data(layout(data)); let newSlices = slices.enter() .append('g') .each(storeAngle) .each(reduceOuterRadius) .classed('arc', true) .append('path'); if (isAnimated) { newSlices.merge(slices) .attr('fill', getSliceFill) .on('mouseover', function(d) { handleMouseOver(this, d, chartWidth, chartHeight); }) .on('mousemove', function(d) { handleMouseMove(this, d, chartWidth, chartHeight); }) .on('mouseout', function(d) { handleMouseOut(this, d, chartWidth, chartHeight); }) .transition() .ease(ease) .duration(pieDrawingTransitionDuration) .attrTween('d', tweenLoading); } else { newSlices.merge(slices) .attr('fill', getSliceFill) .attr('d', shape) .on('mouseover', function(d) { handleMouseOver(this, d, chartWidth, chartHeight); }) .on('mousemove', function(d) { handleMouseMove(this, d, chartWidth, chartHeight); }) .on('mouseout', function(d) { handleMouseOut(this, d, chartWidth, chartHeight); }) } slices.exit().remove(); } /** * Checks if the given element id is the same as the highlightedSliceId and returns the * element if that's the case * @param {DOMElement} options.data Dom element to check * @return {DOMElement} Dom element if it has the same id */ function filterHighlightedSlice({data}) { if (data.id === highlightedSliceId) { return this; } } /** * Handles a path mouse over * @return {void} * @private */ function handleMouseOver(el, d, chartWidth, chartHeight) { drawLegend(d); dispatcher.call('customMouseOver', el, d, d3Selection.mouse(el), [chartWidth, chartHeight]); if (highlightedSlice &amp;&amp; el !== highlightedSlice) { tweenGrowth(highlightedSlice, externalRadius - radiusHoverOffset); } tweenGrowth(el, externalRadius); } /** * Handles a path mouse move * @return {void} * @private */ function handleMouseMove(el, d, chartWidth, chartHeight) { dispatcher.call('customMouseMove', el, d, d3Selection.mouse(el), [chartWidth, chartHeight]); } /** * Handles a path mouse out * @return {void} * @private */ function handleMouseOut(el, d, chartWidth, chartHeight) { cleanLegend(); // When there is a fixed highlighted slice, // we will always highlight it and render legend if (highlightedSlice &amp;&amp; hasFixedHighlightedSlice) { drawLegend(highlightedSlice.__data__); tweenGrowth(highlightedSlice, externalRadius); } // When the current slice is not the highlighted, or there isn't a fixed highlighted slice and it is the highlighted // we will shrink the slice if (el !== highlightedSlice || (!hasFixedHighlightedSlice &amp;&amp; el === highlightedSlice) ) { tweenGrowth(el, externalRadius - radiusHoverOffset, pieHoverTransitionDuration); } dispatcher.call('customMouseOut', el, d, d3Selection.mouse(el), [chartWidth, chartHeight]); } /** * Find the slice by id and growth it if needed * @private */ function initHighlightSlice() { highlightedSlice = svg.selectAll('.chart-group .arc path') .select(filterHighlightedSlice).node(); if (highlightedSlice) { drawLegend(highlightedSlice.__data__); tweenGrowth(highlightedSlice, externalRadius, pieDrawingTransitionDuration); } } /** * Creates the text element that will hold the legend of the chart */ function initTooltip() { svg.select('.legend-group') .append('text') .attr('class', 'donut-text'); } /** * Stores current angles and interpolates with new angles * Check out {@link http://bl.ocks.org/mbostock/1346410| this example} * * @param {Object} a New data for slice * @return {Function} Tweening function for the donut shape * @private */ function tweenArc(a) { let i = d3Interpolate.interpolate(this._current, a); this._current = i(0); return function(t) { return shape(i(t)); }; } /** * Animate slice with tweens depending on the attributes given * * @param {DOMElement} slice Slice to growth * @param {Number} outerRadius Final outer radius value * @param {Number} delay Delay of animation * @private */ function tweenGrowth(slice, outerRadius, delay = 0) { d3Selection.select(slice) .transition() .delay(delay) .attrTween('d', function(d) { let i = d3Interpolate.interpolate(d.outerRadius, outerRadius); return (t) =&gt; { d.outerRadius = i(t); return shape(d); }; }); } /** * Animation for chart loading * Check out {@link http://bl.ocks.org/mbostock/4341574| this example} * * @param {Object} b Data point * @return {Function} Tween function * @private */ function tweenLoading(b) { let i; b.innerRadius = 0; i = d3Interpolate.interpolate({ startAngle: 0, endAngle: 0}, b); return function(t) { return shape(i(t)); }; } /** * Utility function that wraps a text into the given width * * @param {D3Selection} text Text to write * @param {Number} legendWidth Width of the container * @private */ function wrapText(text, legendWidth) { let fontSize = externalRadius / 5; textHelper.wrapText.call(null, 0, fontSize, legendWidth, text.node()); } // API /** * Gets or Sets the colorSchema of the chart * @param {String[]} _x Desired colorSchema for the graph * @return { String | module} Current colorSchema or Chart module to chain calls * @public */ exports.colorSchema = function(_x) { if (!arguments.length) { return colorSchema; } colorSchema = _x; return this; }; /** * Chart exported to png and a download action is fired * @param {String} filename File title for the resulting picture * @param {String} title Title to add at the top of the exported picture * @public */ exports.exportChart = function(filename, title) { exportChart.call(exports, svg, filename, title); }; /** * Gets or Sets the externalRadius of the chart * @param {Number} _x ExternalRadius number to get/set * @return { (Number | Module) } Current externalRadius or Donut Chart module to chain calls * @public */ exports.externalRadius = function(_x) { if (!arguments.length) { return externalRadius; } externalRadius = _x; return this; }; /** * Gets or Sets the hasFixedHighlightedSlice property of the chart, making it to * highlight the selected slice id set with `highlightSliceById` all the time. * * @param {Boolean} _x If we want to make the highlighted slice permanently highlighted * @return { Boolean | module} Current hasFixedHighlightedSlice flag or Chart module * @public */ exports.hasFixedHighlightedSlice = function(_x) { if (!arguments.length) { return hasFixedHighlightedSlice; } hasFixedHighlightedSlice = _x; return this; }; /** * Gets or Sets the height of the chart * @param {Number} _x Desired width for the graph * @return { (Number | Module) } Current height or Donut Chart module to chain calls * @public */ exports.height = function(_x) { if (!arguments.length) { return height; } height = _x; return this; }; /** * Gets or Sets the id of the slice to highlight * @param {Number} _x Slice id * @return { (Number | Module) } Current highlighted slice id or Donut Chart module to chain calls * @public */ exports.highlightSliceById = function(_x) { if (!arguments.length) { return highlightedSliceId; } highlightedSliceId = _x; return this; }; /** * Gets or Sets the internalRadius of the chart * @param {Number} _x InternalRadius number to get/set * @return { (Number | Module) } Current internalRadius or Donut Chart module to chain calls * @public */ exports.internalRadius = function(_x) { if (!arguments.length) { return internalRadius; } internalRadius = _x; return this; }; /** * Gets or Sets the isAnimated property of the chart, making it to animate when render. * By default this is 'false' * * @param {Boolean} _x Desired animation flag * @return { Boolean | module} Current isAnimated flag or Chart module * @public */ exports.isAnimated = function(_x) { if (!arguments.length) { return isAnimated; } isAnimated = _x; return this; }; /** * Gets or Sets the margin of the chart * @param {Object} _x Margin object to get/set * @return { (Object | Module) } Current margin or Donut Chart module to chain calls * @public */ exports.margin = function(_x) { if (!arguments.length) { return margin; } margin = _x; return this; }; /** * Exposes an 'on' method that acts as a bridge with the event dispatcher * We are going to expose this events: * customMouseOver, customMouseMove and customMouseOut * * @return {module} Bar Chart * @public */ exports.on = function() { let value = dispatcher.on.apply(dispatcher, arguments); return value === dispatcher ? exports : value; }; /** * Gets or Sets the width of the chart * @param {Number} _x Desired width for the graph * @return { (Number | Module) } Current width or Donut Chart module to chain calls * @public */ exports.width = function(_x) { if (!arguments.length) { return width; } width = _x; return this; }; return exports; }; }); × Search results Close "},"grouped-bar.js.html":{"id":"grouped-bar.js.html","title":"Source: grouped-bar.js","body":" Getting started Demos Bar Chart Brush Chart Donut Chart Grouped Bar Chart Kitchen Sink Line Chart Sparkline Chart Stacked Area Chart Stacked Bar Chart Step Chart API Bar Brush Donut Grouped-bar Legend Line Mini-tooltip Sparkline Stacked-area Stacked-bar Step Tooltip Types Github Twitter Source: grouped-bar.js define(function (require) { 'use strict'; const d3Array = require('d3-array'); const d3Axis = require('d3-axis'); const d3Color = require('d3-color'); const d3Collection = require('d3-collection'); const d3Dispatch = require('d3-dispatch'); const d3Ease = require('d3-ease'); const d3Interpolate = require('d3-interpolate'); const d3Scale = require('d3-scale'); const d3Selection = require('d3-selection'); const assign = require('lodash.assign'); const d3Transition = require('d3-transition'); const { exportChart } = require('./helpers/exportChart'); const colorHelper = require('./helpers/colors'); const NUMBER_FORMAT = ',f'; const uniq = (arrArg) =&gt; arrArg.filter((elem, pos, arr) =&gt; arr.indexOf(elem) == pos); /** * @typdef D3Layout * @type function */ /** * @typedef GroupedBarChartData * @type {Object} * @property {Object[]} data All data entries * @property {String} name Name of the entry * @property {String} group group of the entry * @property {Number} value Value of the entry * * @example * { * 'data': [ * { * &quot;name&quot;: &quot;2011-01&quot;, * &quot;group&quot;: &quot;Direct&quot;, * &quot;value&quot;: 0 * } * ] * } */ /** * Grouped Bar Chart reusable API module that allows us * rendering a multi grouped bar and configurable chart. * * @module Grouped-bar * @tutorial grouped-bar * @requires d3-array, d3-axis, d3-color, d3-collection, d3-dispatch, d3-ease, * d3-interpolate, d3-scale, d3-selection, lodash assign * * @example * let groupedBar = GroupedBar(); * * groupedBar * .width(containerWidth); * * d3Selection.select('.css-selector') * .datum(dataset.data) * .call(groupedBar); * */ return function module() { let margin = { top: 40, right: 30, bottom: 60, left: 70 }, width = 960, height = 500, xScale, xScale2, xAxis, yScale, yScale2, yAxis, aspectRatio = null, yTickTextOffset = { y: -8, x: -20 }, yTicks = 5, xTicks = 5, baseLine, colorSchema = colorHelper.colorSchemas.britecharts, colorScale, categoryColorMap, layers, ease = d3Ease.easeQuadInOut, isHorizontal = false, svg, chartWidth, chartHeight, data, groups, layerElements, transformedData, tooltipThreshold = 480, xAxisPadding = { top: 0, left: 0, bottom: 0, right: 0 }, maxBarNumber = 8, barOpacity = 0.24, animationDelayStep = 20, animationDelays = d3Array.range(animationDelayStep, maxBarNumber * animationDelayStep, animationDelayStep), animationDuration = 1000, grid = null, nameLabel = 'name', valueLabel = 'value', groupLabel = 'group', valueLabelFormat = NUMBER_FORMAT, // getters getName = ({name}) =&gt; name, getValue = ({value}) =&gt; value, getGroup = ({group}) =&gt; group, isAnimated = false, // events dispatcher = d3Dispatch.dispatch('customMouseOver', 'customMouseOut', 'customMouseMove'); /** * This function creates the graph using the selection and data provided * @param {D3Selection} _selection A d3 selection that represents * the container(s) where the chart(s) will be rendered * @param {GroupedBarChartData} _data The data to attach and generate the chart */ function exports(_selection) { _selection.each(function (_data) { chartWidth = width - margin.left - margin.right; chartHeight = height - margin.top - margin.bottom; data = cleanData(_data); prepareData(data); buildScales(); buildLayers(); buildSVG(this); drawGridLines(); buildAxis(); drawAxis(); drawGroupedBar(); addMouseEvents(); }); } /** * Adds events to the container group if the environment is not mobile * Adding: mouseover, mouseout and mousemove */ function addMouseEvents() { if (shouldShowTooltip()) { svg .on('mouseover', function(d) { handleMouseOver(this, d); }) .on('mouseout', function(d) { handleMouseOut(this, d); }) .on('mousemove', function(d) { handleMouseMove(this, d); }); } svg.selectAll('.bar') .on('mouseover', function(d) { handleBarsMouseOver(this, d); }) .on('mouseout', function(d) { handleBarsMouseOut(this, d); }); } /** * Adjusts the position of the y axis' ticks * @param {D3Selection} selection Y axis group * @return void */ function adjustYTickLabels(selection) { selection.selectAll('.tick text') .attr('transform', `translate(${yTickTextOffset['x']}, ${yTickTextOffset['y']})`); } /** * Creates the d3 x and y axis, setting orientations * @private */ function buildAxis() { if (isHorizontal) { xAxis = d3Axis.axisBottom(xScale) .ticks(xTicks, valueLabelFormat); yAxis = d3Axis.axisLeft(yScale) } else { xAxis = d3Axis.axisBottom(xScale) yAxis = d3Axis.axisLeft(yScale) .ticks(yTicks, valueLabelFormat) } } /** * Builds containers for the chart, the axis and a wrapper for all of them * NOTE: The order of drawing of this group elements is really important, * as everything else will be drawn on top of them * @private */ function buildContainerGroups() { let container = svg .append('g') .classed('container-group', true) .attr('transform', `translate(${margin.left},${margin.top})`); container .append('g').classed('x-axis-group', true) .append('g').classed('x axis', true); container.selectAll('.x-axis-group') .append('g').classed('month-axis', true); container .append('g').classed('y-axis-group axis', true); container .append('g').classed('grid-lines-group', true); container .append('g').classed('chart-group', true); container .append('g').classed('metadata-group', true); } /** * Builds the grouped layers layout * @return {D3Layout} Layout for drawing the chart * @private */ function buildLayers() { layers = transformedData.map((item) =&gt; { let ret = {}; groups.forEach((key) =&gt; { ret[key] = item[key]; }); return assign({}, item, ret); }); } /** * Creates the x, y and color scales of the chart * @private */ function buildScales() { let yMax = d3Array.max(data.map(getValue)); if (isHorizontal) { xScale = d3Scale.scaleLinear() .domain([0, yMax]) .rangeRound([0, chartWidth - 1]); // 1 pix for edge tick yScale = d3Scale.scaleBand() .domain(data.map(getName)) .rangeRound([chartHeight, 0]) .padding(0.1); yScale2 = d3Scale.scaleBand() .domain(data.map(getGroup)) .rangeRound([yScale.bandwidth(), 0]) .padding(0.1); } else { xScale = d3Scale.scaleBand() .domain(data.map(getName)) .rangeRound([0, chartWidth]) .padding(0.1); xScale2 = d3Scale.scaleBand() .domain(data.map(getGroup)) .rangeRound([0, xScale.bandwidth()]) .padding(0.1); yScale = d3Scale.scaleLinear() .domain([0, yMax]) .rangeRound([chartHeight, 0]) .nice(); } colorScale = d3Scale.scaleOrdinal() .range(colorSchema) .domain(data.map(getGroup)); categoryColorMap = colorScale .domain(data.map(getName)).domain() .reduce((memo, item) =&gt; { data.forEach(function (v) { if (getName(v) == item) { memo[v.name] = colorScale(v.group) memo[v.group] = colorScale(v.group) memo[v.group + item] = colorScale(v.group) } }) return memo; }, {}); } /** * @param {HTMLElement} container DOM element that will work as the container of the graph * @private */ function buildSVG(container) { if (!svg) { svg = d3Selection.select(container) .append('svg') .classed('britechart grouped-bar', true); buildContainerGroups(); } svg .attr('width', width) .attr('height', height); } /** * Cleaning data casting the values, groups, topic names and names to the proper type while keeping * the rest of properties on the data * @param {GroupedBarChartData} originalData Raw data from the container * @return {GroupedBarChartData} Parsed data with values and dates * @private */ function cleanData(originalData) { return originalData.reduce((acc, d) =&gt; { d.value = +d[valueLabel]; d.group = d[groupLabel]; // for tooltip d.topicName = getGroup(d); d.name = d[nameLabel]; return [...acc, d]; }, []); } /** * Draws the x and y axis on the svg object within their * respective groups * @private */ function drawAxis() { if (isHorizontal) { svg.select('.x-axis-group .axis.x') .attr('transform', `translate( 0, ${chartHeight} )`) .call(xAxis); svg.select('.y-axis-group.axis') .attr('transform', `translate( ${-xAxisPadding.left}, 0)`) .call(yAxis); } else { svg.select('.x-axis-group .axis.x') .attr('transform', `translate( 0, ${chartHeight} )`) .call(xAxis); svg.select('.y-axis-group.axis') .attr('transform', `translate( ${-xAxisPadding.left}, 0)`) .call(yAxis) .call(adjustYTickLabels); } } /** * Draws a vertical line to extend x-axis till the edges * @return {void} */ function drawHorizontalExtendedLine() { baseLine = svg.select('.grid-lines-group') .selectAll('line.extended-x-line') .data([0]) .enter() .append('line') .attr('class', 'extended-x-line') .attr('x1', (xAxisPadding.left)) .attr('x2', chartWidth) .attr('y1', chartHeight) .attr('y2', chartHeight); } /** * Draws a vertical line to extend y-axis till the edges * @return {void} */ function drawVerticalExtendedLine() { baseLine = svg.select('.grid-lines-group') .selectAll('line.extended-y-line') .data([0]) .enter() .append('line') .attr('class', 'extended-y-line') .attr('y1', (xAxisPadding.bottom)) .attr('y2', chartHeight) .attr('x1', 0) .attr('x2', 0); } /** * Draws grid lines on the background of the chart * @return void */ function drawGridLines() { let scale = isHorizontal ? xScale : yScale; if (grid === 'horizontal' || grid === 'full') { svg.select('.grid-lines-group') .selectAll('line.horizontal-grid-line') .data(scale.ticks(yTicks).slice(1)) .enter() .append('line') .attr('class', 'horizontal-grid-line') .attr('x1', (-xAxisPadding.left + 1)) .attr('x2', chartWidth) .attr('y1', (d) =&gt; yScale(d)) .attr('y2', (d) =&gt; yScale(d)); } if (grid === 'vertical' || grid === 'full') { svg.select('.grid-lines-group') .selectAll('line.vertical-grid-line') .data(scale.ticks(xTicks).slice(1)) .enter() .append('line') .attr('class', 'vertical-grid-line') .attr('y1', 0) .attr('y2', chartHeight) .attr('x1', (d) =&gt; xScale(d)) .attr('x2', (d) =&gt; xScale(d)); } if (isHorizontal) { drawVerticalExtendedLine(); } else { drawHorizontalExtendedLine(); } } /** * Draws the bars along the x axis * @param {D3Selection} layersSelection Selection of layers * @return {void} */ function drawHorizontalBars(layersSelection) { let layerJoin = layersSelection .data(layers); layerElements = layerJoin .enter() .append('g') .attr('transform', ({key}) =&gt; `translate(0,${yScale(key)})`) .classed('layer', true); let barJoin = layerElements .selectAll('.bar') .data(({values}) =&gt; values); // Enter + Update let bars = barJoin .enter() .append('rect') .classed('bar', true) .attr('x', 1) .attr('y', (d) =&gt; yScale2(getGroup(d))) .attr('height', yScale2.bandwidth()) .attr('fill', (({group}) =&gt; categoryColorMap[group])); if (isAnimated) { bars.style('opacity', barOpacity) .transition() .delay((_, i) =&gt; animationDelays[i]) .duration(animationDuration) .ease(ease) .tween('attr.width', horizontalBarsTween); } else { bars.attr('width', (d) =&gt; xScale(getValue(d))); } } /** * Draws the bars along the y axis * @param {D3Selection} layersSelection Selection of layers * @return {void} */ function drawVerticalBars(layersSelection) { let layerJoin = layersSelection .data(layers); layerElements = layerJoin .enter() .append('g') .attr('transform', ({key}) =&gt; `translate(${xScale(key)},0)`) .classed('layer', true); let barJoin = layerElements .selectAll('.bar') .data(({values}) =&gt; values); let bars = barJoin .enter() .append('rect') .classed('bar', true) .attr('x', (d) =&gt; xScale2(getGroup(d))) .attr('y', ({value}) =&gt; yScale(value)) .attr('width', xScale2.bandwidth) .attr('fill', (({group}) =&gt; categoryColorMap[group])); if (isAnimated) { bars.style('opacity', barOpacity) .transition() .delay((_, i) =&gt; animationDelays[i]) .duration(animationDuration) .ease(ease) .tween('attr.height', verticalBarsTween); } else { bars.attr('height', (d) =&gt; chartHeight - yScale(getValue(d))); } } /** * Draws the different areas into the chart-group element * @private */ function drawGroupedBar() { // Not ideal, we need to figure out how to call exit for nested elements if (layerElements) { svg.selectAll('.layer').remove(); } let series = svg.select('.chart-group').selectAll('.layer'); if (isHorizontal) { drawHorizontalBars(series); } else { drawVerticalBars(series); } // Exit series.exit() .transition() .style('opacity', 0) .remove(); } /** * Extract X position on the chart from a given mouse event * @param {obj} event D3 mouse event * @return {Number} Position on the x axis of the mouse * @private */ function getMousePosition(event) { return d3Selection.mouse(event); } /** * Finds out the data entry that is closer to the given position on pixels * @param {Number} mouseX X position of the mouse * @return {obj} Data entry that is closer to that x axis position */ function getNearestDataPoint(mouseX) { let adjustedMouseX = mouseX - margin.left, epsilon = xScale2.bandwidth(), nearest = []; layers.forEach(function (data) { let found = data.values.find((d2) =&gt; Math.abs(adjustedMouseX &gt;= xScale(d2[nameLabel]) + xScale2(d2[groupLabel])) &amp;&amp; Math.abs(adjustedMouseX - xScale2(d2[groupLabel]) - xScale(d2[nameLabel]) &lt;= epsilon)); if (found) { found.values = data.values; found.key = found.name; nearest.push(found); } }); return nearest.length ? nearest[0] : undefined; } /** * Finds out the data entry that is closer to the given position on pixels * @param {Number} mouseX X position of the mouse * @return {obj} Data entry that is closer to that x axis position */ function getNearestDataPoint2(mouseY) { let adjustedMouseY = mouseY - margin.bottom, epsilon = yScale.bandwidth(), nearest = []; layers.map(function (data) { let found = data.values.find((d2) =&gt; Math.abs(adjustedMouseY &gt;= yScale(d2[nameLabel])) &amp;&amp; Math.abs(adjustedMouseY - yScale(d2[nameLabel]) &lt;= epsilon * 2)); if (found) { found.values = data.values; found.key = found.name; nearest.push(found) } }); return nearest.length ? nearest[0] : undefined; } /** * Handles a mouseover event on top of a bar * @param {obj} e the fired event * @param {obj} d data of bar * @return {void} */ function handleBarsMouseOver(e, d) { d3Selection.select(e) .attr('fill', () =&gt; d3Color.color(categoryColorMap[d.group]).darker()); } /** * Handles a mouseout event out of a bar * @param {obj} e the fired event * @param {obj} d data of bar * @return {void} */ function handleBarsMouseOut(e, d) { d3Selection.select(e) .attr('fill', () =&gt; categoryColorMap[d.group]) } /** * MouseMove handler, calculates the nearest dataPoint to the cursor * and updates metadata related to it * @param {obj} e the fired event * @private */ function handleMouseMove(e) { let [mouseX, mouseY] = getMousePosition(e), dataPoint = isHorizontal ? getNearestDataPoint2(mouseY) : getNearestDataPoint(mouseX), x, y; if (dataPoint) { // Move verticalMarker to that datapoint if (isHorizontal) { x = mouseX - margin.left; y = yScale(dataPoint.key) + yScale.bandwidth() / 2; } else { x = xScale(dataPoint.key) + xScale2(dataPoint[groupLabel]); y = mouseY - margin.bottom; } moveTooltipOriginXY(x, y); // Emit event with xPosition for tooltip or similar feature dispatcher.call('customMouseMove', e, dataPoint, categoryColorMap, x, y); } } /** * MouseOut handler, hides overlay and removes active class on verticalMarkerLine * It also resets the container of the vertical marker * @private */ function handleMouseOut(e, d) { svg.select('.metadata-group').attr('transform', 'translate(9999, 0)'); dispatcher.call('customMouseOut', e, d, d3Selection.mouse(e)); } /** * Mouseover handler, shows overlay and adds active class to verticalMarkerLine * @private */ function handleMouseOver(e, d) { dispatcher.call('customMouseOver', e, d, d3Selection.mouse(e)); } /** * Animation tween of horizontal bars * @param {obj} d data of bar * @return {void} */ function horizontalBarsTween(d) { let node = d3Selection.select(this), i = d3Interpolate.interpolateRound(0, xScale(getValue(d))), j = d3Interpolate.interpolateNumber(0, 1); return function (t) { node.attr('width', i(t)) .style('opacity', j(t)); } } /** * Helper method to update the x position of the vertical marker * @param {obj} dataPoint Data entry to extract info * @return void */ function moveTooltipOriginXY(originXPosition, originYPosition) { svg.select('.metadata-group') .attr('transform', `translate(${originXPosition},${originYPosition})`); } /** * Prepare data for create chart. * @private */ function prepareData(data) { groups = uniq(data.map((d) =&gt; getGroup(d))); transformedData = d3Collection.nest() .key(getName) .rollup(function (values) { let ret = {}; values.forEach((entry) =&gt; { if (entry &amp;&amp; entry[groupLabel]) { ret[entry[groupLabel]] = getValue(entry); } }); //for tooltip ret.values = values; return ret; }) .entries(data) .map(function (data) { return assign({}, { total: d3Array.sum(d3Array.permute(data.value, groups)), key: data.key }, data.value); }); } /** * Determines if we should add the tooltip related logic depending on the * size of the chart and the tooltipThreshold variable value * @return {boolean} Should we build the tooltip? * @private */ function shouldShowTooltip() { return width &gt; tooltipThreshold; } /** * Animation tween of vertical bars * @param {obj} d data of bar * @return {void} */ function verticalBarsTween(d) { let node = d3Selection.select(this), i = d3Interpolate.interpolateRound(0, chartHeight - yScale(getValue(d))), y = d3Interpolate.interpolateRound(chartHeight, yScale(getValue(d))), j = d3Interpolate.interpolateNumber(0, 1); return function (t) { node.attr('y', y(t)) .attr('height', i(t)).style('opacity', j(t)); } } // API /** * Gets or Sets the aspect ratio of the chart * @param {Number} _x Desired aspect ratio for the graph * @return { (Number | Module) } Current aspect ratio or Area Chart module to chain calls * @public */ exports.aspectRatio = function (_x) { if (!arguments.length) { return aspectRatio; } aspectRatio = _x; return this; }; /** * Gets or Sets the colorSchema of the chart * @param {String[]} _x Desired colorSchema for the graph * @return { colorSchema | module} Current colorSchema or Chart module to chain calls * @public */ exports.colorSchema = function (_x) { if (!arguments.length) { return colorSchema; } colorSchema = _x; return this; }; /** * Chart exported to png and a download action is fired * @param {String} filename File title for the resulting picture * @param {String} title Title to add at the top of the exported picture * @public */ exports.exportChart = function (filename, title) { exportChart.call(exports, svg, filename, title); }; /** * Gets or Sets the groupLabel of the chart * @param {String} _x Desired groupLabel for the graph * @return { groupLabel | module} Current groupLabel or Chart module to chain calls * @public */ exports.groupLabel = function (_x) { if (!arguments.length) { return groupLabel; } groupLabel = _x; return this; }; /** * Gets or Sets the grid mode. * * @param {String} _x Desired mode for the grid ('vertical'|'horizontal'|'full') * @return { String | module} Current mode of the grid or Area Chart module to chain calls * @public */ exports.grid = function (_x) { if (!arguments.length) { return grid; } grid = _x; return this; }; /** * Gets or Sets the height of the chart * @param {Number} _x Desired width for the graph * @return { height | module} Current height or Area Chart module to chain calls * @public */ exports.height = function (_x) { if (!arguments.length) { return height; } if (aspectRatio) { width = Math.ceil(_x / aspectRatio); } height = _x; return this; }; /** * Gets or Sets the horizontal direction of the chart * @param {number} _x Desired horizontal direction for the graph * @return { isHorizontal | module} If it is horizontal or Bar Chart module to chain calls * @public */ exports.isHorizontal = function (_x) { if (!arguments.length) { return isHorizontal; } isHorizontal = _x; return this; }; /** * Gets or Sets the isAnimated property of the chart, making it to animate when render. * By default this is 'false' * * @param {Boolean} _x Desired animation flag * @return { isAnimated | module} Current isAnimated flag or Chart module * @public */ exports.isAnimated = function (_x) { if (!arguments.length) { return isAnimated; } isAnimated = _x; return this; }; /** * Gets or Sets the margin of the chart * @param {Object} _x Margin object to get/set * @return { margin | module} Current margin or Area Chart module to chain calls * @public */ exports.margin = function (_x) { if (!arguments.length) { return margin; } margin = _x; return this; }; /** * Gets or Sets the nameLabel of the chart * @param {Number} _x Desired dateLabel for the graph * @return { nameLabel | module} Current nameLabel or Chart module to chain calls * @public */ exports.nameLabel = function (_x) { if (!arguments.length) { return nameLabel; } nameLabel = _x; return this; }; /** * Gets or Sets the number of ticks of the y axis on the chart * @param {Number} _x Desired vertical ticks * @return {Number | module} Current yTicks or Chart module to chain calls * @public */ exports.yTicks = function (_x) { if (!arguments.length) { return yTicks; } yTicks = _x; return this; }; /** * Exposes an 'on' method that acts as a bridge with the event dispatcher * We are going to expose this events: * customMouseOver, customMouseMove and customMouseOut * * @return {module} Bar Chart * @public */ exports.on = function () { let value = dispatcher.on.apply(dispatcher, arguments); return value === dispatcher ? exports : value; }; /** * Gets or Sets the minimum width of the graph in order to show the tooltip * NOTE: This could also depend on the aspect ratio * * @param {Object} _x Margin object to get/set * @return { tooltipThreshold | module} Current tooltipThreshold or Area Chart module to chain calls * @public */ exports.tooltipThreshold = function (_x) { if (!arguments.length) { return tooltipThreshold; } tooltipThreshold = _x; return this; }; /** * Gets or Sets the valueLabel of the chart * @param {Number} _x Desired valueLabel for the graph * @return { valueLabel | module} Current valueLabel or Chart module to chain calls * @public */ exports.valueLabel = function (_x) { if (!arguments.length) { return valueLabel; } valueLabel = _x; return this; }; /** * Gets or Sets the valueLabelFormat of the chart * @param {String[]} _x Desired valueLabelFormat for the graph * @return { valueLabelFormat | module} Current valueLabelFormat or Chart module to chain calls * @public */ exports.valueLabelFormat = function (_x) { if (!arguments.length) { return valueLabelFormat; } valueLabelFormat = _x; return this; }; /** * Gets or Sets the width of the chart * @param {Number} _x Desired width for the graph * @return { width | module} Current width or Area Chart module to chain calls * @public */ exports.width = function (_x) { if (!arguments.length) { return width; } if (aspectRatio) { height = Math.ceil(_x * aspectRatio); } width = _x; return this; }; /** * Gets or Sets the number of ticks of the x axis on the chart * @param {Number} _x Desired xTicks * @return {Number | module} Current xTicks or Chart module to chain calls * @public */ exports.xTicks = function (_x) { if (!arguments.length) { return xTicks; } xTicks = _x; return this; }; /** * Gets or Sets the x and y offset of ticks of the y axis on the chart * @param {Object} _x Desired offset * @return {Object | module} Current offset or Chart module to chain calls * @public */ exports.yTickTextOffset = function (_x) { if (!arguments.length) { return yTickTextOffset; } yTickTextOffset = _x; return this; }; return exports; }; }); × Search results Close "},"legend.js.html":{"id":"legend.js.html","title":"Source: legend.js","body":" Getting started Demos Bar Chart Brush Chart Donut Chart Grouped Bar Chart Kitchen Sink Line Chart Sparkline Chart Stacked Area Chart Stacked Bar Chart Step Chart API Bar Brush Donut Grouped-bar Legend Line Mini-tooltip Sparkline Stacked-area Stacked-bar Step Tooltip Types Github Twitter Source: legend.js define(function(require){ 'use strict'; const d3Format = require('d3-format'); const d3Scale = require('d3-scale'); const d3Selection = require('d3-selection'); const d3Transition = require('d3-transition'); const textHelper = require('./helpers/text'); const colorHelper = require('./helpers/colors'); /** * @typedef LegendChartData * @type {Object[]} * @property {Number} id Id of the group (required) * @property {Number} quantity Quantity of the group (required) * @property {String} name Name of the group (required) * * @example * [ * { * id: 1, * quantity: 2, * name: 'glittering' * }, * { * id: 2, * quantity: 3, * name: 'luminous' * } */ /** * @fileOverview Legend Component reusable API class that renders a * simple and configurable legend element. * * @example * var donutChart = donut(), * legendBox = legend(); * * donutChart * .externalRadius(500) * .internalRadius(200) * .on('customMouseOver', function(data) { * legendBox.highlight(data.data.id); * }) * .on('customMouseOut', function() { * legendBox.clearHighlight(); * }); * * d3Selection.select('.css-selector') * .datum(dataset) * .call(donutChart); * * d3Selection.select('.other-css-selector') * .datum(dataset) * .call(legendBox); * * @module Legend * @tutorial legend * @exports charts/legend * @requires d3 */ return function module() { let margin = { top: 5, right: 5, bottom: 5, left: 5 }, width = 320, height = 180, textSize = 12, textLetterSpacing = 0.5, markerSize = 16, markerYOffset = - (textSize - 2) / 2, marginRatio = 1.5, valueReservedSpace = 40, numberLetterSpacing = 0.8, numberFormat = 's', isFadedClassName = 'is-faded', isHorizontal = false, // colors colorScale, colorSchema = colorHelper.colorSchemas.britecharts, getId = ({id}) =&gt; id, getName = ({name}) =&gt; name, getFormattedQuantity = ({quantity}) =&gt; d3Format.format(numberFormat)(quantity), getCircleFill = ({name}) =&gt; colorScale(name), entries, chartWidth, chartHeight, data, svg; /** * This function creates the graph using the selection as container * @param {D3Selection} _selection A d3 selection that represents * the container(s) where the chart(s) will be rendered * @param {object} _data The data to attach and generate the chart * @private */ function exports(_selection) { _selection.each(function(_data){ chartWidth = width - margin.left - margin.right; chartHeight = height - margin.top - margin.bottom; data = _data; buildColorScale(); buildSVG(this); if (isHorizontal) { drawHorizontalLegend(); } else { drawVerticalLegend(); } }); } /** * Depending on the size of the horizontal legend, we are going to either * center the legend or add a new line with the last entry of the legend * @return {void} * @private */ function adjustLines() { let lineWidth = svg.select('.legend-line').node().getBoundingClientRect().width; let lineWidthSpace = chartWidth - lineWidth; if (lineWidthSpace &gt; 0) { centerLegendOnSVG(); } else { splitInLines(); } } /** * Builds containers for the legend * Also applies the Margin convention * @private */ function buildContainerGroups() { let container = svg .append('g') .classed('legend-container-group', true) .attr('transform', `translate(${margin.left},${margin.top})`); container .append('g') .classed('legend-group', true); } /** * Builds color scale for chart, if any colorSchema was defined * @private */ function buildColorScale() { if (colorSchema) { colorScale = d3Scale.scaleOrdinal().range(colorSchema); } } /** * Builds the SVG element that will contain the chart * @param {HTMLElement} container DOM element that will work as the container of the graph * @private */ function buildSVG(container) { if (!svg) { svg = d3Selection.select(container) .append('svg') .classed('britechart britechart-legend', true); buildContainerGroups(); } svg .attr('width', width) .attr('height', height); } /** * Centers the legend on the chart given that is a single line of labels * @return {void} * @private */ function centerLegendOnSVG() { let legendGroupSize = svg.select('g.legend-container-group').node().getBoundingClientRect().width; let emptySpace = width - legendGroupSize; if (emptySpace &gt; 0) { svg.select('g.legend-container-group') .attr('transform', `translate(${emptySpace/2},0)`) } } /** * Removes the faded class from all the entry lines * @private */ function cleanFadedLines() { svg.select('.legend-group') .selectAll('g.legend-entry') .classed(isFadedClassName, false); } /** * Draws the entries of the legend within a single line * @private */ function drawHorizontalLegend() { let xOffset = markerSize; // We want a single line svg.select('.legend-group') .append('g') .classed('legend-line', true); // And one entry per data item entries = svg.select('.legend-line') .selectAll('g.legend-entry') .data(data); // Enter entries.enter() .append('g') .classed('legend-entry', true) .attr('data-item', getId) .attr('transform', function({name}) { let horizontalOffset = xOffset, lineHeight = chartHeight / 2, verticalOffset = lineHeight, labelWidth = textHelper.getTextWidth(name, textSize); xOffset += markerSize + 2 * getLineElementMargin() + labelWidth; return `translate(${horizontalOffset},${verticalOffset})`; }) .merge(entries) .append('circle') .classed('legend-circle', true) .attr('cx', markerSize/2) .attr('cy', markerYOffset) .attr('r', markerSize / 2) .style('fill', getCircleFill) .style('stroke-width', 1); svg.select('.legend-group') .selectAll('g.legend-entry') .append('text') .classed('legend-entry-name', true) .text(getName) .attr('x', getLineElementMargin()) .style('font-size', `${textSize}px`) .style('letter-spacing', `${textLetterSpacing}px`); // Exit svg.select('.legend-group') .selectAll('g.legend-entry') .exit() .transition() .style('opacity', 0) .remove(); adjustLines(); } /** * Draws the entries of the legend * @private */ function drawVerticalLegend() { entries = svg.select('.legend-group') .selectAll('g.legend-line') .data(data); // Enter entries.enter() .append('g') .classed('legend-line', true) .append('g') .classed('legend-entry', true) .attr('data-item', getId) .attr('transform', function(d, i) { let horizontalOffset = markerSize + getLineElementMargin(), lineHeight = chartHeight/ (data.length + 1), verticalOffset = (i + 1) * lineHeight; return `translate(${horizontalOffset},${verticalOffset})`; }) .merge(entries) .append('circle') .classed('legend-circle', true) .attr('cx', markerSize/2) .attr('cy', markerYOffset) .attr('r', markerSize/2 ) .style('fill', getCircleFill) .style('stroke-width', 1); svg.select('.legend-group') .selectAll('g.legend-line') .selectAll('g.legend-entry') .append('text') .classed('legend-entry-name', true) .text(getName) .attr('x', getLineElementMargin()) .style('font-size', `${textSize}px`) .style('letter-spacing', `${textLetterSpacing}px`); svg.select('.legend-group') .selectAll('g.legend-line') .selectAll('g.legend-entry') .append('text') .classed('legend-entry-value', true) .text(getFormattedQuantity) .attr('x', chartWidth - valueReservedSpace) .style('font-size', `${textSize}px`) .style('letter-spacing', `${numberLetterSpacing}px`) .style('text-anchor', 'end') .style('startOffset', '100%'); // Exit svg.select('.legend-group') .selectAll('g.legend-line') .exit() .transition() .style('opacity', 0) .remove(); } /** * Applies the faded class to all lines but the one that has the given id * @param {number} exceptionItemId Id of the line that needs to stay the same * @private */ function fadeLinesBut(exceptionItemId) { let classToFade = 'g.legend-entry'; svg.select('.legend-group') .selectAll(classToFade) .classed(isFadedClassName, true); svg.select(`[data-item=&quot;${exceptionItemId}&quot;]`) .classed(isFadedClassName, false); } /** * Calculates the margin between elements of the legend * @return {Number} Margin to apply between elements * @private */ function getLineElementMargin() { return marginRatio * markerSize; } /** * Simple method to move the last item of an overflowing legend into the next line * @return {void} * @private */ function splitInLines() { let legendEntries = svg.selectAll('.legend-entry'); let numberOfEntries = legendEntries.size(); let lineHeight = (chartHeight / 2) * 1.7; let newLine = svg.select('.legend-group') .append('g') .classed('legend-line', true) .attr('transform', `translate(0, ${lineHeight})`); let lastEntry = legendEntries.filter(`:nth-child(${numberOfEntries})`); lastEntry.attr('transform', `translate(${markerSize},0)`); newLine.append(() =&gt; lastEntry.node()); } // API /** * Clears all highlighted entries * @public */ exports.clearHighlight = function() { cleanFadedLines(); }; /** * Gets or Sets the colorSchema of the chart * @param {array} _x Color scheme array to get/set * @return {number | module} Current colorSchema or Donut Chart module to chain calls * @public */ exports.colorSchema = function(_x) { if (!arguments.length) { return colorSchema; } colorSchema = _x; return this; }; /** * Gets or Sets the height of the legend chart * @param {number} _x Desired width for the chart * @return {height | module} Current height or Legend module to chain calls * @public */ exports.height = function(_x) { if (!arguments.length) { return height; } height = _x; return this; }; /** * Highlights a line entry by fading the rest of lines * @param {number} entryId ID of the entry line * @public */ exports.highlight = function(entryId) { cleanFadedLines(); fadeLinesBut(entryId); }; /** * Gets or Sets the horizontal mode on the legend * @param {boolean} _x Desired horizontal mode for the graph * @return {ishorizontal | module} If it is horizontal or Legend module to chain calls * @public */ exports.isHorizontal = function(_x) { if (!arguments.length) { return isHorizontal; } isHorizontal = _x; return this; }; /** * Gets or Sets the margin of the legend chart * @param {object} _x Margin object to get/set * @return {margin | module} Current margin or Legend module to chain calls * @public */ exports.margin = function(_x) { if (!arguments.length) { return margin; } margin = _x; return this; }; /** * Gets or Sets the markerSize of the legend chart. * This markerSize will determine the horizontal and vertical size of the colored marks * added as color identifiers for the chart's categories. * * @param {object} _x Margin object to get/set * @return {markerSize | module} Current markerSize or Legend module to chain calls * @public */ exports.markerSize = function(_x) { if (!arguments.length) { return markerSize; } markerSize = _x; return this; }; /** * Gets or Sets the number format of the legend chart * @param {string} _x Desired number format for the legend chart * @return {numberFormat | module} Current number format or Legend module to chain calls * @public */ exports.numberFormat = function(_x) { if (!arguments.length) { return numberFormat; } numberFormat = _x; return this; }; /** * Gets or Sets the width of the legend chart * @param {number} _x Desired width for the graph * @return {width | module} Current width or Legend module to chain calls * @public */ exports.width = function(_x) { if (!arguments.length) { return width; } width = _x; return this; }; return exports; }; }); × Search results Close "},"mini-tooltip.js.html":{"id":"mini-tooltip.js.html","title":"Source: mini-tooltip.js","body":" Getting started Demos Bar Chart Brush Chart Donut Chart Grouped Bar Chart Kitchen Sink Line Chart Sparkline Chart Stacked Area Chart Stacked Bar Chart Step Chart API Bar Brush Donut Grouped-bar Legend Line Mini-tooltip Sparkline Stacked-area Stacked-bar Step Tooltip Types Github Twitter Source: mini-tooltip.js define(function(require){ 'use strict'; const d3Array = require('d3-array'); const d3Ease = require('d3-ease'); const d3Format = require('d3-format'); const d3Selection = require('d3-selection'); const d3Transition = require('d3-transition'); /** * Mini Tooltip Component reusable API class that renders a * simple and configurable tooltip element for Britechart's * bar and step chart. * * @module Mini-tooltip * @tutorial bar * @requires d3 * * @example * var barChart = line(), * miniTooltip = miniTooltip(); * * barChart * .width(500) * .height(300) * .on('customMouseHover', miniTooltip.show) * .on('customMouseMove', miniTooltip.update) * .on('customMouseOut', miniTooltip.hide); * * d3Selection.select('.css-selector') * .datum(dataset) * .call(barChart); * * d3Selection.select('.metadata-group .mini-tooltip-container') * .datum([]) * .call(miniTooltip); * */ return function module() { let margin = { top: 12, right: 12, bottom: 12, left: 12 }, width = 100, height = 100, // Optional Title title = '', // Data Format valueLabel = 'value', nameLabel = 'name', // Animations mouseChaseDuration = 100, ease = d3Ease.easeQuadInOut, // tooltip tooltipBackground, backgroundBorderRadius = 1, tooltipTextContainer, tooltipOffset = { y: 0, x: 20 }, // Fonts textSize = 14, textLineHeight = 1.5, valueTextSize = 27, valueTextLineHeight = 1.18, // Colors bodyFillColor = '#FFFFFF', borderStrokeColor = '#D2D6DF', titleFillColor = '#666a73', nameTextFillColor = '#666a73', valueTextFillColor = '#45494E', valueTextWeight = 200, // formats tooltipValueFormat = d3Format.format('.2f'), chartWidth, chartHeight, svg; /** * This function creates the graph using the selection as container * @param {D3Selection} _selection A d3 selection that represents * the container(s) where the chart(s) will be rendered */ function exports(_selection) { _selection.each(function(){ chartWidth = width - margin.left - margin.right; chartHeight = height - margin.top - margin.bottom; buildSVG(this); drawTooltip(); }); } /** * Builds containers for the tooltip * Also applies the Margin convention * @private */ function buildContainerGroups() { let container = svg .append('g') .classed('tooltip-container-group', true) .attr('transform', `translate( ${margin.left}, ${margin.top})`); container.append('g').classed('tooltip-group', true); } /** * Builds the SVG element that will contain the chart * @param {HTMLElement} container DOM element that will work as the container of the graph * @private */ function buildSVG(container) { if (!svg) { svg = d3Selection.select(container) .append('g') .classed('britechart britechart-mini-tooltip', true); buildContainerGroups(); } svg .transition() .attr('width', width) .attr('height', height); // Hidden by default exports.hide(); } /** * Draws the different elements of the Tooltip box * @return void */ function drawTooltip(){ tooltipTextContainer = svg.selectAll('.tooltip-group') .append('g') .classed('tooltip-text', true); tooltipBackground = tooltipTextContainer .append('rect') .classed('tooltip-background', true) .attr('width', width) .attr('height', height) .attr('rx', backgroundBorderRadius) .attr('ry', backgroundBorderRadius) .attr('y', - margin.top) .attr('x', - margin.left) .style('fill', bodyFillColor) .style('stroke', borderStrokeColor) .style('stroke-width', 1) .style('pointer-events', 'none') .style('opacity', 0.9); } /** * Figures out the max length of the tooltip lines * @param {D3Selection[]} texts List of svg elements of each line * @return {Number} Max size of the lines */ function getMaxLengthLine(...texts) { let textSizes = texts.filter(x =&gt; !!x) .map(x =&gt; x.node().getBBox().width); return d3Array.max(textSizes); } /** * Calculates the desired position for the tooltip * @param {Number} mouseX Current horizontal mouse position * @param {Number} mouseY Current vertical mouse position * @param {Number} parentChartWidth Parent's chart width * @param {Number} parentChartHeight Parent's chart height * @return {Number[]} X and Y position * @private */ function getTooltipPosition([mouseX, mouseY], [parentChartWidth, parentChartHeight]) { let tooltipX, tooltipY; if (hasEnoughHorizontalRoom(parentChartWidth, mouseX)) { tooltipX = mouseX + tooltipOffset.x; } else { tooltipX = mouseX - chartWidth - tooltipOffset.x - margin.right; } if (hasEnoughVerticalRoom(parentChartHeight, mouseY)) { tooltipY = mouseY + tooltipOffset.y; } else { tooltipY = mouseY - chartHeight - tooltipOffset.y - margin.bottom; } return [tooltipX, tooltipY]; } /** * Checks if the mouse is over the bounds of the parent chart * @param {Number} chartWidth Parent's chart * @param {Number} positionX Mouse position * @return {Boolean} If the mouse position allows space for the tooltip */ function hasEnoughHorizontalRoom(parentChartWidth, positionX) { return (parentChartWidth - margin.left - margin.right - chartWidth) - positionX &gt; 0; } /** * Checks if the mouse is over the bounds of the parent chart * @param {Number} chartWidth Parent's chart * @param {Number} positionX Mouse position * @return {Boolean} If the mouse position allows space for the tooltip */ function hasEnoughVerticalRoom(parentChartHeight, positionY) { return (parentChartHeight - margin.top - margin.bottom - chartHeight) - positionY &gt; 0; } /** * Hides the tooltip * @return {void} */ function hideTooltip() { svg.style('display', 'none'); } /** * Shows the tooltip updating it's content * @param {Object} dataPoint Data point from the chart * @return {void} */ function showTooltip(dataPoint) { updateContent(dataPoint); svg.style('display', 'block'); } /** * Draws the data entries inside the tooltip for a given topic * @param {Object} topic Topic to extract data from * @return void */ function updateContent(dataPoint = {}){ let value = dataPoint[valueLabel] || '', name = dataPoint[nameLabel] || '', lineHeight = textSize * textLineHeight, valueLineHeight = valueTextSize * valueTextLineHeight, defaultDy = '1em', temporalHeight = 0, tooltipValue, tooltipName, tooltipTitle; tooltipTextContainer.selectAll('text') .remove(); if (title) { tooltipTitle = tooltipTextContainer .append('text') .classed('mini-tooltip-title', true) .attr('dy', defaultDy) .attr('y', 0) .style('fill', titleFillColor) .style('font-size', textSize) .text(title); temporalHeight = lineHeight + temporalHeight; } if (name) { tooltipName = tooltipTextContainer .append('text') .classed('mini-tooltip-name', true) .attr('dy', defaultDy) .attr('y', temporalHeight || 0) .style('fill', nameTextFillColor) .style('font-size', textSize) .text(name); temporalHeight = lineHeight + temporalHeight; } if (value) { tooltipValue = tooltipTextContainer .append('text') .classed('mini-tooltip-value', true) .attr('dy', defaultDy) .attr('y', temporalHeight || 0) .style('fill', valueTextFillColor) .style('font-size', valueTextSize) .style('font-weight', valueTextWeight) .text(tooltipValueFormat(value)); temporalHeight = valueLineHeight + temporalHeight; } chartWidth = getMaxLengthLine(tooltipName, tooltipTitle, tooltipValue); chartHeight = temporalHeight; } /** * Updates size and position of tooltip depending on the side of the chart we are in * @param {Object} dataPoint DataPoint of the tooltip * @return void */ function updatePositionAndSize(mousePosition, parentChartSize) { let [tooltipX, tooltipY] = getTooltipPosition(mousePosition, parentChartSize); svg.transition() .duration(mouseChaseDuration) .ease(ease) .attr('height', chartHeight + margin.top + margin.bottom) .attr('width', chartWidth + margin.left + margin.right) .attr('transform', `translate(${tooltipX},${tooltipY})`); tooltipBackground .attr('height', chartHeight + margin.top + margin.bottom) .attr('width', chartWidth + margin.left + margin.right); } /** * Updates tooltip content, size and position * * @param {Object} dataPoint Current datapoint to show info about * @return void */ function updateTooltip(dataPoint, position, chartSize) { updateContent(dataPoint); updatePositionAndSize(position, chartSize); } /** * Hides the tooltip * @return {Module} Tooltip module to chain calls * @public */ exports.hide = function() { hideTooltip(); return this; }; /** * Gets or Sets data's nameLabel * @param {text} _x Desired nameLabel * @return { text | module} nameLabel or Step Chart module to chain calls * @public */ exports.nameLabel = function(_x) { if (!arguments.length) { return nameLabel; } nameLabel = _x; return this; }; /** * Shows the tooltip * @return {Module} Tooltip module to chain calls * @public */ exports.show = function() { showTooltip(); return this; }; /** * Gets or Sets the title of the tooltip * @param {string} _x Desired title * @return { string | module} Current title or module to chain calls * @public */ exports.title = function(_x) { if (!arguments.length) { return title; } title = _x; return this; }; /** * Updates the position and content of the tooltip * @param {Object} dataPoint Datapoint of the hovered element * @param {Array} mousePosition Mouse position relative to the parent chart [x, y] * @param {Array} chartSize Parent chart size [x, y] * @return {module} Current component */ exports.update = function(dataPoint, mousePosition, chartSize) { updateTooltip(dataPoint, mousePosition, chartSize); return this; }; return exports; }; }); × Search results Close "},"sparkline.js.html":{"id":"sparkline.js.html","title":"Source: sparkline.js","body":" Getting started Demos Bar Chart Brush Chart Donut Chart Grouped Bar Chart Kitchen Sink Line Chart Sparkline Chart Stacked Area Chart Stacked Bar Chart Step Chart API Bar Brush Donut Grouped-bar Legend Line Mini-tooltip Sparkline Stacked-area Stacked-bar Step Tooltip Types Github Twitter Source: sparkline.js define(function(require){ 'use strict'; const d3Array = require('d3-array'); const d3Ease = require('d3-ease'); const d3Scale = require('d3-scale'); const d3Shape = require('d3-shape'); const d3Selection = require('d3-selection'); const d3Transition = require('d3-transition'); const {exportChart} = require('./helpers/exportChart'); const colorHelper = require('./helpers/colors'); /** * @typedef SparklineChartData * @type {Object[]} * @property {Number} value Value of the group (required) * @property {String} name Name of the group (required) * * @example * [ * { * value: 1, * date: '2011-01-06T00:00:00Z' * }, * { * value: 2, * date: '2011-01-07T00:00:00Z' * } */ /** * Sparkline Chart reusable API module that allows us * rendering a sparkline configurable chart. * * @module Sparkline * @tutorial sparkline * @requires d3 * * @example * var sparkLineChart = sparkline(); * * sparkLineChart * .width(200) * .height(100); * * d3Selection.select('.css-selector') * .datum(dataset) * .call(sparkLineChart); * */ return function module(){ let margin = { left: 5, right: 5, top: 5, bottom: 5 }, width = 100, height = 30, xScale, yScale, areaGradient = ['#F5FDFF', '#F6FEFC'], areaGradientEl, lineGradient = colorHelper.colorGradients.greenBlue, lineGradientEl, maskingClip, svg, chartWidth, chartHeight, data, hasArea = true, isAnimated = false, clipDuration = 3000, ease = d3Ease.easeQuadInOut, line, area, circle, markerSize = 1.5, valueLabel = 'value', dateLabel = 'date', // getters getDate = ({date}) =&gt; date, getValue = ({value}) =&gt; value; /** * This function creates the graph using the selection and data provided * * @param {D3Selection} _selection A d3 selection that represents * the container(s) where the chart(s) will be rendered * @param {SparklineChartData} _data The data to attach and generate the chart */ function exports(_selection) { _selection.each(function(_data){ chartWidth = width - margin.left - margin.right; chartHeight = height - margin.top - margin.bottom; data = cleanData(_data); buildScales(); buildSVG(this); createGradients(); createMaskingClip(); drawLine(); drawArea(); drawEndMarker(); }); } /** * Builds containers for the chart, the axis and a wrapper for all of them * NOTE: The order of drawing of this group elements is really important, * as everything else will be drawn on top of them * @private */ function buildContainerGroups(){ let container = svg .append('g') .classed('container-group', true) .attr('transform', `translate(${margin.left},${margin.top})`); container .append('g').classed('chart-group', true); container .append('g').classed('metadata-group', true); } /** * Creates the x, y and color scales of the chart * @private */ function buildScales(){ xScale = d3Scale.scaleLinear() .domain(d3Array.extent(data, getDate)) .range([0, chartWidth]); yScale = d3Scale.scaleLinear() .domain(d3Array.extent(data, getValue)) .range([chartHeight, 0]); } /** * Builds the SVG element that will contain the chart * @param {HTMLElement} container DOM element that will work as the container of the graph * @private */ function buildSVG(container){ if (!svg) { svg = d3Selection.select(container) .append('svg') .classed('britechart sparkline', true); buildContainerGroups(); } svg .attr('width', width) .attr('height', height); } /** * Cleaning data casting the values and dates to the proper type while keeping * the rest of properties on the data * @param {SparklineChartData} originalData Raw data from the container * @return {SparklineChartData} Clean data * @private */ function cleanData(originalData) { return originalData.reduce((acc, d) =&gt; { d.date = new Date(d[dateLabel]); d.value = +d[valueLabel]; return [...acc, d]; }, []); } /** * Creates the gradient on the area below the line * @return {void} */ function createGradients() { let metadataGroup = svg.select('.metadata-group'); if (areaGradientEl || lineGradientEl) { svg.selectAll('#sparkline-area-gradient').remove(); svg.selectAll('#sparkline-line-gradient').remove(); } areaGradientEl = metadataGroup.append('linearGradient') .attr('id', 'sparkline-area-gradient') .attr('gradientUnits', 'userSpaceOnUse') .attr('x1', 0) .attr('x2', xScale(data[data.length - 1].date)) .attr('y1', 0) .attr('y2', 0) .selectAll('stop') .data([ {offset: '0%', color: areaGradient[0]}, {offset: '100%', color: areaGradient[1]} ]) .enter().append('stop') .attr('offset', ({offset}) =&gt; offset) .attr('stop-color', ({color}) =&gt; color); lineGradientEl = metadataGroup.append('linearGradient') .attr('id', 'sparkline-line-gradient') .attr('gradientUnits', 'userSpaceOnUse') .attr('x1', 0) .attr('x2', xScale(data[data.length - 1].date)) .attr('y1', 0) .attr('y2', 0) .selectAll('stop') .data([ {offset: '0%', color: lineGradient[0]}, {offset: '100%', color: lineGradient[1]} ]) .enter().append('stop') .attr('offset', ({offset}) =&gt; offset) .attr('stop-color', ({color}) =&gt; color); } /** * Creates a masking clip that would help us fake an animation if the * proper flag is true * * @return {void} */ function createMaskingClip() { if (maskingClip) { svg.selectAll('#maskingClip').remove(); } if (isAnimated) { maskingClip = svg.select('.metadata-group') .append('clipPath') .attr('id', 'maskingClip') .append('rect') .attr('width', 0) .attr('height', height); d3Selection.select('#maskingClip rect') .transition() .ease(ease) .duration(clipDuration) .attr('width', width); } } /** * Draws the area that will be placed below the line * @private */ function drawArea(){ if (area) { svg.selectAll('.sparkline-area').remove(); } area = d3Shape.area() .x(({date}) =&gt; xScale(date)) .y0(() =&gt; yScale(0)) .y1(({value}) =&gt; yScale(value)) .curve(d3Shape.curveBasis); svg.select('.chart-group') .append('path') .datum(data) .attr('class', 'sparkline-area') .attr('d', area) .attr('clip-path', 'url(#maskingClip)'); } /** * Draws the line element within the chart group * @private */ function drawLine(){ if (line) { svg.selectAll('.line').remove(); } line = d3Shape.line() .curve(d3Shape.curveBasis) .x(({date}) =&gt; xScale(date)) .y(({value}) =&gt; yScale(value)); svg.select('.chart-group') .append('path') .datum(data) .attr('class', 'line') .attr('d', line) .attr('clip-path', 'url(#maskingClip)'); } /** * Draws a marker at the end of the sparkline */ function drawEndMarker(){ if (circle) { svg.selectAll('.sparkline-circle').remove(); } circle = svg.selectAll('.chart-group') .append('circle') .attr('class', 'sparkline-circle') .attr('cx', xScale(data[data.length - 1].date)) .attr('cy', yScale(data[data.length - 1].value)) .attr('r', markerSize); } // API /** * Gets or Sets the areaGradient of the chart * @param {String[]} _x Desired areaGradient for the graph * @return { areaGradient | module} Current areaGradient or Chart module to chain calls * @public */ exports.areaGradient = function(_x) { if (!arguments.length) { return areaGradient; } areaGradient = _x; return this; }; /** * Gets or Sets the dateLabel of the chart * @param {Number} _x Desired dateLabel for the graph * @return { dateLabel | module} Current dateLabel or Chart module to chain calls * @public */ exports.dateLabel = function(_x) { if (!arguments.length) { return dateLabel; } dateLabel = _x; return this; }; /** * Gets or Sets the duration of the animation * @param {Number} _x Desired animation duration for the graph * @return { dateLabel | module} Current animation duration or Chart module to chain calls * @public */ exports.duration = function(_x) { if (!arguments.length) { return clipDuration; } clipDuration = _x; return this; }; /** * Chart exported to png and a download action is fired * @param {String} filename File title for the resulting picture * @param {String} title Title to add at the top of the exported picture * @public */ exports.exportChart = function(filename, title) { exportChart.call(exports, svg, filename, title); }; /** * Gets or Sets the height of the chart * @param {Number} _x Desired width for the graph * @return { height | module} Current height or Chart module to chain calls * @public */ exports.height = function(_x) { if (!arguments.length) { return height; } height = _x; return this; }; /** * Gets or Sets the isAnimated property of the chart, making it to animate when render. * By default this is 'false' * * @param {Boolean} _x Desired animation flag * @return { isAnimated | module} Current isAnimated flag or Chart module * @public */ exports.isAnimated = function(_x) { if (!arguments.length) { return isAnimated; } isAnimated = _x; return this; }; /** * Gets or Sets the lineGradient of the chart * @param {String[]} _x Desired lineGradient for the graph * @return { lineGradient | module} Current lineGradient or Chart module to chain calls * @public */ exports.lineGradient = function(_x) { if (!arguments.length) { return lineGradient; } lineGradient = _x; return this; }; /** * Gets or Sets the margin of the chart * @param {Object} _x Margin object to get/set * @return { margin | module} Current margin or Chart module to chain calls * @public */ exports.margin = function(_x) { if (!arguments.length) { return margin; } margin = _x; return this; }; /** * Gets or Sets the valueLabel of the chart * @param {Number} _x Desired valueLabel for the graph * @return { valueLabel | module} Current valueLabel or Chart module to chain calls * @public */ exports.valueLabel = function(_x) { if (!arguments.length) { return valueLabel; } valueLabel = _x; return this; }; /** * Gets or Sets the width of the chart * @param {Number} _x Desired width for the graph * @return { width | module} Current width or Chart module to chain calls * @public */ exports.width = function(_x) { if (!arguments.length) { return width; } width = _x; return this; }; return exports; }; }); × Search results Close "},"stacked-bar.js.html":{"id":"stacked-bar.js.html","title":"Source: stacked-bar.js","body":" Getting started Demos Bar Chart Brush Chart Donut Chart Grouped Bar Chart Kitchen Sink Line Chart Sparkline Chart Stacked Area Chart Stacked Bar Chart Step Chart API Bar Brush Donut Grouped-bar Legend Line Mini-tooltip Sparkline Stacked-area Stacked-bar Step Tooltip Types Github Twitter Source: stacked-bar.js define(function(require){ 'use strict'; const d3Array = require('d3-array'); const d3Axis = require('d3-axis'); const d3Color = require('d3-color'); const d3Collection = require('d3-collection'); const d3Dispatch = require('d3-dispatch'); const d3Ease = require('d3-ease'); const d3Interpolate = require('d3-interpolate'); const d3Scale = require('d3-scale'); const d3Shape = require('d3-shape'); const d3Selection = require('d3-selection'); const assign = require('lodash.assign'); const d3Transition = require('d3-transition'); const {exportChart} = require('./helpers/exportChart'); const colorHelper = require('./helpers/colors'); const NUMBER_FORMAT = ',f'; const uniq = (arrArg) =&gt; arrArg.filter((elem, pos, arr) =&gt; arr.indexOf(elem) == pos); /** * @typdef D3Layout * @type function */ /** * @typedef stackedBarData * @type {Object} * @property {Object[]} data All data entries * @property {String} name Name of the entry * @property {String} stack Stack of the entry * @property {Number} value Value of the entry * * @example * { * 'data': [ * { * &quot;name&quot;: &quot;2011-01&quot;, * &quot;stack&quot;: &quot;Direct&quot;, * &quot;value&quot;: 0 * } * ] * } */ /** * Stacked Area Chart reusable API module that allows us * rendering a multi area and configurable chart. * * @module Stacked-bar * @tutorial stacked-bar * @requires d3-array, d3-axis, d3-color, d3-collection, d3-dispatch, d3-ease, * d3-interpolate, d3-scale, d3-shape, d3-selection, lodash assign * * @example * let stackedBar = stackedBar(); * * stackedBar * .width(containerWidth); * * d3Selection.select('.css-selector') * .datum(dataset.data) * .call(stackedBar); * */ return function module() { let margin = { top: 40, right: 30, bottom: 60, left: 70 }, width = 960, height = 500, xScale, xAxis, yScale, yAxis, aspectRatio = null, yTickTextYOffset = -8, yTickTextXOffset = -20, locale, yTicks = 5, xTicks = 5, percentageAxisToMaxRatio = 1, colorSchema = colorHelper.colorSchemas.britecharts, colorScale, categoryColorMap, layers, ease = d3Ease.easeQuadInOut, isHorizontal = false, svg, chartWidth, chartHeight, data, transformedData, stacks, layerElements, tooltipThreshold = 480, baseLine, xAxisPadding = { top: 0, left: 0, bottom: 0, right: 0 }, maxBarNumber = 8, barOpacity = 0.24, animationDelayStep = 20, animationDelays = d3Array.range(animationDelayStep, maxBarNumber* animationDelayStep, animationDelayStep), animationDuration = 1000, grid = null, nameLabel = 'name', valueLabel = 'value', stackLabel = 'stack', nameLabelFormat, valueLabelFormat = NUMBER_FORMAT, // getters getName = (data) =&gt; data[nameLabel], getValue = (data) =&gt; data[valueLabel], getStack = (data) =&gt; data[stackLabel], isAnimated = false, // events dispatcher = d3Dispatch.dispatch('customMouseOver', 'customMouseOut', 'customMouseMove'); /** * This function creates the graph using the selection and data provided * @param {D3Selection} _selection A d3 selection that represents * the container(s) where the chart(s) will be rendered * @param {stackedBarData} _data The data to attach and generate the chart */ function exports(_selection) { _selection.each(function(_data){ chartWidth = width - margin.left - margin.right; chartHeight = height - margin.top - margin.bottom; data = cleanData(_data); prepareData(data); buildScales(); buildLayers(); buildSVG(this); drawGridLines(); buildAxis(); drawAxis(); drawStackedBar(); addMouseEvents(); }); } /** * Adds events to the container group if the environment is not mobile * Adding: mouseover, mouseout and mousemove */ function addMouseEvents() { if (shouldShowTooltip()){ svg .on('mouseover', function(d) { handleMouseOver(this, d); }) .on('mouseout', function(d) { handleMouseOut(this, d); }) .on('mousemove', function(d) { handleMouseMove(this, d); }); } svg.selectAll('.bar') .on('mouseover', handleBarsMouseOver) .on('mouseout', handleBarsMouseOut); } /** * Adjusts the position of the y axis' ticks * @param {D3Selection} selection Y axis group * @return void */ function adjustYTickLabels(selection) { selection.selectAll('.tick text') .attr('transform', `translate(${yTickTextXOffset}, ${yTickTextYOffset})`); } /** * Creates the d3 x and y axis, setting orientations * @private */ function buildAxis() { if (isHorizontal) { xAxis = d3Axis.axisBottom(xScale) .ticks(xTicks, valueLabelFormat); yAxis = d3Axis.axisLeft(yScale) } else { xAxis = d3Axis.axisBottom(xScale) yAxis = d3Axis.axisLeft(yScale) .ticks(yTicks, valueLabelFormat) } } /** * Builds containers for the chart, the axis and a wrapper for all of them * NOTE: The order of drawing of this group elements is really important, * as everything else will be drawn on top of them * @private */ function buildContainerGroups(){ let container = svg .append('g') .classed('container-group', true) .attr('transform', `translate(${margin.left},${margin.top})`); container .append('g').classed('x-axis-group', true) .append('g').classed('x axis', true); container.selectAll('.x-axis-group') .append('g').classed('month-axis', true); container .append('g').classed('y-axis-group axis', true); container .append('g').classed('grid-lines-group', true); container .append('g').classed('chart-group', true); container .append('g').classed('metadata-group', true); } /** * Builds the stacked layers layout * @return {D3Layout} Layout for drawing the chart * @private */ function buildLayers(){ let stack3 = d3Shape.stack().keys(stacks), dataInitial = transformedData.map((item) =&gt; { let ret = {}; stacks.forEach((key) =&gt; { ret[key] = item[key]; }); return assign({}, item, ret); }); layers = stack3(dataInitial); } /** * Creates the x, y and color scales of the chart * @private */ function buildScales() { let yMax = d3Array.max(transformedData.map(function(d){ return d.total; })); if (isHorizontal) { xScale = d3Scale.scaleLinear() .domain([0, yMax]) .rangeRound([0, chartWidth - 1]); // 1 pix for edge tick yScale = d3Scale.scaleBand() .domain(data.map(getName)) .rangeRound([chartHeight, 0]) .padding(0.1); } else { xScale = d3Scale.scaleBand() .domain(data.map(getName)) .rangeRound([0, chartWidth ]) .padding(0.1); yScale = d3Scale.scaleLinear() .domain([0,yMax]) .rangeRound([chartHeight, 0]) .nice(); } colorScale = d3Scale.scaleOrdinal() .range(colorSchema) .domain(data.map(getStack)); categoryColorMap = colorScale .domain(data.map(getName)).domain() .reduce((memo, item) =&gt; { data.forEach(function(v){ if (getName(v) === item){ memo[v.name] = colorScale(v.stack) memo[v.stack] = colorScale(v.stack) memo[v.stack + item] = colorScale(v.stack) } }) return memo; }, {}); } /** * @param {HTMLElement} container DOM element that will work as the container of the graph * @private */ function buildSVG(container) { if (!svg) { svg = d3Selection.select(container) .append('svg') .classed('britechart stacked-bar', true); buildContainerGroups(); } svg .attr('width', width) .attr('height', height); } /** * Cleaning data casting the values, stacks, names and topic names to the proper type while keeping * the rest of properties on the data * @param {stackedBarData} originalData Raw data from the container * @return {stackedBarData} Parsed data with values and dates * @private */ function cleanData(originalData) { return originalData.reduce((acc, d) =&gt; { d.value = +d[valueLabel]; d.stack = d[stackLabel]; d.topicName = getStack(d); // for tooltip d.name = d[nameLabel]; return [...acc, d]; }, []); } /** * Draws the x and y axis on the svg object within their * respective groups * @private */ function drawAxis(){ if (isHorizontal) { svg.select('.x-axis-group .axis.x') .attr('transform', `translate( 0, ${chartHeight} )`) .call(xAxis); svg.select('.y-axis-group.axis') .attr('transform', `translate( ${-xAxisPadding.left}, 0)`) .call(yAxis); } else { svg.select('.x-axis-group .axis.x') .attr('transform', `translate( 0, ${chartHeight} )`) .call(xAxis); svg.select('.y-axis-group.axis') .attr('transform', `translate( ${-xAxisPadding.left}, 0)`) .call(yAxis) .call(adjustYTickLabels); } } /** * Draws grid lines on the background of the chart * @return void */ function drawGridLines() { let scale = isHorizontal ? xScale : yScale; if (grid === 'horizontal' || grid === 'full') { svg.select('.grid-lines-group') .selectAll('line.horizontal-grid-line') .data(scale.ticks(yTicks).slice(1)) .enter() .append('line') .attr('class', 'horizontal-grid-line') .attr('x1', (-xAxisPadding.left + 1 )) .attr('x2', chartWidth) .attr('y1', (d) =&gt; yScale(d)) .attr('y2', (d) =&gt; yScale(d)); } if (grid === 'vertical' || grid === 'full') { svg.select('.grid-lines-group') .selectAll('line.vertical-grid-line') .data(scale.ticks(xTicks).slice(1)) .enter() .append('line') .attr('class', 'vertical-grid-line') .attr('y1', 0) .attr('y2', chartHeight) .attr('x1', (d) =&gt; xScale(d)) .attr('x2', (d) =&gt; xScale(d)); } if (isHorizontal) { drawVerticalExtendedLine(); } else { drawHorizontalExtendedLine(); } } /** * Draws the bars along the x axis * @param {D3Selection} layersSelection Selection of bars * @return {void} */ function drawHorizontalBars(layersSelection) { let layerJoin = layersSelection .data(layers); layerElements = layerJoin .enter() .append('g') .attr('fill', (({key}) =&gt; categoryColorMap[key])) .classed('layer', true); let barJoin = layerElements .selectAll('.bar') .data((d) =&gt; d); // Enter + Update let bars = barJoin .enter() .append('rect') .classed('bar', true) .attr('x', (d) =&gt; xScale(d[0]) ) .attr('y', (d) =&gt; yScale(d.data.key) ) .attr('height', yScale.bandwidth()) .attr('fill', (({data}) =&gt; categoryColorMap[`${data.stack}${data.key}`])); if (isAnimated) { bars.style('opacity', barOpacity) .transition() .delay((_, i) =&gt; animationDelays[i]) .duration(animationDuration) .ease(ease) .tween('attr.width', horizontalBarsTween); } else { bars.attr('width', (d) =&gt; xScale(d[1] - d[0])); } } /** * Draws a vertical line to extend x-axis till the edges * @return {void} */ function drawHorizontalExtendedLine() { baseLine = svg.select('.grid-lines-group') .selectAll('line.extended-x-line') .data([0]) .enter() .append('line') .attr('class', 'extended-x-line') .attr('x1', (xAxisPadding.left)) .attr('x2', chartWidth) .attr('y1', chartHeight) .attr('y2', chartHeight); } /** * Draws the bars along the y axis * @param {D3Selection} layersSelection Selection of bars * @return {void} */ function drawVerticalBars(layersSelection) { let layerJoin = layersSelection .data(layers); layerElements = layerJoin .enter() .append('g') .attr('fill', (({key}) =&gt; categoryColorMap[key])) .classed('layer', true); let barJoin = layerElements .selectAll('.bar') .data((d) =&gt; d); // Enter + Update let bars = barJoin .enter() .append('rect') .classed('bar', true) .attr('x', (d) =&gt; xScale(d.data.key)) .attr('y', (d) =&gt; yScale(d[1])) .attr('width', xScale.bandwidth ) .attr('fill', (({data}) =&gt; categoryColorMap[`${data.stack}${data.key}`])); if (isAnimated) { bars.style('opacity', barOpacity) .transition() .delay((_, i) =&gt; animationDelays[i]) .duration(animationDuration) .ease(ease) .tween('attr.height', verticalBarsTween); } else { bars.attr('height', (d) =&gt; yScale(d[0]) - yScale(d[1])); } } /** * Draws a vertical line to extend y-axis till the edges * @return {void} */ function drawVerticalExtendedLine() { baseLine = svg.select('.grid-lines-group') .selectAll('line.extended-y-line') .data([0]) .enter() .append('line') .attr('class', 'extended-y-line') .attr('y1', (xAxisPadding.bottom)) .attr('y2', chartHeight) .attr('x1', 0) .attr('x2', 0); } /** * Draws the different areas into the chart-group element * @private */ function drawStackedBar(){ // Not ideal, we need to figure out how to call exit for nested elements if (layerElements) { svg.selectAll('.layer').remove(); } let series = svg.select('.chart-group').selectAll('.layer') if (isHorizontal) { drawHorizontalBars(series) } else { drawVerticalBars(series) } // Exit series.exit() .transition() .style('opacity', 0) .remove(); } /** * Extract X position on the chart from a given mouse event * @param {obj} event D3 mouse event * @return {Number} Position on the x axis of the mouse * @private */ function getMousePosition(event) { return d3Selection.mouse(event); } /** * Finds out the data entry that is closer to the given position on pixels * @param {Number} mouseX X position of the mouse * @return {obj} Data entry that is closer to that x axis position */ function getNearestDataPoint(mouseX) { let adjustedMouseX = mouseX - margin.left, dataByValueParsed = transformedData.map((item) =&gt; { item.key = item.key return item; }), epsilon, nearest; epsilon = (xScale(dataByValueParsed[1].key) - xScale(dataByValueParsed[0].key)); nearest = dataByValueParsed.find(({key}) =&gt; Math.abs(xScale(key) - adjustedMouseX) &lt;= epsilon); return nearest; } /** * Finds out the data entry that is closer to the given position on pixels * @param {Number} mouseY Y position of the mouse * @return {obj} Data entry that is closer to that y axis position */ function getNearestDataPoint2(mouseY) { let adjustedMouseY = mouseY - margin.bottom, epsilon = yScale.bandwidth(), nearest; nearest = layers.map(function(stackedArray){ return stackedArray.map(function(d1){ let found = d1.data.values.find((d2) =&gt; Math.abs(adjustedMouseY &gt;= yScale(d2[nameLabel])) &amp;&amp; Math.abs(adjustedMouseY - yScale(d2[nameLabel]) &lt;= epsilon*2) ); return found ? d1.data :undefined; }) }); nearest = d3Array.merge( nearest).filter(function(e){return e}); return nearest.length ? nearest[0] :undefined; } /** * Handles a mouseover event on top of a bar * @return {void} */ function handleBarsMouseOver() { d3Selection.select(this) .attr('fill', () =&gt; d3Color.color(d3Selection.select(this.parentNode).attr('fill')).darker()) } /** * Handles a mouseout event out of a bar * @return {void} */ function handleBarsMouseOut() { d3Selection .select(this).attr('fill', () =&gt; d3Selection.select(this.parentNode).attr('fill')) } /** * MouseMove handler, calculates the nearest dataPoint to the cursor * and updates metadata related to it * @private */ function handleMouseMove(e){ let [mouseX, mouseY] = getMousePosition(e), dataPoint = isHorizontal ? getNearestDataPoint2(mouseY) : getNearestDataPoint(mouseX), x, y; if (dataPoint) { // Move verticalMarker to that datapoint if (isHorizontal) { x = mouseX - margin.left; y = yScale(dataPoint.key) + yScale.bandwidth()/2; } else { x = xScale(dataPoint.key) + margin.left; y = mouseY - margin.bottom; } moveTooltipOriginXY(x,y); // Emit event with xPosition for tooltip or similar feature dispatcher.call('customMouseMove', e, dataPoint, categoryColorMap, x, y); } } /** * MouseOut handler, hides overlay and removes active class on verticalMarkerLine * It also resets the container of the vertical marker * @private */ function handleMouseOut(e, d) { svg.select('.metadata-group').attr('transform', 'translate(9999, 0)'); dispatcher.call('customMouseOut', e, d, d3Selection.mouse(e)); } /** * Mouseover handler, shows overlay and adds active class to verticalMarkerLine * @private */ function handleMouseOver(e, d) { dispatcher.call('customMouseOver', e, d, d3Selection.mouse(e)); } /** * Animation tween of horizontal bars * @param {obj} d data of bar * @return {void} */ function horizontalBarsTween(d) { let node = d3Selection.select(this), i = d3Interpolate.interpolateRound(0, xScale(d[1] - d[0])), j = d3Interpolate.interpolateNumber(0, 1); return function (t) { node.attr('width', i(t)) .style('opacity', j(t)); } } /** * Helper method to update the x position of the vertical marker * @param {obj} dataPoint Data entry to extract info * @return void */ function moveTooltipOriginXY(originXPosition, originYPosition){ svg.select('.metadata-group') .attr('transform', `translate(${originXPosition},${originYPosition})`); } /** * Prepare data for create chart. * @private */ function prepareData(data) { stacks = uniq(data.map(({stack}) =&gt; stack)); transformedData = d3Collection.nest() .key(getName) .rollup(function(values) { let ret = {}; values.forEach((entry) =&gt; { if (entry &amp;&amp; entry[stackLabel]) { ret[entry[stackLabel]] = getValue(entry); } }); ret.values = values; //for tooltip return ret; }) .entries(data) .map(function(data){ return assign({}, { total:d3Array.sum( d3Array.permute(data.value, stacks) ), key:data.key }, data.value); }); } /** * Determines if we should add the tooltip related logic depending on the * size of the chart and the tooltipThreshold variable value * @return {boolean} Should we build the tooltip? * @private */ function shouldShowTooltip() { return width &gt; tooltipThreshold; } /** * Animation tween of vertical bars * @param {obj} d data of bar * @return {void} */ function verticalBarsTween(d) { let node = d3Selection.select(this), i = d3Interpolate.interpolateRound(0, yScale(d[0]) - yScale(d[1])), j = d3Interpolate.interpolateNumber(0,1); return function (t) { node .attr('height', i(t)) .style('opacity', j(t)); } } // API /** * Gets or Sets the aspect ratio of the chart * @param {Number} _x Desired aspect ratio for the graph * @return { (Number | Module) } Current aspect ratio or Area Chart module to chain calls * @public */ exports.aspectRatio = function(_x) { if (!arguments.length) { return aspectRatio; } aspectRatio = _x; return this; }; /** * Gets or Sets the colorSchema of the chart * @param {String[]} _x Desired colorSchema for the graph * @return { colorSchema | module} Current colorSchema or Chart module to chain calls * @public */ exports.colorSchema = function(_x) { if (!arguments.length) { return colorSchema; } colorSchema = _x; return this; }; /** * Chart exported to png and a download action is fired * @param {String} filename File title for the resulting picture * @param {String} title Title to add at the top of the exported picture * @public */ exports.exportChart = function(filename, title) { exportChart.call(exports, svg, filename, title); }; /** * Gets or Sets the grid mode. * * @param {String} _x Desired mode for the grid ('vertical'|'horizontal'|'full') * @return { String | module} Current mode of the grid or Area Chart module to chain calls * @public */ exports.grid = function(_x) { if (!arguments.length) { return grid; } grid = _x; return this; }; /** * Gets or Sets the height of the chart * @param {Number} _x Desired width for the graph * @return { height | module} Current height or Area Chart module to chain calls * @public */ exports.height = function(_x) { if (!arguments.length) { return height; } if (aspectRatio) { width = Math.ceil(_x / aspectRatio); } height = _x; return this; }; /** * Gets or Sets the horizontal direction of the chart * @param {number} _x Desired horizontal direction for the graph * @return { isHorizontal | module} If it is horizontal or Bar Chart module to chain calls * @public */ exports.isHorizontal = function(_x) { if (!arguments.length) { return isHorizontal; } isHorizontal = _x; return this; }; /** * Gets or Sets the isAnimated property of the chart, making it to animate when render. * By default this is 'false' * * @param {Boolean} _x Desired animation flag * @return { isAnimated | module} Current isAnimated flag or Chart module * @public */ exports.isAnimated = function(_x) { if (!arguments.length) { return isAnimated; } isAnimated = _x; return this; }; /** * Pass language tag for the tooltip to localize the date. * Feature uses Intl.DateTimeFormat, for compatability and support, refer to * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DateTimeFormat * @param {String} _x must be a language tag (BCP 47) like 'en-US' or 'fr-FR' * @return { (String|Module) } Current locale or module to chain calls */ exports.locale = function(_x) { if (!arguments.length) { return locale; } locale = _x; return this; }; /** * Gets or Sets the margin of the chart * @param {Object} _x Margin object to get/set * @return { margin | module} Current margin or Area Chart module to chain calls * @public */ exports.margin = function(_x) { if (!arguments.length) { return margin; } margin = _x; return this; }; /** * Gets or Sets the nameLabel of the chart * @param {Number} _x Desired dateLabel for the graph * @return { nameLabel | module} Current nameLabel or Chart module to chain calls * @public */ exports.nameLabel = function(_x) { if (!arguments.length) { return nameLabel; } nameLabel = _x; return this; }; /** * Gets or Sets the valueLabelFormat of the chart * @param {String[]} _x Desired valueLabelFormat for the graph * @return { valueLabelFormat | module} Current valueLabelFormat or Chart module to chain calls * @public */ exports.nameLabelFormat = function(_x) { if (!arguments.length) { return nameLabelFormat; } nameLabelFormat = _x; return this; }; /** * Gets or Sets the number of ticks of the x axis on the chart * (Default is 5) * @param {Number} _x Desired horizontal ticks * @return {Number | module} Current xTicks or Chart module to chain calls * @public */ exports.xTicks = function (_x) { if (!arguments.length) { return xTicks; } xTicks = _x; return this; }; /** * Gets or Sets the number of vertical ticks of the axis on the chart * @param {Number} _x Desired vertical ticks * @return {Number | module} Current yTicks or Chart module to chain calls * @public */ exports.yTicks = function (_x) { if (!arguments.length) { return yTicks; } yTicks = _x; return this; }; /** * Exposes an 'on' method that acts as a bridge with the event dispatcher * We are going to expose this events: * customMouseOver, customMouseMove and customMouseOut * * @return {module} Bar Chart * @public */ exports.on = function() { let value = dispatcher.on.apply(dispatcher, arguments); return value === dispatcher ? exports : value; }; /** * Configurable extension of the x axis * if your max point was 50% you might want to show x axis to 60%, pass 1.2 * @param {number} _x ratio to max data point to add to the x axis * @return { ratio | module} Current ratio or Bar Chart module to chain calls * @public */ exports.percentageAxisToMaxRatio = function(_x) { if (!arguments.length) { return percentageAxisToMaxRatio; } percentageAxisToMaxRatio = _x; return this; }; /** * Gets or Sets the stackLabel of the chart * @param {String} _x Desired stackLabel for the graph * @return { stackLabel | module} Current stackLabel or Chart module to chain calls * @public */ exports.stackLabel = function(_x) { if (!arguments.length) { return stackLabel; } stackLabel = _x; return this; }; /** * Gets or Sets the minimum width of the graph in order to show the tooltip * NOTE: This could also depend on the aspect ratio * * @param {Object} _x Margin object to get/set * @return { tooltipThreshold | module} Current tooltipThreshold or Area Chart module to chain calls * @public */ exports.tooltipThreshold = function(_x) { if (!arguments.length) { return tooltipThreshold; } tooltipThreshold = _x; return this; }; /** * Gets or Sets the valueLabel of the chart * @param {Number} _x Desired valueLabel for the graph * @return { valueLabel | module} Current valueLabel or Chart module to chain calls * @public */ exports.valueLabel = function(_x) { if (!arguments.length) { return valueLabel; } valueLabel = _x; return this; }; /** * Gets or Sets the valueLabelFormat of the chart * @param {String[]} _x Desired valueLabelFormat for the graph * @return { valueLabelFormat | module} Current valueLabelFormat or Chart module to chain calls * @public */ exports.valueLabelFormat = function(_x) { if (!arguments.length) { return valueLabelFormat; } valueLabelFormat = _x; return this; }; /** * Gets or Sets the width of the chart * @param {Number} _x Desired width for the graph * @return { width | module} Current width or Area Chart module to chain calls * @public */ exports.width = function(_x) { if (!arguments.length) { return width; } if (aspectRatio) { height = Math.ceil(_x * aspectRatio); } width = _x; return this; }; return exports; }; }); × Search results Close "},"step.js.html":{"id":"step.js.html","title":"Source: step.js","body":" Getting started Demos Bar Chart Brush Chart Donut Chart Grouped Bar Chart Kitchen Sink Line Chart Sparkline Chart Stacked Area Chart Stacked Bar Chart Step Chart API Bar Brush Donut Grouped-bar Legend Line Mini-tooltip Sparkline Stacked-area Stacked-bar Step Tooltip Types Github Twitter Source: step.js define(function(require) { 'use strict'; const d3Array = require('d3-array'); const d3Axis = require('d3-axis'); const d3Dispatch = require('d3-dispatch'); const d3Ease = require('d3-ease'); const d3Format = require('d3-format'); const d3Scale = require('d3-scale'); const d3Selection = require('d3-selection'); const d3Transition = require('d3-transition'); const {exportChart} = require('./helpers/exportChart'); /** * @typedef StepChartData * @type Object[] * * @property {String} key Key we measure (required) * @property {Number} value value of the key (required) * * @example * [ * { * value: 1, * key: 'glittering' * }, * { * value: 1, * key: 'luminous' * } * ] */ /** * Step Chart reusable API class that renders a * simple and configurable step chart. * * @module Step * @tutorial step * @requires d3-array, d3-axis, d3-dispatch, d3-format, d3-scale, d3-selection, d3-transition * * @example * var stepChart= step(); * * stepChart * .height(500) * .width(800); * * d3Selection.select('.css-selector') * .datum(dataset) * .call(stepChart); * */ return function module() { let margin = { top: 20, right: 20, bottom: 30, left: 40 }, width = 960, height = 500, ease = d3Ease.easeQuadInOut, data, chartWidth, chartHeight, xScale, yScale, yTicks = 6, xAxis, xAxisLabel, xAxisLabelEl, yAxis, yAxisLabel, yAxisLabelEl, xAxisLabelOffset = 80, yAxisLabelOffset = -20, xAxisPadding = { top: 0, left: 0, bottom: 0, right: 0 }, yTickPadding = 8, svg, valueLabel = 'value', nameLabel = 'key', maskGridLines, baseLine, // Dispatcher object to broadcast the mouse events // Ref: https://github.com/mbostock/d3/wiki/Internals#d3_dispatch dispatcher = d3Dispatch.dispatch('customMouseOver', 'customMouseOut', 'customMouseMove'), // Formats yAxisTickFormat = d3Format.format('.3'), // extractors getKey = ({key}) =&gt; key, getValue = ({value}) =&gt; value; /** * This function creates the graph using the selection as container * @param {D3Selection} _selection A d3 selection that represents * the container(s) where the chart(s) will be rendered * @param {StepChartData} _data The data to attach and generate the chart */ function exports(_selection){ _selection.each(function(_data){ // Make space on the left of the graph for the y axis label chartWidth = width - margin.left - margin.right; chartHeight = height - margin.top - margin.bottom; data = cleanData(_data); buildScales(); buildAxis(); buildSVG(this); drawGridLines(); drawSteps(); drawAxis(); }); } /** * Creates the d3 x and y axis, setting orientations * @private */ function buildAxis(){ xAxis = d3Axis.axisBottom(xScale); yAxis = d3Axis.axisLeft(yScale) .ticks(yTicks) .tickPadding(yTickPadding) .tickFormat(yAxisTickFormat); } /** * Builds containers for the chart, the axis and a wrapper for all of them * Also applies the Margin convention * @private */ function buildContainerGroups(){ let container = svg .append('g') .classed('container-group', true) .attr('transform', `translate(${margin.left}, ${margin.top})`); container .append('g') .classed('grid-lines-group', true); container .append('g') .classed('chart-group', true); container .append('g') .classed('x-axis-group axis', true) .append('g') .classed('x-axis-label', true); container .append('g') .classed('y-axis-group axis', true) .append('g') .classed('y-axis-label', true); container .append('g').classed('metadata-group', true); } /** * Creates the x and y scales of the graph * @private */ function buildScales(){ xScale = d3Scale.scaleBand() .domain(data.map(getKey)) .rangeRound([0, chartWidth]) .paddingInner(0); yScale = d3Scale.scaleLinear() .domain([0, d3Array.max(data, getValue)]) .rangeRound([chartHeight, 0]); } /** * Builds the SVG element that will contain the chart * @param {HTMLElement} container DOM element that will work as the container of the graph * @private */ function buildSVG(container){ if (!svg) { svg = d3Selection.select(container) .append('svg') .classed('britechart step-chart', true); buildContainerGroups(); } svg .attr('width', width) .attr('height', height); } /** * Cleaning data casting the values and keys to the proper type while keeping * the rest of properties on the data * @param {StepChartData} originalData Data as provided on the container * @private */ function cleanData(originalData) { return originalData.reduce((acc, d) =&gt; { d.value = +d[valueLabel]; d.key = String(d[nameLabel]); return [...acc, d]; }, []); } /** * Draws the x and y axis on the svg object within their * respective groups * @private */ function drawAxis(){ svg.select('.x-axis-group.axis') .attr('transform', `translate(0, ${chartHeight})`) .call(xAxis); svg.selectAll('.x-axis-group .tick text') .style('text-anchor', 'start') .attr('transform', 'rotate(45 -1 10)'); if (xAxisLabel) { if (xAxisLabelEl) { svg.selectAll('.x-axis-label-text').remove(); } xAxisLabelEl = svg.select('.x-axis-label') .append('text') .attr('y', xAxisLabelOffset) .attr('text-anchor', 'middle') .classed('x-axis-label-text', true) .attr('x', chartWidth / 2) .text(xAxisLabel); } svg.select('.y-axis-group.axis') .call(yAxis); if (yAxisLabel) { if (yAxisLabelEl) { svg.selectAll('.y-axis-label-text').remove(); } yAxisLabelEl = svg.select('.y-axis-label') .append('text') .classed('y-axis-label-text', true) .attr('x', -chartHeight / 2) .attr('y', yAxisLabelOffset) .attr('text-anchor', 'middle') .attr('transform', 'rotate(270 0 0)') .text(yAxisLabel); } } /** * Draws the step elements within the chart group * @private */ function drawSteps(){ let steps = svg.select('.chart-group').selectAll('.step').data(data); // Enter steps.enter() .append('rect') .classed('step', true) .attr('x', chartWidth) // Initially drawing the steps at the end of Y axis .attr('y', ({value}) =&gt; yScale(value)) .attr('width', xScale.bandwidth()) .attr('height', (d) =&gt; (chartHeight - yScale(d.value))) .on('mouseover', function(d) { handleMouseOver(this, d, chartWidth, chartHeight); }) .on('mousemove', function(d) { handleMouseMove(this, d, chartWidth, chartHeight); }) .on('mouseout', function(d) { handleMouseOut(this, d, chartWidth, chartHeight); }) .merge(steps) .transition() .ease(ease) .attr('x', ({key}) =&gt; xScale(key)) .attr('y', function(d) { return yScale(d.value); }) .attr('width', xScale.bandwidth()) .attr('height', function(d) { return chartHeight - yScale(d.value); }); // Exit steps.exit() .transition() .style('opacity', 0) .remove(); } /** * Draws grid lines on the background of the chart * @return void */ function drawGridLines(){ if (maskGridLines) { svg.selectAll('.horizontal-grid-line').remove(); } if (baseLine) { svg.selectAll('.extended-x-line').remove(); } maskGridLines = svg.select('.grid-lines-group') .selectAll('line.horizontal-grid-line') .data(yScale.ticks(yTicks)) .enter() .append('line') .attr('class', 'horizontal-grid-line') .attr('x1', (xAxisPadding.left)) .attr('x2', chartWidth) .attr('y1', (d) =&gt; yScale(d)) .attr('y2', (d) =&gt; yScale(d)); if (baseLine) { svg.selectAll('.extended-x-line').remove(); } //draw a horizontal line to extend x-axis till the edges baseLine = svg.select('.grid-lines-group') .selectAll('line.extended-x-line') .data([0]) .enter() .append('line') .attr('class', 'extended-x-line') .attr('x1', (xAxisPadding.left)) .attr('x2', chartWidth) .attr('y1', chartHeight) .attr('y2', chartHeight); } // API /** * Custom OnMouseOver event handler * @return {void} * @private */ function handleMouseOver(e, d, chartWidth, chartHeight) { dispatcher.call('customMouseOver', e, d, d3Selection.mouse(e), [chartWidth, chartHeight]); } /** * Custom OnMouseMove event handler * @return {void} * @private */ function handleMouseMove(e, d, chartWidth, chartHeight) { dispatcher.call('customMouseMove', e, d, d3Selection.mouse(e), [chartWidth, chartHeight]); } /** * Custom OnMouseOver event handler * @return {void} * @private */ function handleMouseOut(e, d, chartWidth, chartHeight) { dispatcher.call('customMouseOut', e, d, d3Selection.mouse(e), [chartWidth, chartHeight]); } /** * Chart exported to png and a download action is fired * @param {String} filename File title for the resulting picture * @param {String} title Title to add at the top of the exported picture * @public */ exports.exportChart = function(filename) { exportChart.call(exports, svg, filename); }; /** * Gets or Sets the margin of the chart * @param {object} _x Margin object to get/set * @return { margin | module} Current margin or Chart module to chain calls * @public */ exports.margin = function(_x) { if (!arguments.length) { return margin; } margin = _x; return this; }; /** * Gets or Sets the number of vertical ticks on the chart * (Default is 6) * @param {Number} _x Desired number of vertical ticks for the graph * @return {Number | module} Current yTicks or Chart module to chain calls * @public */ exports.yTicks = function(_x) { if (!arguments.length) { return yTicks; } yTicks = _x; return this; }; /** * Gets or Sets the height of the chart * @param {number} _x Desired width for the graph * @return { height | module} Current height or Chart module to chain calls * @public */ exports.height = function(_x) { if (!arguments.length) { return height; } height = _x; return this; }; /** * Exposes an 'on' method that acts as a bridge with the event dispatcher * We are going to expose this events: * customMouseOver, customMouseMove and customMouseOut * * @return {module} Bar Chart * @public */ exports.on = function(...args) { let value = dispatcher.on(...args); return value === dispatcher ? exports : value; }; /** * Gets or Sets the width of the chart * @param {number} _x Desired width for the graph * @return { width | module} Current width or Chart module to chain calls * @public */ exports.width = function(_x) { if (!arguments.length) { return width; } width = _x; return this; }; /** * Gets or Sets the text of the xAxisLabel on the chart * @param {text} _x Desired text for the label * @return { text | module} label or Chart module to chain calls * @public */ exports.xAxisLabel = function(_x) { if (!arguments.length) { return xAxisLabel; } xAxisLabel = _x; return this; }; /** * Gets or Sets the offset of the xAxisLabel on the chart * @param {integer} _x Desired offset for the label * @return { integer | module} label or Chart module to chain calls * @public */ exports.xAxisLabelOffset = function(_x) { if (!arguments.length) { return xAxisLabelOffset; } xAxisLabelOffset = _x; return this; }; /** * Gets or Sets the text of the yAxisLabel on the chart * @param {text} _x Desired text for the label * @return { text | module} label or Chart module to chain calls * @public */ exports.yAxisLabel = function(_x) { if (!arguments.length) { return yAxisLabel; } yAxisLabel = _x; return this; }; /** * Gets or Sets the offset of the yAxisLabel on the chart * @param {integer} _x Desired offset for the label * @return { integer | module} label or Chart module to chain calls * @public */ exports.yAxisLabelOffset = function(_x) { if (!arguments.length) { return yAxisLabelOffset; } yAxisLabelOffset = _x; return this; }; return exports; }; }); × Search results Close "},"tooltip.js.html":{"id":"tooltip.js.html","title":"Source: tooltip.js","body":" Getting started Demos Bar Chart Brush Chart Donut Chart Grouped Bar Chart Kitchen Sink Line Chart Sparkline Chart Stacked Area Chart Stacked Bar Chart Step Chart API Bar Brush Donut Grouped-bar Legend Line Mini-tooltip Sparkline Stacked-area Stacked-bar Step Tooltip Types Github Twitter Source: tooltip.js define(function(require){ 'use strict'; const d3Ease = require('d3-ease'); const d3Format = require('d3-format'); const d3Selection = require('d3-selection'); const d3Transition = require('d3-transition'); const d3TimeFormat = require('d3-time-format'); const { axisTimeCombinations } = require('./helpers/constants'); const { formatIntegerValue, formatDecimalValue } = require('./helpers/formatHelpers'); const { isInteger } = require('./helpers/common'); /** * Tooltip Component reusable API class that renders a * simple and configurable tooltip element for Britechart's * line chart or stacked area chart. * * @module Tooltip * @tutorial tooltip * @requires d3-array, d3-axis, d3-dispatch, d3-format, d3-scale, d3-selection, d3-transition * * @example * var lineChart = line(), * tooltip = tooltip(); * * tooltip * .title('Tooltip title'); * * lineChart * .width(500) * .on('customMouseOver', function() { * tooltip.show(); * }) * .on('customMouseMove', function(dataPoint, topicColorMap, dataPointXPosition) { * tooltip.update(dataPoint, topicColorMap, dataPointXPosition); * }) * .on('customMouseOut', function() { * tooltip.hide(); * }); * * d3Selection.select('.css-selector') * .datum(dataset) * .call(lineChart); * * d3Selection.select('.metadata-group .hover-marker') * .datum([]) * .call(tooltip); * */ return function module() { let margin = { top: 2, right: 2, bottom: 2, left: 2 }, width = 250, height = 45, title = 'Tooltip title', shouldShowDateInTitle = true, valueFormat = null, // tooltip tooltip, tooltipOffset = { y: -55, x: 0 }, tooltipMaxTopicLength = 170, tooltipTextContainer, tooltipDivider, tooltipBody, tooltipTitle, tooltipWidth = 250, tooltipHeight = 48, tooltipBorderRadius = 3, ttTextX = 0, ttTextY = 37, textSize, entryLineLimit = 3, // Animations mouseChaseDuration = 100, ease = d3Ease.easeQuadInOut, circleYOffset = 8, colorMap, bodyFillColor = '#FFFFFF', borderStrokeColor = '#D2D6DF', titleFillColor = '#6D717A', textFillColor = '#282C35', tooltipTextColor = '#000000', dateLabel = 'date', valueLabel = 'value', nameLabel = 'name', topicLabel = 'topics', defaultAxisSettings = axisTimeCombinations.DAY_MONTH, dateFormat = null, topicsOrder = [], // formats monthDayYearFormat = d3TimeFormat.timeFormat('%b %d, %Y'), monthDayHourFormat = d3TimeFormat.timeFormat('%b %d, %I %p'), locale, chartWidth, chartHeight, data, svg; /** * This function creates the graph using the selection as container * @param {D3Selection} _selection A d3 selection that represents * the container(s) where the chart(s) will be rendered * @param {Object} _data The data to attach and generate the chart */ function exports(_selection) { _selection.each(function(_data){ chartWidth = width - margin.left - margin.right; chartHeight = height - margin.top - margin.bottom; data = _data; buildSVG(this); }); } /** * Builds containers for the tooltip * Also applies the Margin convention * @private */ function buildContainerGroups() { var container = svg.append('g') .classed('tooltip-container-group', true) .attr('transform', `translate( ${margin.left}, ${margin.top})`); container.append('g').classed('tooltip-group', true); } /** * Builds the SVG element that will contain the chart * @param {HTMLElement} container DOM element that will work as the container of the graph * @private */ function buildSVG(container) { if (!svg) { svg = d3Selection.select(container) .append('g') .classed('britechart britechart-tooltip', true) .style('display', 'none'); buildContainerGroups(); drawTooltip(); } svg .transition() .attr('width', width) .attr('height', height); // Hidden by default exports.hide(); } /** * Resets the tooltipBody content * @return void */ function cleanContent(){ tooltipBody.selectAll('text').remove(); tooltipBody.selectAll('circle').remove(); } /** * Draws the different elements of the Tooltip box * @return void */ function drawTooltip(){ tooltipTextContainer = svg.selectAll('.tooltip-group') .append('g') .classed('tooltip-text', true); tooltip = tooltipTextContainer .append('rect') .classed('tooltip-text-container', true) .attr('x', -tooltipWidth / 4 + 8) .attr('y', 0) .attr('width', tooltipWidth) .attr('height', tooltipHeight) .attr('rx', tooltipBorderRadius) .attr('ry', tooltipBorderRadius) .style('fill', bodyFillColor) .style('stroke', borderStrokeColor) .style('stroke-width', 1); tooltipTitle = tooltipTextContainer .append('text') .classed('tooltip-title', true) .attr('x', -tooltipWidth / 4 + 16) .attr('dy', '.35em') .attr('y', 16) .style('fill', titleFillColor); tooltipDivider = tooltipTextContainer .append('line') .classed('tooltip-divider', true) .attr('x1', -tooltipWidth / 4 + 16) .attr('x2', 265) .attr('y1', 31) .attr('y2', 31) .style('stroke', borderStrokeColor); tooltipBody = tooltipTextContainer .append('g') .classed('tooltip-body', true) .style('transform', 'translateY(8px)') .style('fill', textFillColor); } /** * Formats the value depending on its characteristics * @param {Number} value Value to format * @return {Number} Formatted value */ function getFormattedValue(value) { let valueFormatter = formatDecimalValue; if (!value) { return 0; } if (valueFormat) { valueFormatter = d3Format.format(valueFormat); } else if (isInteger(value)) { valueFormatter = formatIntegerValue; } return valueFormatter(value); } /** * Calculates the desired position for the tooltip * @param {Number} mouseX Current horizontal mouse position * @param {Number} mouseY Current vertical mouse position * @return {Number[]} X and Y position */ function getTooltipPosition([mouseX, mouseY]) { let tooltipX, tooltipY; // show tooltip to the right if ((mouseX - tooltipWidth) &lt; 0) { // Tooltip on the right tooltipX = tooltipWidth - 185; } else { // Tooltip on the left tooltipX = -205 } if (mouseY) { tooltipY = tooltipOffset.y; // tooltipY = mouseY + tooltipOffset.y; } else { tooltipY = tooltipOffset.y; } return [tooltipX, tooltipY]; } /** * Extracts the value from the data object * @param {Object} data Data value containing the info * @return {String} Value to show */ function getValueText(data) { let value = data[valueLabel]; let valueText; if (data.missingValue) { valueText = '-'; } else { valueText = getFormattedValue(value).toString(); } return valueText; } /** * Resets the height of the tooltip and the pointer for the text * position */ function resetSizeAndPositionPointers() { tooltipHeight = 48; ttTextY = 37; ttTextX = 0; } /** * Draws the data entries inside the tooltip for a given topic * @param {Object} topic Topic to extract data from * @return void */ function updateTopicContent(topic){ let name = topic[nameLabel], tooltipRight, tooltipLeftText, tooltipRightText, elementText; tooltipLeftText = topic.topicName || name; tooltipRightText = getValueText(topic); elementText = tooltipBody .append('text') .classed('tooltip-left-text', true) .attr('dy', '1em') .attr('x', ttTextX - 20) .attr('y', ttTextY) .style('fill', tooltipTextColor) .text(tooltipLeftText) .call(textWrap, tooltipMaxTopicLength, -25); tooltipRight = tooltipBody .append('text') .classed('tooltip-right-text', true) .attr('dy', '1em') .attr('x', ttTextX + 8) .attr('y', ttTextY) .style('fill', tooltipTextColor) .text(tooltipRightText); textSize = elementText.node().getBBox(); tooltipHeight += textSize.height + 5; // Not sure if necessary tooltipRight.attr('x', tooltipWidth - tooltipRight.node().getBBox().width - 10 - tooltipWidth / 4) tooltipBody .append('circle') .classed('tooltip-circle', true) .attr('cx', 23 - tooltipWidth / 4) .attr('cy', (ttTextY + circleYOffset)) .attr('r', 5) .style('fill', colorMap[name]) .style('stroke-width', 1); ttTextY += textSize.height + 7; } /** * Updates size and position of tooltip depending on the side of the chart we are in * TODO: This needs a refactor, following the mini-tooltip code. * * @param {Object} dataPoint DataPoint of the tooltip * @param {Number} xPosition DataPoint's x position in the chart * @param {Number} xPosition DataPoint's y position in the chart * @return void */ function updatePositionAndSize(dataPoint, xPosition, yPosition){ let [tooltipX, tooltipY] = getTooltipPosition([xPosition, yPosition]) tooltip .attr('width', tooltipWidth) .attr('height', tooltipHeight + 10); tooltipTextContainer.transition() .duration(mouseChaseDuration) .ease(ease) .attr('transform', `translate(${tooltipX}, ${tooltipY})`); tooltipDivider .attr('x2', tooltipWidth - 60); } /** * Updates value of tooltipTitle with the data meaning and the date * @param {Object} dataPoint Point of data to use as source * @return void */ function updateTitle(dataPoint) { let tTitle = title; if (shouldShowDateInTitle) { tTitle = `${tTitle} - ${formatDate(new Date(dataPoint[dateLabel]))}`; } tooltipTitle.text(tTitle); } /** * Figures out which date format to use when showing the date of the current data entry * @return {Function} The proper date formatting function */ function formatDate(date) { let settings = dateFormat || defaultAxisSettings; let format = null; let localeOptions = {month:'short', day:'numeric'}; if (settings === axisTimeCombinations.DAY_MONTH || settings === axisTimeCombinations.MONTH_YEAR) { format = monthDayYearFormat; localeOptions.year = 'numeric'; } else if (settings === axisTimeCombinations.HOUR_DAY || settings === axisTimeCombinations.MINUTE_HOUR) { format = monthDayHourFormat; localeOptions.hour = 'numeric'; } if (locale &amp;&amp; ((typeof Intl !== 'undefined') &amp;&amp; (typeof Intl === 'object' &amp;&amp; Intl.DateTimeFormat))) { let f = Intl.DateTimeFormat(locale, localeOptions); return f.format(date); } return format(date); } /** * Helper method to sort the passed topics array by the names passed int he order arary * @param {Object[]} topics Topics data, retrieved from datapoint passed by line chart * @param {Object[]} order Array of names in the order to sort topics by * @return {Object[]} sorted topics object */ function _sortByTopicsOrder(topics, order=topicsOrder) { return order.map((orderName) =&gt; topics.filter(({name}) =&gt; name === orderName)[0]); } /** * Sorts topic by alphabetical order for arrays of objects with a name proeprty * @param {Array} topics List of topic objects * @return {Array} List of topic name strings */ function _sortByAlpha(topics) { return topics .map(d =&gt; d) .sort((a, b) =&gt; { if (a.name &gt; b.name) return 1; if (a.name === b.name) return 0; return -1; }); let otherIndex = topics.map(({name}) =&gt; name).indexOf('Other'); if (otherIndex &gt;= 0) { let other = topics.splice(otherIndex, 1); topics = topics.concat(other); } } /** * Wraps a text given the text, width, x position and textFormatter function * @param {D3Selection} text Selection with the text to wrap inside * @param {Number} width Desired max width for that line * @param {Number} xpos Initial x position of the text * * REF: http://bl.ocks.org/mbostock/7555321 * More discussions on https://github.com/mbostock/d3/issues/1642 */ function textWrap(text, width, xpos) { xpos = xpos || 0; text.each(function() { var words, word, line, lineNumber, lineHeight, y, dy, tspan; text = d3Selection.select(this); words = text.text().split(/\\s+/).reverse(); line = []; lineNumber = 0; lineHeight = 1.2; y = text.attr('y'); dy = parseFloat(text.attr('dy')); tspan = text .text(null) .append('tspan') .attr('x', xpos) .attr('y', y) .attr('dy', dy + 'em'); while ((word = words.pop())) { line.push(word); tspan.text(line.join(' ')); if (tspan.node().getComputedTextLength() &gt; width) { line.pop(); tspan.text(line.join(' ')); if (lineNumber &lt; entryLineLimit - 1) { line = [word]; tspan = text.append('tspan') .attr('x', xpos) .attr('y', y) .attr('dy', ++lineNumber * lineHeight + dy + 'em') .text(word); } } } }); } /** * Draws the data entries inside the tooltip * @param {Object} dataPoint Data entry from to take the info * @return void */ function updateContent(dataPoint){ var topics = dataPoint[topicLabel]; // sort order by topicsOrder array if passed if (topicsOrder.length) { topics = _sortByTopicsOrder(topics); } else if (topics.length &amp;&amp; topics[0].name) { topics = _sortByAlpha(topics); } cleanContent(); updateTitle(dataPoint); resetSizeAndPositionPointers(); topics.forEach(updateTopicContent); } /** * Updates tooltip title, content, size and position * sorts by alphatical name order if not forced order given * * @param {lineChartPointByDate} dataPoint Current datapoint to show info about * @param {Number} xPosition Position of the mouse on the X axis * @return void */ function updateTooltip(dataPoint, xPosition, yPosition) { updateContent(dataPoint); updatePositionAndSize(dataPoint, xPosition, yPosition); } // API /** * constants to be used to force the x axis to respect a certain granularity * current options: HOUR_DAY, DAY_MONTH, MONTH_YEAR * @example tooltip.dateFormat(tooltip.axisTimeCombinations.HOUR_DAY) */ exports.axisTimeCombinations = axisTimeCombinations; /** * Exposes the ability to force the tooltip to use a certain date format * @param {String} _x Desired format * @return { (String|Module) } Current format or module to chain calls */ exports.dateFormat = function(_x) { if (!arguments.length) { return dateFormat || defaultAxisSettings; } dateFormat = _x; return this; }; /** * Gets or Sets the dateLabel of the data * @param {String} _x Desired dateLabel * @return { String | module} Current dateLabel or Chart module to chain calls * @public */ exports.dateLabel = function(_x) { if (!arguments.length) { return dateLabel; } dateLabel = _x; return this; }; /** * Hides the tooltip * @return {Module} Tooltip module to chain calls * @public */ exports.hide = function() { svg.style('display', 'none'); return this; }; /** * Pass locale for the tooltip to render the date in * @param {String} _x Must be a locale tag like 'en-US' or 'fr-FR' * @return { (String|Module) } Current locale or module to chain calls * @public */ exports.locale = function(_x) { if (!arguments.length) { return locale; } locale = _x; return this; }; /** * Gets or Sets the nameLabel of the data * @param {String} _x Desired nameLabel * @return { String | module} Current nameLabel or Chart module to chain calls * @public */ exports.nameLabel = function(_x) { if (!arguments.length) { return nameLabel; } nameLabel = _x; return this; }; /** * Gets or Sets shouldShowDateInTitle * @param {Boolean} _x Desired value * @return { shouldShowDateInTitle | module} Current shouldShowDateInTitle or Chart module to chain calls * @public */ exports.shouldShowDateInTitle = function(_x) { if (!arguments.length) { return shouldShowDateInTitle; } shouldShowDateInTitle = _x; return this; }; /** * Shows the tooltip * @return {Module} Tooltip module to chain calls * @public */ exports.show = function() { svg.style('display', 'block'); return this; }; /** * Gets or Sets shouldShowDateInTitle * @param {Boolean} _x Desired value * @return { Boolean | module} Current shouldShowDateInTitle or Chart module to chain calls * @public */ exports.shouldShowDateInTitle = function(_x) { if (!arguments.length) { return shouldShowDateInTitle; } shouldShowDateInTitle = _x; return this; }; /** * Gets or Sets the title of the tooltip * @param {String} _x Desired title * @return { String | module} Current title or module to chain calls * @public */ exports.title = function(_x) { if (!arguments.length) { return title; } title = _x; return this; }; /** * Pass an override for the ordering of your tooltip * @param {Object[]} _x Array of the names of your tooltip items * @return { Object[] | module} Current overrideOrder or Chart module to chain calls * @public */ exports.topicsOrder = function(_x) { if (!arguments.length) { return topicsOrder; } topicsOrder = _x; return this; }; /** * Pass an override for the ordering of your tooltip * @param {String[]} _x Array of the names of your tooltip items * @return { String[] | module} Current overrideOrder or Chart module to chain calls * @public */ exports.topicsOrder = function(_x) { if (!arguments.length) { return topicsOrder; } topicsOrder = _x; return this; }; /** * Gets or Sets the topicLabel of the data * @param {String} _x Desired topicLabel * @return { String | module} Current topicLabel or Chart module to chain calls * @public */ exports.topicLabel = function(_x) { if (!arguments.length) { return topicLabel; } topicLabel = _x; return this; }; /** * Updates the position and content of the tooltip * @param {Object} dataPoint Datapoint to represent * @param {Object} colorMapping Color scheme of the topics * @param {Number} position X-scale position in pixels * @return {Module} Tooltip module to chain calls * @public */ exports.update = function(dataPoint, colorMapping, xPosition, yPosition = null) { colorMap = colorMapping; updateTooltip(dataPoint, xPosition, yPosition); return this; }; /** * Gets or Sets the valueFormat of the tooltip * @param {String} _x Desired valueFormat * @return { String | module} Current valueFormat or module to chain calls * @public */ exports.valueFormat = function(_x) { if (!arguments.length) { return valueFormat; } valueFormat = _x; return this; }; /** * Gets or Sets the valueLabel of the data * @param {String} _x Desired valueLabel * @return { String | module} Current valueLabel or Chart module to chain calls * @public */ exports.valueLabel = function(_x) { if (!arguments.length) { return valueLabel; } valueLabel = _x; return this; }; return exports; }; }); × Search results Close "},"global.html":{"id":"global.html","title":"Global","body":" Getting started Demos Bar Chart Brush Chart Donut Chart Grouped Bar Chart Kitchen Sink Line Chart Sparkline Chart Stacked Area Chart Stacked Bar Chart Step Chart API Bar Brush Donut Grouped-bar Legend Line Mini-tooltip Sparkline Stacked-area Stacked-bar Step Tooltip Types Github Twitter Global Type Definitions areaChartData Type: Object Properties: Name Type Description data Array.&lt;Object&gt; All data entries date String Date of the entry name String Name of the entry value Number Value of the entry Source: stacked-area.js Example { 'data': [ { &quot;date&quot;: &quot;2011-01-05T00:00:00Z&quot;, &quot;name&quot;: &quot;Direct&quot;, &quot;value&quot;: 0 } ] } BarChartData Type: Array.&lt;Object&gt; Properties: Name Type Description value Number Value of the group (required) name String Name of the group (required) Source: bar.js Example [ { value: 1, name: 'glittering' }, { value: 1, name: 'luminous' } ] BrushChartData Type: Array.&lt;Object&gt; Properties: Name Type Description value Number Value to chart (required) date Date Date of the value (required) Source: brush.js Example [ { value: 1, date: '2011-01-06T00:00:00Z' }, { value: 2, date: '2011-01-07T00:00:00Z' } ] D3Selection Type: Array.&lt;Array&gt; Properties: Name Type Description length Number Size of the selection parentNode DOMElement Parent of the selection Source: line.js DonutChartData Type: Array.&lt;Object&gt; Properties: Name Type Description quantity Number Quantity of the group (required) percentage Number Percentage of the total (optional) name String Name of the group (required) id Number Identifier for the group required for legend feature (optional) Source: donut.js Example [ { quantity: 1, percentage: 50, name: 'glittering', id: 1 }, { quantity: 1, percentage: 50, name: 'luminous', id: 2 } ] GroupedBarChartData Type: Object Properties: Name Type Description data Array.&lt;Object&gt; All data entries name String Name of the entry group String group of the entry value Number Value of the entry Source: grouped-bar.js Example { 'data': [ { &quot;name&quot;: &quot;2011-01&quot;, &quot;group&quot;: &quot;Direct&quot;, &quot;value&quot;: 0 } ] } LegendChartData Type: Array.&lt;Object&gt; Properties: Name Type Description id Number Id of the group (required) quantity Number Quantity of the group (required) name String Name of the group (required) Source: legend.js Example [ { id: 1, quantity: 2, name: 'glittering' }, { id: 2, quantity: 3, name: 'luminous' } LineChartData Type: Array.&lt;Object&gt; Properties: Name Type Description dataByTopic Array.&lt;lineChartDataByTopic&gt; Data values to chart (required) Source: line.js Example { dataByTopic: [ { topicName: 'San Francisco', topic: 123, dates: [ { date: '2017-01-16T16:00:00-08:00', value: 1 }, { date: '2017-01-16T17:00:00-08:00', value: 2 } ] }, { topicName: 'Other', topic: 345, dates: [ {...}, {...} ] } ] } lineChartDataByTopic Type: Object Properties: Name Type Description topicName String Topic name (required) topic Number Topic identifier (required) dates Array.&lt;Object&gt; All date entries with values for that topic (required) Source: line.js Example { topicName: 'San Francisco', topic: 123, dates: [ { date: '2017-01-16T16:00:00-08:00', value: 1 }, { date: '2017-01-16T17:00:00-08:00', value: 2 } ] } SparklineChartData Type: Array.&lt;Object&gt; Properties: Name Type Description value Number Value of the group (required) name String Name of the group (required) Source: sparkline.js Example [ { value: 1, date: '2011-01-06T00:00:00Z' }, { value: 2, date: '2011-01-07T00:00:00Z' } stackedBarData Type: Object Properties: Name Type Description data Array.&lt;Object&gt; All data entries name String Name of the entry stack String Stack of the entry value Number Value of the entry Source: stacked-bar.js Example { 'data': [ { &quot;name&quot;: &quot;2011-01&quot;, &quot;stack&quot;: &quot;Direct&quot;, &quot;value&quot;: 0 } ] } StepChartData Type: Array.&lt;Object&gt; Properties: Name Type Description key String Key we measure (required) value Number value of the key (required) Source: step.js Example [ { value: 1, key: 'glittering' }, { value: 1, key: 'luminous' } ] × Search results Close "},"modules.list.html":{"id":"modules.list.html","title":"Modules","body":" Getting started Demos Bar Chart Brush Chart Donut Chart Grouped Bar Chart Kitchen Sink Line Chart Sparkline Chart Stacked Area Chart Stacked Bar Chart Step Chart API Bar Brush Donut Grouped-bar Legend Line Mini-tooltip Sparkline Stacked-area Stacked-bar Step Tooltip Types Github Twitter Modules × Search results Close "},"tutorials.list.html":{"id":"tutorials.list.html","title":"Demos","body":" Getting started Demos Bar Chart Brush Chart Donut Chart Grouped Bar Chart Kitchen Sink Line Chart Sparkline Chart Stacked Area Chart Stacked Bar Chart Step Chart API Bar Brush Donut Grouped-bar Legend Line Mini-tooltip Sparkline Stacked-area Stacked-bar Step Tooltip Types Github Twitter Demos × Search results Close "},"index.html":{"id":"index.html","title":"Britecharts - D3.js based charting library of reusable components","body":" Getting started Demos Bar Chart Brush Chart Donut Chart Grouped Bar Chart Kitchen Sink Line Chart Sparkline Chart Stacked Area Chart Stacked Bar Chart Step Chart API Bar Brush Donut Grouped-bar Legend Line Mini-tooltip Sparkline Stacked-area Stacked-bar Step Tooltip Types Github Twitter Britecharts Britecharts is a client-side reusable Charting Library based on D3.js v4 that allows easy and intuitive use of charts and components that can be composed together creating amazing visualizations. Britecharts components have been written in ES2015 with a Test Driven methodology so they are fully tested, and we are commited to keeping them that way. Key FeaturesThe main characteristics of this library are: Reusability Composability Fully tested ES2015 source code (transpiled with Babel) UsageThe typical use of Britecharts involves creating a chart using its simple API, then rendering it on a container which has previously had data applied to it. The code will look like this: barChart .width(500) .height(300); barContainer.datum(dataset).call(barChart);APIAll the components expose some basic API methods like width, height and margin. Additionally, each chart or component can expose more methods. Those can be found in the documentation of the modules: Line Chart: API - Demo Donut Chart: API - Demo Bar Chart: API - Demo Stacked Bar Chart: API - Demo Grouped Bar Chart: API - Demo Brush Chart: API - Demo Sparkline Chart: API - Demo Stacked Area Chart: API - Demo Tooltip Chart: API - Demo Mini Tooltip Chart: API - Demo Legend Chart: API - Demo Step Chart: API - Demo InstallationBritecharts components are distributed in UMD modules, each one exposing a D3.js component written with the Reusable API pattern. In order to use any of the Britecharts modules, you will need to require the chart in your JS file using AMD/CommonJS modules or adding a script tag with the src pointing to the file. You would also need to load the D3.js selection library in order to select the chart container. npm install britecharts d3-selectionThey also provide some minimal CSS styling, that can be loaded independently or as a bundle. Check out our CDN demo page or our JSBin and CodePen sandbox projects. You can also watch Per Borgen's screencast to see Britecharts in action. RoadmapThis project is in active development, if you are interested on helping you can check the contributing document. Review the issues page for more info on what's coming, to give your feedback, and to vote for your favorite proposals. See Also Getting Started Guide Documentation Release Notes Contributing Guide Github Repo Bar Chart Tutorial (Video) AcknowledgmentsBritecharts was inspired by two books, Developing a D3.js Edge and Mastering D3.js. It also leveraged a great number of examples and articles from the D3.js community overall. LicenseCopyright 2017 Eventbrite Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); you may not use this file except in compliance with the License. You may obtain a copy of the License at https://www.apache.org/licenses/LICENSE-2.0 Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an &quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License. Read more in the license document × Search results Close "},"getting-started.html":{"id":"getting-started.html","title":"Getting Started with Britecharts","body":" Getting started Demos Bar Chart Brush Chart Donut Chart Grouped Bar Chart Kitchen Sink Line Chart Sparkline Chart Stacked Area Chart Stacked Bar Chart Step Chart API Bar Brush Donut Grouped-bar Legend Line Mini-tooltip Sparkline Stacked-area Stacked-bar Step Tooltip Types Github Twitter Getting Started with BritechartsBritecharts has been created to help users consume and create d3 charts. It leverages a reusable API, which produces chart objects that (after initialization) can be configured and then applied to a container with a data set to plot. Installing BritechartsIn order to use a Britecharts chart in your project you would need to install it using NPM, Bower or cloning it via Github: Install with NPM npm install --save britecharts d3-selectionInstall with Bower bower install --save britecharts d3-selectionClone the git repository git clone https://github.com/eventbrite/britecharts.gitDirectly from CDNhttps://cdn.jsdelivr.net/npm/britecharts@2/dist/bundled/britecharts.min.js (latest 2.x.x version)Or browse all CDN files. Check also our CDN demo page or our JSBin and CodePen sandbox projects. Using BritechartsIn order to use a Britecharts chart in your project you would need to: Require the proper chart as a module, we can do: // ES2015 Modules import LineChart from 'britecharts/dist/umd/line.min'; // CommonJS or AMD modules LineChart = require('britecharts/dist/umd/line.min'); Require d3-selection as a dependency, in order to select a container to execute the chart on. d3Selection = require('d3-selection'); Instantiate a new line chart and select the chart container with d3-selection: var container = d3Selection.select('.js-chart-container'), lineChart = new LineChart(); Configure the default chart with attributes: if (container.node()) { lineChart .tooltipThreshold(tooltipShouldShowThreshold) .margin(chartMargin) .height(chartHeight) .width(chartWidth); } And finally call the chart with a container and data attached to the container. // This line gets together container, data and chart container.datum(data).call(lineChart);And that would generate your britechart! Here is the whole code: var container = d3Selection.select('.js-chart-container'), lineChart = new LineChart(); if (container.node()) { lineChart .tooltipThreshold(tooltipShouldShowThreshold) .margin(chartMargin) .height(chartHeight) .width(chartWidth); } // This line gets together container, data and chart container.datum(data).call(lineChart);It won't look perfect though, you will need to load a small CSS file in order to see it styled. You can load the whole bundle: &lt;link type=&quot;text/css&quot; rel=&quot;stylesheet&quot; href=&quot;node_modules/britecharts/dist/css/britecharts.min.css&quot;&gt;or just load the styles for the current chart plus the common Britecharts styles: &lt;link type=&quot;text/css&quot; rel=&quot;stylesheet&quot; href=&quot;node_modules/britecharts/dist/css/common/common.css&quot;&gt; &lt;link type=&quot;text/css&quot; rel=&quot;stylesheet&quot; href=&quot;node_modules/britecharts/dist/css/charts/line.css&quot;&gt;Making it ResponsiveYou will probably want to set up a listener for the resize event to re-render the chart, and probably debounce it, so it doesn't render too many times. This code would probably look like this: const redrawChart = () =&gt; { let container = d3.select(‘.js-chart-container’); let newContainerWidth = container.node() ? container.node().getBoundingClientRect().width : false; // Setting the new width on the chart lineChart.width(newContainerWidth); // Rendering the chart again container.datum(data).call(lineChart); }; const throttledRedraw = _.throttle(redrawChart, 200); window.addEventListener(&quot;resize&quot;, throttledRedraw);Learning MoreCheck out our Documentation Homepage and our kitchen sink to see all the available charts. If you are excited about Britecharts, want to add more configurable properties or even create your own chart, please check our Contributing Guide. In it, we walk you through the development environment setup, run our docs and demos and create new Pull Requests. × Search results Close "},"cdn.html":{"id":"cdn.html","title":"CDN Loading Demo - Britecharts","body":" Getting started Demos Bar Chart Brush Chart Donut Chart Grouped Bar Chart Kitchen Sink Line Chart Sparkline Chart Stacked Area Chart Stacked Bar Chart Step Chart API Bar Brush Donut Grouped-bar Legend Line Mini-tooltip Sparkline Stacked-area Stacked-bar Step Tooltip Types Github Twitter × Search results Close "},"module-Bar.html":{"id":"module-Bar.html","title":"API: Bar","body":" Getting started Demos Bar Chart Brush Chart Donut Chart Grouped Bar Chart Kitchen Sink Line Chart Sparkline Chart Stacked Area Chart Stacked Bar Chart Step Chart API Bar Brush Donut Grouped-bar Legend Line Mini-tooltip Sparkline Stacked-area Stacked-bar Step Tooltip Types Github Twitter API: Bar Bar Chart reusable API class that renders a simple and configurable bar chart. (require(&quot;Bar&quot;))(_selection, _data) This function creates the graph using the selection as container Parameters: Name Type Description _selection D3Selection A d3 selection that represents the container(s) where the chart(s) will be rendered _data BarChartData The data to attach and generate the chart Source: bar.js Requires module:d3-array, Methods module:Bar(_selection, _data) This function creates the graph using the selection as container Parameters: Name Type Description _selection D3Selection A d3 selection that represents the container(s) where the chart(s) will be rendered _data BarChartData The data to attach and generate the chart Source: bar.js &lt;static&gt; colorSchema(_x) Gets or Sets the colorSchema of the chart Parameters: Name Type Description _x Array.&lt;String&gt; Desired colorSchema for the graph Source: bar.js Returns: Current colorSchema or Chart module to chain calls Type colorSchema | module &lt;static&gt; enablePercentageLabels(_x) Default false. If true, adds percentage labels at the end of the bars Parameters: Name Type Description _x Boolean Source: bar.js Returns: Current value of enablePercentageLables or Chart module to chain calls Type Boolean | module &lt;static&gt; exportChart(filename, title) Chart exported to png and a download action is fired Parameters: Name Type Description filename String File title for the resulting picture title String Title to add at the top of the exported picture Source: bar.js &lt;static&gt; hasPercentage(_x) Gets or Sets the hasPercentage status Parameters: Name Type Description _x boolean Should use percentage as value format Source: bar.js Returns: Is percentage used or Chart module to chain calls Type boolean | module &lt;static&gt; height(_x) Gets or Sets the height of the chart Parameters: Name Type Description _x number Desired width for the graph Source: bar.js Returns: Current height or Chart module to chain calls Type height | module &lt;static&gt; isAnimated(_x) Gets or Sets the isAnimated property of the chart, making it to animate when render. By default this is 'false' Parameters: Name Type Description _x Boolean Desired animation flag Source: bar.js Returns: Current isAnimated flag or Chart module Type isAnimated | module &lt;static&gt; isHorizontal(_x) Gets or Sets the horizontal direction of the chart Parameters: Name Type Description _x number Desired horizontal direction for the graph Source: bar.js Returns: If it is horizontal or Chart module to chain calls Type isHorizontal | module &lt;static&gt; margin(_x) Gets or Sets the margin of the chart Parameters: Name Type Description _x object Margin object to get/set Source: bar.js Returns: Current margin or Chart module to chain calls Type margin | module &lt;static&gt; nameLabel(_x) Gets or Sets the nameLabel of the chart Parameters: Name Type Description _x Number Desired nameLabel for the graph Source: bar.js Returns: Current nameLabel or Chart module to chain calls Type nameLabel | module &lt;static&gt; on() Exposes an 'on' method that acts as a bridge with the event dispatcher We are going to expose this events: customMouseOver, customMouseMove and customMouseOut Source: bar.js Returns: Bar Chart Type module &lt;static&gt; percentageAxisToMaxRatio(_x) Configurable extension of the x axis if your max point was 50% you might want to show x axis to 60%, pass 1.2 Parameters: Name Type Description _x number ratio to max data point to add to the x axis Source: bar.js Returns: Current ratio or Chart module to chain calls Type ratio | module &lt;static&gt; percentageLabelMargin(_x) Default 10px. Offset between end of bar and start of the percentage bars Parameters: Name Type Description _x number percentage margin offset from end of bar Source: bar.js Returns: Currnet offset or Chart module to chain calls Type number | module &lt;static&gt; shouldReverseColorList(_x) Gets or Sets whether the color list should be reversed or not Parameters: Name Type Description _x boolean Should reverse the color list Source: bar.js Returns: Is color list being reversed Type boolean | module &lt;static&gt; usePercentage(_x) Gets or Sets the valueLabelFormat to a percentage format if true (default false) Parameters: Name Type Description _x boolean Should use percentage as value format Source: bar.js Returns: Is percentage the value format used or Chart module to chain calls Type boolean | module &lt;static&gt; valueLabel(_x) Gets or Sets the valueLabel of the chart Parameters: Name Type Description _x Number Desired valueLabel for the graph Source: bar.js Returns: Current valueLabel or Chart module to chain calls Type valueLabel | module &lt;static&gt; width(_x) Gets or Sets the width of the chart Parameters: Name Type Description _x number Desired width for the graph Source: bar.js Returns: Current width or Chart module to chain calls Type width | module &lt;static&gt; xTicks(_x) Gets or Sets the number of ticks of the x axis on the chart (Default is 5) Parameters: Name Type Description _x Number Desired horizontal ticks Source: bar.js Returns: Current xTicks or Chart module to chain calls Type Number | module &lt;static&gt; yAxisPaddingBetweenChart(_x) Space between y axis and chart (Default 10) Parameters: Name Type Description _x Number Space between y axis and chart Source: bar.js Returns: Current value of yAxisPaddingBetweenChart or Chart module to chain calls Type Number | module &lt;static&gt; yTicks(_x) Gets or Sets the number of vertical ticks on the chart (Default is 6) Parameters: Name Type Description _x Number Desired number of vertical ticks for the graph Source: bar.js Returns: Current yTicks or Chart module to chain calls Type Number | module × Search results Close "},"module-Brush.html":{"id":"module-Brush.html","title":"API: Brush","body":" Getting started Demos Bar Chart Brush Chart Donut Chart Grouped Bar Chart Kitchen Sink Line Chart Sparkline Chart Stacked Area Chart Stacked Bar Chart Step Chart API Bar Brush Donut Grouped-bar Legend Line Mini-tooltip Sparkline Stacked-area Stacked-bar Step Tooltip Types Github Twitter API: Brush Brush Chart reusable API class that renders a simple and configurable brush chart. (require(&quot;Brush&quot;))(_selection, _data) This function creates the graph using the selection as container Parameters: Name Type Description _selection D3Selection A d3 selection that represents the container(s) where the chart(s) will be rendered _data BrushChartData The data to attach and generate the chart Source: brush.js Requires module:d3-array, Members &lt;static&gt; axisTimeCombinations Exposes the constants to be used to force the x axis to respect a certain granularity current options: MINUTE_HOUR, HOUR_DAY, DAY_MONTH, MONTH_YEAR Source: brush.js Example brush.xAxisCustomFormat(brush.axisTimeCombinations.HOUR_DAY) Methods module:Brush(_selection, _data) This function creates the graph using the selection as container Parameters: Name Type Description _selection D3Selection A d3 selection that represents the container(s) where the chart(s) will be rendered _data BrushChartData The data to attach and generate the chart Source: brush.js &lt;static&gt; dateRange(_x) Gets or Sets the dateRange for the selected part of the brush Parameters: Name Type Description _x Array.&lt;String&gt; Desired dateRange for the graph Source: brush.js Returns: Current dateRange or Chart module to chain calls Type dateRange | module &lt;static&gt; gradient(_x) Gets or Sets the gradient of the chart Parameters: Name Type Description _x Array.&lt;String&gt; Desired gradient for the graph Source: brush.js Returns: Current gradient or Chart module to chain calls Type String | Module &lt;static&gt; height(_x) Gets or Sets the height of the chart Parameters: Name Type Description _x Number Desired width for the graph Source: brush.js Returns: Current height or Chart module to chain calls Type Number | Module &lt;static&gt; locale(_x) Pass language tag for the tooltip to localize the date. Feature uses Intl.DateTimeFormat, for compatability and support, refer to https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DateTimeFormat Parameters: Name Type Description _x String must be a language tag (BCP 47) like 'en-US' or 'fr-FR' Source: brush.js Returns: Current locale or module to chain calls Type String | Module &lt;static&gt; margin(_x) Gets or Sets the margin of the chart Parameters: Name Type Description _x Object Margin object to get/set Source: brush.js Returns: Current margin or Chart module to chain calls Type Object | Module &lt;static&gt; on() Exposes an 'on' method that acts as a bridge with the event dispatcher We are going to expose this events: customMouseOver, customMouseMove and customMouseOut Source: brush.js Returns: Bar Chart Type module &lt;static&gt; width(_x) Gets or Sets the width of the chart Parameters: Name Type Description _x Number Desired width for the graph Source: brush.js Returns: Current width or Chart module to chain calls Type Number | Module &lt;static&gt; xAxisCustomFormat(_x) Exposes the ability to force the chart to show a certain x format It requires a `xAxisFormat` of 'custom' in order to work. Parameters: Name Type Description _x String Desired format for x axis Source: brush.js Returns: Current format or module to chain calls Type String | Module &lt;static&gt; xAxisFormat(_x) Exposes the ability to force the chart to show a certain x axis grouping Parameters: Name Type Description _x String Desired format Source: brush.js Returns: Current format or module to chain calls Type String | Module Example brush.xAxisFormat(brush.axisTimeCombinations.HOUR_DAY) &lt;static&gt; xTicks(_x) Exposes the ability to force the chart to show a certain x ticks. It requires a `xAxisCustomFormat` of 'custom' in order to work. NOTE: This value needs to be a multiple of 2, 5 or 10. They won't always work as expected, as D3 decides at the end how many and where the ticks will appear. Parameters: Name Type Description _x Number Desired number of x axis ticks (multiple of 2, 5 or 10) Source: brush.js Returns: Current number or ticks or module to chain calls Type Number | Module × Search results Close "},"module-Donut.html":{"id":"module-Donut.html","title":"API: Donut","body":" Getting started Demos Bar Chart Brush Chart Donut Chart Grouped Bar Chart Kitchen Sink Line Chart Sparkline Chart Stacked Area Chart Stacked Bar Chart Step Chart API Bar Brush Donut Grouped-bar Legend Line Mini-tooltip Sparkline Stacked-area Stacked-bar Step Tooltip Types Github Twitter API: Donut Reusable Donut Chart API class that renders a simple and configurable donut chart. (require(&quot;Donut&quot;))(_selection, _data) This function creates the graph using the selection as container Parameters: Name Type Description _selection D3Selection A d3 selection that represents the container(s) where the chart(s) will be rendered _data DonutChartData The data to attach and generate the chart Source: donut.js Requires module:d3-dispatch, Methods module:Donut(_selection, _data) This function creates the graph using the selection as container Parameters: Name Type Description _selection D3Selection A d3 selection that represents the container(s) where the chart(s) will be rendered _data DonutChartData The data to attach and generate the chart Source: donut.js &lt;static&gt; colorSchema(_x) Gets or Sets the colorSchema of the chart Parameters: Name Type Description _x Array.&lt;String&gt; Desired colorSchema for the graph Source: donut.js Returns: Current colorSchema or Chart module to chain calls Type String | module &lt;static&gt; exportChart(filename, title) Chart exported to png and a download action is fired Parameters: Name Type Description filename String File title for the resulting picture title String Title to add at the top of the exported picture Source: donut.js &lt;static&gt; externalRadius(_x) Gets or Sets the externalRadius of the chart Parameters: Name Type Description _x Number ExternalRadius number to get/set Source: donut.js Returns: Current externalRadius or Donut Chart module to chain calls Type Number | Module &lt;static&gt; hasFixedHighlightedSlice(_x) Gets or Sets the hasFixedHighlightedSlice property of the chart, making it to highlight the selected slice id set with `highlightSliceById` all the time. Parameters: Name Type Description _x Boolean If we want to make the highlighted slice permanently highlighted Source: donut.js Returns: Current hasFixedHighlightedSlice flag or Chart module Type Boolean | module &lt;static&gt; height(_x) Gets or Sets the height of the chart Parameters: Name Type Description _x Number Desired width for the graph Source: donut.js Returns: Current height or Donut Chart module to chain calls Type Number | Module &lt;static&gt; highlightSliceById(_x) Gets or Sets the id of the slice to highlight Parameters: Name Type Description _x Number Slice id Source: donut.js Returns: Current highlighted slice id or Donut Chart module to chain calls Type Number | Module &lt;static&gt; internalRadius(_x) Gets or Sets the internalRadius of the chart Parameters: Name Type Description _x Number InternalRadius number to get/set Source: donut.js Returns: Current internalRadius or Donut Chart module to chain calls Type Number | Module &lt;static&gt; isAnimated(_x) Gets or Sets the isAnimated property of the chart, making it to animate when render. By default this is 'false' Parameters: Name Type Description _x Boolean Desired animation flag Source: donut.js Returns: Current isAnimated flag or Chart module Type Boolean | module &lt;static&gt; margin(_x) Gets or Sets the margin of the chart Parameters: Name Type Description _x Object Margin object to get/set Source: donut.js Returns: Current margin or Donut Chart module to chain calls Type Object | Module &lt;static&gt; on() Exposes an 'on' method that acts as a bridge with the event dispatcher We are going to expose this events: customMouseOver, customMouseMove and customMouseOut Source: donut.js Returns: Bar Chart Type module &lt;static&gt; width(_x) Gets or Sets the width of the chart Parameters: Name Type Description _x Number Desired width for the graph Source: donut.js Returns: Current width or Donut Chart module to chain calls Type Number | Module × Search results Close "},"module-Grouped-bar.html":{"id":"module-Grouped-bar.html","title":"API: Grouped-bar","body":" Getting started Demos Bar Chart Brush Chart Donut Chart Grouped Bar Chart Kitchen Sink Line Chart Sparkline Chart Stacked Area Chart Stacked Bar Chart Step Chart API Bar Brush Donut Grouped-bar Legend Line Mini-tooltip Sparkline Stacked-area Stacked-bar Step Tooltip Types Github Twitter API: Grouped-bar Grouped Bar Chart reusable API module that allows us rendering a multi grouped bar and configurable chart. (require(&quot;Grouped-bar&quot;))(_selection, _data) This function creates the graph using the selection and data provided Parameters: Name Type Description _selection D3Selection A d3 selection that represents the container(s) where the chart(s) will be rendered _data GroupedBarChartData The data to attach and generate the chart Source: grouped-bar.js Requires module:d3-array, Methods module:Grouped-bar(_selection, _data) This function creates the graph using the selection and data provided Parameters: Name Type Description _selection D3Selection A d3 selection that represents the container(s) where the chart(s) will be rendered _data GroupedBarChartData The data to attach and generate the chart Source: grouped-bar.js &lt;static&gt; aspectRatio(_x) Gets or Sets the aspect ratio of the chart Parameters: Name Type Description _x Number Desired aspect ratio for the graph Source: grouped-bar.js Returns: Current aspect ratio or Area Chart module to chain calls Type Number | Module &lt;static&gt; colorSchema(_x) Gets or Sets the colorSchema of the chart Parameters: Name Type Description _x Array.&lt;String&gt; Desired colorSchema for the graph Source: grouped-bar.js Returns: Current colorSchema or Chart module to chain calls Type colorSchema | module &lt;static&gt; exportChart(filename, title) Chart exported to png and a download action is fired Parameters: Name Type Description filename String File title for the resulting picture title String Title to add at the top of the exported picture Source: grouped-bar.js &lt;static&gt; grid(_x) Gets or Sets the grid mode. Parameters: Name Type Description _x String Desired mode for the grid ('vertical'|'horizontal'|'full') Source: grouped-bar.js Returns: Current mode of the grid or Area Chart module to chain calls Type String | module &lt;static&gt; groupLabel(_x) Gets or Sets the groupLabel of the chart Parameters: Name Type Description _x String Desired groupLabel for the graph Source: grouped-bar.js Returns: Current groupLabel or Chart module to chain calls Type groupLabel | module &lt;static&gt; height(_x) Gets or Sets the height of the chart Parameters: Name Type Description _x Number Desired width for the graph Source: grouped-bar.js Returns: Current height or Area Chart module to chain calls Type height | module &lt;static&gt; isAnimated(_x) Gets or Sets the isAnimated property of the chart, making it to animate when render. By default this is 'false' Parameters: Name Type Description _x Boolean Desired animation flag Source: grouped-bar.js Returns: Current isAnimated flag or Chart module Type isAnimated | module &lt;static&gt; isHorizontal(_x) Gets or Sets the horizontal direction of the chart Parameters: Name Type Description _x number Desired horizontal direction for the graph Source: grouped-bar.js Returns: If it is horizontal or Bar Chart module to chain calls Type isHorizontal | module &lt;static&gt; margin(_x) Gets or Sets the margin of the chart Parameters: Name Type Description _x Object Margin object to get/set Source: grouped-bar.js Returns: Current margin or Area Chart module to chain calls Type margin | module &lt;static&gt; nameLabel(_x) Gets or Sets the nameLabel of the chart Parameters: Name Type Description _x Number Desired dateLabel for the graph Source: grouped-bar.js Returns: Current nameLabel or Chart module to chain calls Type nameLabel | module &lt;static&gt; on() Exposes an 'on' method that acts as a bridge with the event dispatcher We are going to expose this events: customMouseOver, customMouseMove and customMouseOut Source: grouped-bar.js Returns: Bar Chart Type module &lt;static&gt; tooltipThreshold(_x) Gets or Sets the minimum width of the graph in order to show the tooltip NOTE: This could also depend on the aspect ratio Parameters: Name Type Description _x Object Margin object to get/set Source: grouped-bar.js Returns: Current tooltipThreshold or Area Chart module to chain calls Type tooltipThreshold | module &lt;static&gt; valueLabel(_x) Gets or Sets the valueLabel of the chart Parameters: Name Type Description _x Number Desired valueLabel for the graph Source: grouped-bar.js Returns: Current valueLabel or Chart module to chain calls Type valueLabel | module &lt;static&gt; valueLabelFormat(_x) Gets or Sets the valueLabelFormat of the chart Parameters: Name Type Description _x Array.&lt;String&gt; Desired valueLabelFormat for the graph Source: grouped-bar.js Returns: Current valueLabelFormat or Chart module to chain calls Type valueLabelFormat | module &lt;static&gt; width(_x) Gets or Sets the width of the chart Parameters: Name Type Description _x Number Desired width for the graph Source: grouped-bar.js Returns: Current width or Area Chart module to chain calls Type width | module &lt;static&gt; xTicks(_x) Gets or Sets the number of ticks of the x axis on the chart Parameters: Name Type Description _x Number Desired xTicks Source: grouped-bar.js Returns: Current xTicks or Chart module to chain calls Type Number | module &lt;static&gt; yTicks(_x) Gets or Sets the number of ticks of the y axis on the chart Parameters: Name Type Description _x Number Desired vertical ticks Source: grouped-bar.js Returns: Current yTicks or Chart module to chain calls Type Number | module &lt;static&gt; yTickTextOffset(_x) Gets or Sets the x and y offset of ticks of the y axis on the chart Parameters: Name Type Description _x Object Desired offset Source: grouped-bar.js Returns: Current offset or Chart module to chain calls Type Object | module × Search results Close "},"module-Legend.html":{"id":"module-Legend.html","title":"API: Legend","body":" Getting started Demos Bar Chart Brush Chart Donut Chart Grouped Bar Chart Kitchen Sink Line Chart Sparkline Chart Stacked Area Chart Stacked Bar Chart Step Chart API Bar Brush Donut Grouped-bar Legend Line Mini-tooltip Sparkline Stacked-area Stacked-bar Step Tooltip Types Github Twitter API: Legend Legend Component reusable API class that renders a simple and configurable legend element. Source: legend.js Tutorials: Tutorial: legend Example var donutChart = donut(), legendBox = legend(); donutChart .externalRadius(500) .internalRadius(200) .on('customMouseOver', function(data) { legendBox.highlight(data.data.id); }) .on('customMouseOut', function() { legendBox.clearHighlight(); }); d3Selection.select('.css-selector') .datum(dataset) .call(donutChart); d3Selection.select('.other-css-selector') .datum(dataset) .call(legendBox); Requires module:d3 Methods &lt;static&gt; clearHighlight() Clears all highlighted entries Source: legend.js &lt;static&gt; colorSchema(_x) Gets or Sets the colorSchema of the chart Parameters: Name Type Description _x array Color scheme array to get/set Source: legend.js Returns: Current colorSchema or Donut Chart module to chain calls Type number | module &lt;static&gt; height(_x) Gets or Sets the height of the legend chart Parameters: Name Type Description _x number Desired width for the chart Source: legend.js Returns: Current height or Legend module to chain calls Type height | module &lt;static&gt; highlight(entryId) Highlights a line entry by fading the rest of lines Parameters: Name Type Description entryId number ID of the entry line Source: legend.js &lt;static&gt; isHorizontal(_x) Gets or Sets the horizontal mode on the legend Parameters: Name Type Description _x boolean Desired horizontal mode for the graph Source: legend.js Returns: If it is horizontal or Legend module to chain calls Type ishorizontal | module &lt;static&gt; margin(_x) Gets or Sets the margin of the legend chart Parameters: Name Type Description _x object Margin object to get/set Source: legend.js Returns: Current margin or Legend module to chain calls Type margin | module &lt;static&gt; markerSize(_x) Gets or Sets the markerSize of the legend chart. This markerSize will determine the horizontal and vertical size of the colored marks added as color identifiers for the chart's categories. Parameters: Name Type Description _x object Margin object to get/set Source: legend.js Returns: Current markerSize or Legend module to chain calls Type markerSize | module &lt;static&gt; numberFormat(_x) Gets or Sets the number format of the legend chart Parameters: Name Type Description _x string Desired number format for the legend chart Source: legend.js Returns: Current number format or Legend module to chain calls Type numberFormat | module &lt;static&gt; width(_x) Gets or Sets the width of the legend chart Parameters: Name Type Description _x number Desired width for the graph Source: legend.js Returns: Current width or Legend module to chain calls Type width | module × Search results Close "},"module-Line.html":{"id":"module-Line.html","title":"API: Line","body":" Getting started Demos Bar Chart Brush Chart Donut Chart Grouped Bar Chart Kitchen Sink Line Chart Sparkline Chart Stacked Area Chart Stacked Bar Chart Step Chart API Bar Brush Donut Grouped-bar Legend Line Mini-tooltip Sparkline Stacked-area Stacked-bar Step Tooltip Types Github Twitter API: Line Line Chart reusable API module that allows us rendering a multi line and configurable chart. (require(&quot;Line&quot;))(_selection, _data) This function creates the graph using the selection and data provided Parameters: Name Type Description _selection D3Selection A d3 selection that represents the container(s) where the chart(s) will be rendered _data LineChartData The data to attach and generate the chart Source: line.js Requires module:d3-array, Members &lt;static&gt; axisTimeCombinations Exposes the constants to be used to force the x axis to respect a certain granularity current options: MINUTE_HOUR, HOUR_DAY, DAY_MONTH, MONTH_YEAR Source: line.js Example line.xAxisCustomFormat(line.axisTimeCombinations.HOUR_DAY) Methods module:Line(_selection, _data) This function creates the graph using the selection and data provided Parameters: Name Type Description _selection D3Selection A d3 selection that represents the container(s) where the chart(s) will be rendered _data LineChartData The data to attach and generate the chart Source: line.js &lt;static&gt; aspectRatio(_x) Gets or Sets the aspect ratio of the chart Parameters: Name Type Description _x Number Desired aspect ratio for the graph Source: line.js Returns: Current aspect ratio or Line Chart module to chain calls Type Number | Module &lt;static&gt; colorSchema(_x) Gets or Sets the colorSchema of the chart Parameters: Name Type Description _x Array.&lt;String&gt; Desired colorSchema for the graph Source: line.js Returns: Current colorSchema or Chart module to chain calls Type colorSchema | module &lt;static&gt; dateLabel(_x) Gets or Sets the dateLabel of the chart Parameters: Name Type Description _x Number Desired dateLabel for the graph Source: line.js Returns: Current dateLabel or Chart module to chain calls Type dateLabel | module &lt;static&gt; exportChart(filename, title) Chart exported to png and a download action is fired Parameters: Name Type Description filename String File title for the resulting picture title String Title to add at the top of the exported picture Source: line.js &lt;static&gt; grid(_x) Gets or Sets the grid mode. Parameters: Name Type Description _x String Desired mode for the grid ('vertical'|'horizontal'|'full') Source: line.js Returns: Current mode of the grid or Line Chart module to chain calls Type String | module &lt;static&gt; height(_x) Gets or Sets the height of the chart Parameters: Name Type Description _x Number Desired width for the graph Source: line.js Returns: Current height or Line Chart module to chain calls Type Number | Module &lt;static&gt; isAnimated(_x) Gets or Sets the isAnimated property of the chart, making it to animate when render. By default this is 'false' Parameters: Name Type Description _x Boolean Desired animation flag Source: line.js Returns: Current isAnimated flag or Chart module Type isAnimated | module &lt;static&gt; lineCurve(_x) Gets or Sets the curve of the line chart Parameters: Name Type Description _x curve Desired curve for the lines, default 'linear'. Other options are: basis, natural, monotoneX, monotoneY, step, stepAfter, stepBefore, cardinal, and catmullRom. Visit https://github.com/d3/d3-shape#curves for more information. Source: line.js Returns: Current line curve or Line Chart module to chain calls Type curve | Module &lt;static&gt; lineGradient(_x) Gets or Sets the gradient colors of the line chart when there is only one line Parameters: Name Type Description _x Array.&lt;String&gt; Desired color gradient for the line (array of two hexadecimal numbers) Source: line.js Returns: Current color gradient or Line Chart module to chain calls Type Number | Module &lt;static&gt; locale(_x) Pass language tag for the tooltip to localize the date. Feature uses Intl.DateTimeFormat, for compatability and support, refer to https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DateTimeFormat Parameters: Name Type Description _x String must be a language tag (BCP 47) like 'en-US' or 'fr-FR' Source: line.js Returns: Current locale or module to chain calls Type String | Module &lt;static&gt; margin(_x) Gets or Sets the margin of the chart Parameters: Name Type Description _x Object Margin object to get/set Source: line.js Returns: Current margin or Line Chart module to chain calls Type Number | Module &lt;static&gt; on() Exposes an 'on' method that acts as a bridge with the event dispatcher We are going to expose this events: customMouseHover, customMouseMove, customMouseOut and customDataEntryClick Source: line.js Returns: Bar Chart Type module &lt;static&gt; tooltipThreshold(_x) Gets or Sets the minimum width of the graph in order to show the tooltip NOTE: This could also depend on the aspect ratio Parameters: Name Type Description _x Number Desired tooltip threshold for the graph Source: line.js Returns: Current tooltip threshold or Line Chart module to chain calls Type Number | Module &lt;static&gt; topicLabel(_x) Gets or Sets the topicLabel of the chart Parameters: Name Type Description _x Number Desired topicLabel for the graph Source: line.js Returns: Current topicLabel or Chart module to chain calls Type topicLabel | module &lt;static&gt; valueLabel(_x) Gets or Sets the valueLabel of the chart Parameters: Name Type Description _x Number Desired valueLabel for the graph Source: line.js Returns: Current valueLabel or Chart module to chain calls Type valueLabel | module &lt;static&gt; width(_x) Gets or Sets the width of the chart Parameters: Name Type Description _x Number Desired width for the graph Source: line.js Returns: Current width or Line Chart module to chain calls Type Number | Module &lt;static&gt; xAxisCustomFormat(_x) Exposes the ability to force the chart to show a certain x format It requires a `xAxisFormat` of 'custom' in order to work. NOTE: localization not supported Parameters: Name Type Description _x String Desired format for x axis Source: line.js Returns: Current format or module to chain calls Type String | Module &lt;static&gt; xAxisFormat(_x) Exposes the ability to force the chart to show a certain x axis grouping Parameters: Name Type Description _x String Desired format Source: line.js Returns: Current format or module to chain calls Type String | Module Example line.xAxisFormat(line.axisTimeCombinations.HOUR_DAY) &lt;static&gt; xTicks(_x) Exposes the ability to force the chart to show a certain x ticks. It requires a `xAxisFormat` of 'custom' in order to work. NOTE: This value needs to be a multiple of 2, 5 or 10. They won't always work as expected, as D3 decides at the end how many and where the ticks will appear. Parameters: Name Type Description _x Number Desired number of x axis ticks (multiple of 2, 5 or 10) Source: line.js Returns: Current number or ticks or module to chain calls Type Number | Module &lt;static&gt; yTicks(_x) Gets or Sets the number of ticks of the y axis on the chart (Default is 5) Parameters: Name Type Description _x Number Desired yTicks Source: line.js Returns: Current yTicks or Chart module to chain calls Type Number | module × Search results Close "},"module-Mini-tooltip.html":{"id":"module-Mini-tooltip.html","title":"API: Mini-tooltip","body":" Getting started Demos Bar Chart Brush Chart Donut Chart Grouped Bar Chart Kitchen Sink Line Chart Sparkline Chart Stacked Area Chart Stacked Bar Chart Step Chart API Bar Brush Donut Grouped-bar Legend Line Mini-tooltip Sparkline Stacked-area Stacked-bar Step Tooltip Types Github Twitter API: Mini-tooltip Mini Tooltip Component reusable API class that renders a simple and configurable tooltip element for Britechart's bar and step chart. (require(&quot;Mini-tooltip&quot;))(_selection) This function creates the graph using the selection as container Parameters: Name Type Description _selection D3Selection A d3 selection that represents the container(s) where the chart(s) will be rendered Source: mini-tooltip.js Requires module:d3 Methods module:Mini-tooltip(_selection) This function creates the graph using the selection as container Parameters: Name Type Description _selection D3Selection A d3 selection that represents the container(s) where the chart(s) will be rendered Source: mini-tooltip.js &lt;static&gt; hide() Hides the tooltip Source: mini-tooltip.js Returns: Tooltip module to chain calls Type Module &lt;static&gt; nameLabel(_x) Gets or Sets data's nameLabel Parameters: Name Type Description _x text Desired nameLabel Source: mini-tooltip.js Returns: nameLabel or Step Chart module to chain calls Type text | module &lt;static&gt; show() Shows the tooltip Source: mini-tooltip.js Returns: Tooltip module to chain calls Type Module &lt;static&gt; title(_x) Gets or Sets the title of the tooltip Parameters: Name Type Description _x string Desired title Source: mini-tooltip.js Returns: Current title or module to chain calls Type string | module &lt;static&gt; update(dataPoint, mousePosition, chartSize) Updates the position and content of the tooltip Parameters: Name Type Description dataPoint Object Datapoint of the hovered element mousePosition Array Mouse position relative to the parent chart [x, y] chartSize Array Parent chart size [x, y] Source: mini-tooltip.js Returns: Current component Type module × Search results Close "},"module-Sparkline.html":{"id":"module-Sparkline.html","title":"API: Sparkline","body":" Getting started Demos Bar Chart Brush Chart Donut Chart Grouped Bar Chart Kitchen Sink Line Chart Sparkline Chart Stacked Area Chart Stacked Bar Chart Step Chart API Bar Brush Donut Grouped-bar Legend Line Mini-tooltip Sparkline Stacked-area Stacked-bar Step Tooltip Types Github Twitter API: Sparkline Sparkline Chart reusable API module that allows us rendering a sparkline configurable chart. (require(&quot;Sparkline&quot;))(_selection, _data) This function creates the graph using the selection and data provided Parameters: Name Type Description _selection D3Selection A d3 selection that represents the container(s) where the chart(s) will be rendered _data SparklineChartData The data to attach and generate the chart Source: sparkline.js Requires module:d3 Methods module:Sparkline(_selection, _data) This function creates the graph using the selection and data provided Parameters: Name Type Description _selection D3Selection A d3 selection that represents the container(s) where the chart(s) will be rendered _data SparklineChartData The data to attach and generate the chart Source: sparkline.js &lt;static&gt; areaGradient(_x) Gets or Sets the areaGradient of the chart Parameters: Name Type Description _x Array.&lt;String&gt; Desired areaGradient for the graph Source: sparkline.js Returns: Current areaGradient or Chart module to chain calls Type areaGradient | module &lt;static&gt; dateLabel(_x) Gets or Sets the dateLabel of the chart Parameters: Name Type Description _x Number Desired dateLabel for the graph Source: sparkline.js Returns: Current dateLabel or Chart module to chain calls Type dateLabel | module &lt;static&gt; duration(_x) Gets or Sets the duration of the animation Parameters: Name Type Description _x Number Desired animation duration for the graph Source: sparkline.js Returns: Current animation duration or Chart module to chain calls Type dateLabel | module &lt;static&gt; exportChart(filename, title) Chart exported to png and a download action is fired Parameters: Name Type Description filename String File title for the resulting picture title String Title to add at the top of the exported picture Source: sparkline.js &lt;static&gt; height(_x) Gets or Sets the height of the chart Parameters: Name Type Description _x Number Desired width for the graph Source: sparkline.js Returns: Current height or Chart module to chain calls Type height | module &lt;static&gt; isAnimated(_x) Gets or Sets the isAnimated property of the chart, making it to animate when render. By default this is 'false' Parameters: Name Type Description _x Boolean Desired animation flag Source: sparkline.js Returns: Current isAnimated flag or Chart module Type isAnimated | module &lt;static&gt; lineGradient(_x) Gets or Sets the lineGradient of the chart Parameters: Name Type Description _x Array.&lt;String&gt; Desired lineGradient for the graph Source: sparkline.js Returns: Current lineGradient or Chart module to chain calls Type lineGradient | module &lt;static&gt; margin(_x) Gets or Sets the margin of the chart Parameters: Name Type Description _x Object Margin object to get/set Source: sparkline.js Returns: Current margin or Chart module to chain calls Type margin | module &lt;static&gt; valueLabel(_x) Gets or Sets the valueLabel of the chart Parameters: Name Type Description _x Number Desired valueLabel for the graph Source: sparkline.js Returns: Current valueLabel or Chart module to chain calls Type valueLabel | module &lt;static&gt; width(_x) Gets or Sets the width of the chart Parameters: Name Type Description _x Number Desired width for the graph Source: sparkline.js Returns: Current width or Chart module to chain calls Type width | module × Search results Close "},"module-Stacked-area.html":{"id":"module-Stacked-area.html","title":"API: Stacked-area","body":" Getting started Demos Bar Chart Brush Chart Donut Chart Grouped Bar Chart Kitchen Sink Line Chart Sparkline Chart Stacked Area Chart Stacked Bar Chart Step Chart API Bar Brush Donut Grouped-bar Legend Line Mini-tooltip Sparkline Stacked-area Stacked-bar Step Tooltip Types Github Twitter API: Stacked-area Stacked Area Chart reusable API module that allows us rendering a multi area and configurable chart. (require(&quot;Stacked-area&quot;))(_selection, _data) This function creates the graph using the selection and data provided Parameters: Name Type Description _selection D3Selection A d3 selection that represents the container(s) where the chart(s) will be rendered _data areaChartData The data to attach and generate the chart Source: stacked-area.js Requires module:d3-array, Members &lt;static&gt; axisTimeCombinations Exposes the constants to be used to force the x axis to respect a certain granularity current options: MINUTE_HOUR, HOUR_DAY, DAY_MONTH, MONTH_YEAR Source: stacked-area.js Example area.xAxisFormat(area.axisTimeCombinations.HOUR_DAY) Methods module:Stacked-area(_selection, _data) This function creates the graph using the selection and data provided Parameters: Name Type Description _selection D3Selection A d3 selection that represents the container(s) where the chart(s) will be rendered _data areaChartData The data to attach and generate the chart Source: stacked-area.js &lt;static&gt; areaOpacity(_x) Gets or Sets the opacity of the stacked areas in the chart (all of them will have the same opacity) Parameters: Name Type Description _x Object Opacity to get/set Source: stacked-area.js Returns: Current opacity or Area Chart module to chain calls Type opacity | module &lt;static&gt; aspectRatio(_x) Gets or Sets the aspect ratio of the chart Parameters: Name Type Description _x Number Desired aspect ratio for the graph Source: stacked-area.js Returns: Current aspect ratio or Area Chart module to chain calls Type Number | Module &lt;static&gt; colorSchema(_x) Gets or Sets the colorSchema of the chart Parameters: Name Type Description _x Array.&lt;String&gt; Desired colorSchema for the graph Source: stacked-area.js Returns: Current colorSchema or Chart module to chain calls Type colorSchema | module &lt;static&gt; dateLabel(_x) Gets or Sets the dateLabel of the chart Parameters: Name Type Description _x Number Desired dateLabel for the graph Source: stacked-area.js Returns: Current dateLabel or Chart module to chain calls Type dateLabel | module &lt;static&gt; emptyDataConfig(_x) Gets or Sets the emptyDataConfig of the chart Parameters: Name Type Description _x Object emptyDataConfig object to get/set Source: stacked-area.js Returns: Current config for when chart data is an empty array Type Object | module &lt;static&gt; exportChart(filename, title) Chart exported to png and a download action is fired Parameters: Name Type Description filename String File title for the resulting picture title String Title to add at the top of the exported picture Source: stacked-area.js &lt;static&gt; grid(_x) Gets or Sets the grid mode. Parameters: Name Type Description _x String Desired mode for the grid ('vertical'|'horizontal'|'full') Source: stacked-area.js Returns: Current mode of the grid or Area Chart module to chain calls Type String | module &lt;static&gt; height(_x) Gets or Sets the height of the chart Parameters: Name Type Description _x Number Desired width for the graph Source: stacked-area.js Returns: Current height or Area Chart module to chain calls Type height | module &lt;static&gt; isAnimated(_x) Gets or Sets the isAnimated property of the chart, making it to animate when render. By default this is 'false' Parameters: Name Type Description _x Boolean Desired animation flag Source: stacked-area.js Returns: Current isAnimated flag or Chart module Type isAnimated | module &lt;static&gt; keyLabel(_x) Gets or Sets the keyLabel of the chart Parameters: Name Type Description _x Number Desired keyLabel for the graph Source: stacked-area.js Returns: Current keyLabel or Chart module to chain calls Type keyLabel | module &lt;static&gt; locale(_x) Pass language tag for the tooltip to localize the date. Feature uses Intl.DateTimeFormat, for compatability and support, refer to https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DateTimeFormat Parameters: Name Type Description _x String must be a language tag (BCP 47) like 'en-US' or 'fr-FR' Source: stacked-area.js Returns: Current locale or module to chain calls Type String | Module &lt;static&gt; margin(_x) Gets or Sets the margin of the chart Parameters: Name Type Description _x Object Margin object to get/set Source: stacked-area.js Returns: Current margin or Area Chart module to chain calls Type margin | module &lt;static&gt; on() Exposes an 'on' method that acts as a bridge with the event dispatcher We are going to expose this events: customMouseOver, customMouseMove, customMouseOut and customDataEntryClick Source: stacked-area.js Returns: Bar Chart Type module &lt;static&gt; tooltipThreshold(_x) Gets or Sets the minimum width of the graph in order to show the tooltip NOTE: This could also depend on the aspect ratio Parameters: Name Type Description _x Object Margin object to get/set Source: stacked-area.js Returns: Current tooltipThreshold or Area Chart module to chain calls Type tooltipThreshold | module &lt;static&gt; topicsOrder(_x) Pass an override for the ordering of the topics Parameters: Name Type Description _x Array.&lt;String&gt; Array of the names of your tooltip items Source: stacked-area.js Returns: Current override order or Chart module to chain calls Type Array.&lt;String&gt; | module &lt;static&gt; valueLabel(_x) Gets or Sets the valueLabel of the chart Parameters: Name Type Description _x Number Desired valueLabel for the graph Source: stacked-area.js Returns: Current valueLabel or Chart module to chain calls Type valueLabel | module &lt;static&gt; width(_x) Gets or Sets the width of the chart Parameters: Name Type Description _x Number Desired width for the graph Source: stacked-area.js Returns: Current width or Area Chart module to chain calls Type Number | module &lt;static&gt; xAxisCustomFormat(_x) Exposes the ability to force the chart to show a certain x format It requires a `xAxisFormat` of 'custom' in order to work. NOTE: localization not supported Parameters: Name Type Description _x String Desired format for x axis Source: stacked-area.js Returns: Current format or module to chain calls Type String | Module &lt;static&gt; xAxisFormat(_x) Exposes the ability to force the chart to show a certain x axis grouping Parameters: Name Type Description _x String Desired format Source: stacked-area.js Returns: Current format or module to chain calls Type String | Module Example area.xAxisFormat(area.axisTimeCombinations.HOUR_DAY) &lt;static&gt; xTicks(_x) Exposes the ability to force the chart to show a certain x ticks. It requires a `xAxisFormat` of 'custom' in order to work. NOTE: This value needs to be a multiple of 2, 5 or 10. They won't always work as expected, as D3 decides at the end how many and where the ticks will appear. Parameters: Name Type Description _x Number Desired number of x axis ticks (multiple of 2, 5 or 10) Source: stacked-area.js Returns: Current number or ticks or module to chain calls Type Number | Module &lt;static&gt; yTicks(_x) Gets or Sets the number of ticks of the y axis on the chart (Default is 5) Parameters: Name Type Description _x Number Desired vertical ticks Source: stacked-area.js Returns: Current vertical ticks or Chart module to chain calls Type Number | module × Search results Close "},"module-Stacked-bar.html":{"id":"module-Stacked-bar.html","title":"API: Stacked-bar","body":" Getting started Demos Bar Chart Brush Chart Donut Chart Grouped Bar Chart Kitchen Sink Line Chart Sparkline Chart Stacked Area Chart Stacked Bar Chart Step Chart API Bar Brush Donut Grouped-bar Legend Line Mini-tooltip Sparkline Stacked-area Stacked-bar Step Tooltip Types Github Twitter API: Stacked-bar Stacked Area Chart reusable API module that allows us rendering a multi area and configurable chart. (require(&quot;Stacked-bar&quot;))(_selection, _data) This function creates the graph using the selection and data provided Parameters: Name Type Description _selection D3Selection A d3 selection that represents the container(s) where the chart(s) will be rendered _data stackedBarData The data to attach and generate the chart Source: stacked-bar.js Requires module:d3-array, Methods module:Stacked-bar(_selection, _data) This function creates the graph using the selection and data provided Parameters: Name Type Description _selection D3Selection A d3 selection that represents the container(s) where the chart(s) will be rendered _data stackedBarData The data to attach and generate the chart Source: stacked-bar.js &lt;static&gt; aspectRatio(_x) Gets or Sets the aspect ratio of the chart Parameters: Name Type Description _x Number Desired aspect ratio for the graph Source: stacked-bar.js Returns: Current aspect ratio or Area Chart module to chain calls Type Number | Module &lt;static&gt; colorSchema(_x) Gets or Sets the colorSchema of the chart Parameters: Name Type Description _x Array.&lt;String&gt; Desired colorSchema for the graph Source: stacked-bar.js Returns: Current colorSchema or Chart module to chain calls Type colorSchema | module &lt;static&gt; exportChart(filename, title) Chart exported to png and a download action is fired Parameters: Name Type Description filename String File title for the resulting picture title String Title to add at the top of the exported picture Source: stacked-bar.js &lt;static&gt; grid(_x) Gets or Sets the grid mode. Parameters: Name Type Description _x String Desired mode for the grid ('vertical'|'horizontal'|'full') Source: stacked-bar.js Returns: Current mode of the grid or Area Chart module to chain calls Type String | module &lt;static&gt; height(_x) Gets or Sets the height of the chart Parameters: Name Type Description _x Number Desired width for the graph Source: stacked-bar.js Returns: Current height or Area Chart module to chain calls Type height | module &lt;static&gt; isAnimated(_x) Gets or Sets the isAnimated property of the chart, making it to animate when render. By default this is 'false' Parameters: Name Type Description _x Boolean Desired animation flag Source: stacked-bar.js Returns: Current isAnimated flag or Chart module Type isAnimated | module &lt;static&gt; isHorizontal(_x) Gets or Sets the horizontal direction of the chart Parameters: Name Type Description _x number Desired horizontal direction for the graph Source: stacked-bar.js Returns: If it is horizontal or Bar Chart module to chain calls Type isHorizontal | module &lt;static&gt; locale(_x) Pass language tag for the tooltip to localize the date. Feature uses Intl.DateTimeFormat, for compatability and support, refer to https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DateTimeFormat Parameters: Name Type Description _x String must be a language tag (BCP 47) like 'en-US' or 'fr-FR' Source: stacked-bar.js Returns: Current locale or module to chain calls Type String | Module &lt;static&gt; margin(_x) Gets or Sets the margin of the chart Parameters: Name Type Description _x Object Margin object to get/set Source: stacked-bar.js Returns: Current margin or Area Chart module to chain calls Type margin | module &lt;static&gt; nameLabel(_x) Gets or Sets the nameLabel of the chart Parameters: Name Type Description _x Number Desired dateLabel for the graph Source: stacked-bar.js Returns: Current nameLabel or Chart module to chain calls Type nameLabel | module &lt;static&gt; nameLabelFormat(_x) Gets or Sets the valueLabelFormat of the chart Parameters: Name Type Description _x Array.&lt;String&gt; Desired valueLabelFormat for the graph Source: stacked-bar.js Returns: Current valueLabelFormat or Chart module to chain calls Type valueLabelFormat | module &lt;static&gt; on() Exposes an 'on' method that acts as a bridge with the event dispatcher We are going to expose this events: customMouseOver, customMouseMove and customMouseOut Source: stacked-bar.js Returns: Bar Chart Type module &lt;static&gt; percentageAxisToMaxRatio(_x) Configurable extension of the x axis if your max point was 50% you might want to show x axis to 60%, pass 1.2 Parameters: Name Type Description _x number ratio to max data point to add to the x axis Source: stacked-bar.js Returns: Current ratio or Bar Chart module to chain calls Type ratio | module &lt;static&gt; stackLabel(_x) Gets or Sets the stackLabel of the chart Parameters: Name Type Description _x String Desired stackLabel for the graph Source: stacked-bar.js Returns: Current stackLabel or Chart module to chain calls Type stackLabel | module &lt;static&gt; tooltipThreshold(_x) Gets or Sets the minimum width of the graph in order to show the tooltip NOTE: This could also depend on the aspect ratio Parameters: Name Type Description _x Object Margin object to get/set Source: stacked-bar.js Returns: Current tooltipThreshold or Area Chart module to chain calls Type tooltipThreshold | module &lt;static&gt; valueLabel(_x) Gets or Sets the valueLabel of the chart Parameters: Name Type Description _x Number Desired valueLabel for the graph Source: stacked-bar.js Returns: Current valueLabel or Chart module to chain calls Type valueLabel | module &lt;static&gt; valueLabelFormat(_x) Gets or Sets the valueLabelFormat of the chart Parameters: Name Type Description _x Array.&lt;String&gt; Desired valueLabelFormat for the graph Source: stacked-bar.js Returns: Current valueLabelFormat or Chart module to chain calls Type valueLabelFormat | module &lt;static&gt; width(_x) Gets or Sets the width of the chart Parameters: Name Type Description _x Number Desired width for the graph Source: stacked-bar.js Returns: Current width or Area Chart module to chain calls Type width | module &lt;static&gt; xTicks(_x) Gets or Sets the number of ticks of the x axis on the chart (Default is 5) Parameters: Name Type Description _x Number Desired horizontal ticks Source: stacked-bar.js Returns: Current xTicks or Chart module to chain calls Type Number | module &lt;static&gt; yTicks(_x) Gets or Sets the number of vertical ticks of the axis on the chart Parameters: Name Type Description _x Number Desired vertical ticks Source: stacked-bar.js Returns: Current yTicks or Chart module to chain calls Type Number | module × Search results Close "},"module-Step.html":{"id":"module-Step.html","title":"API: Step","body":" Getting started Demos Bar Chart Brush Chart Donut Chart Grouped Bar Chart Kitchen Sink Line Chart Sparkline Chart Stacked Area Chart Stacked Bar Chart Step Chart API Bar Brush Donut Grouped-bar Legend Line Mini-tooltip Sparkline Stacked-area Stacked-bar Step Tooltip Types Github Twitter API: Step Step Chart reusable API class that renders a simple and configurable step chart. (require(&quot;Step&quot;))(_selection, _data) This function creates the graph using the selection as container Parameters: Name Type Description _selection D3Selection A d3 selection that represents the container(s) where the chart(s) will be rendered _data StepChartData The data to attach and generate the chart Source: step.js Requires module:d3-array, Methods module:Step(_selection, _data) This function creates the graph using the selection as container Parameters: Name Type Description _selection D3Selection A d3 selection that represents the container(s) where the chart(s) will be rendered _data StepChartData The data to attach and generate the chart Source: step.js &lt;static&gt; exportChart(filename, title) Chart exported to png and a download action is fired Parameters: Name Type Description filename String File title for the resulting picture title String Title to add at the top of the exported picture Source: step.js &lt;static&gt; height(_x) Gets or Sets the height of the chart Parameters: Name Type Description _x number Desired width for the graph Source: step.js Returns: Current height or Chart module to chain calls Type height | module &lt;static&gt; margin(_x) Gets or Sets the margin of the chart Parameters: Name Type Description _x object Margin object to get/set Source: step.js Returns: Current margin or Chart module to chain calls Type margin | module &lt;static&gt; on() Exposes an 'on' method that acts as a bridge with the event dispatcher We are going to expose this events: customMouseOver, customMouseMove and customMouseOut Source: step.js Returns: Bar Chart Type module &lt;static&gt; width(_x) Gets or Sets the width of the chart Parameters: Name Type Description _x number Desired width for the graph Source: step.js Returns: Current width or Chart module to chain calls Type width | module &lt;static&gt; xAxisLabel(_x) Gets or Sets the text of the xAxisLabel on the chart Parameters: Name Type Description _x text Desired text for the label Source: step.js Returns: label or Chart module to chain calls Type text | module &lt;static&gt; xAxisLabelOffset(_x) Gets or Sets the offset of the xAxisLabel on the chart Parameters: Name Type Description _x integer Desired offset for the label Source: step.js Returns: label or Chart module to chain calls Type integer | module &lt;static&gt; yAxisLabel(_x) Gets or Sets the text of the yAxisLabel on the chart Parameters: Name Type Description _x text Desired text for the label Source: step.js Returns: label or Chart module to chain calls Type text | module &lt;static&gt; yAxisLabelOffset(_x) Gets or Sets the offset of the yAxisLabel on the chart Parameters: Name Type Description _x integer Desired offset for the label Source: step.js Returns: label or Chart module to chain calls Type integer | module &lt;static&gt; yTicks(_x) Gets or Sets the number of vertical ticks on the chart (Default is 6) Parameters: Name Type Description _x Number Desired number of vertical ticks for the graph Source: step.js Returns: Current yTicks or Chart module to chain calls Type Number | module × Search results Close "},"module-Tooltip.html":{"id":"module-Tooltip.html","title":"API: Tooltip","body":" Getting started Demos Bar Chart Brush Chart Donut Chart Grouped Bar Chart Kitchen Sink Line Chart Sparkline Chart Stacked Area Chart Stacked Bar Chart Step Chart API Bar Brush Donut Grouped-bar Legend Line Mini-tooltip Sparkline Stacked-area Stacked-bar Step Tooltip Types Github Twitter API: Tooltip Tooltip Component reusable API class that renders a simple and configurable tooltip element for Britechart's line chart or stacked area chart. (require(&quot;Tooltip&quot;))(_selection, _data) This function creates the graph using the selection as container Parameters: Name Type Description _selection D3Selection A d3 selection that represents the container(s) where the chart(s) will be rendered _data Object The data to attach and generate the chart Source: tooltip.js Requires module:d3-array, Members &lt;static&gt; axisTimeCombinations constants to be used to force the x axis to respect a certain granularity current options: HOUR_DAY, DAY_MONTH, MONTH_YEAR Source: tooltip.js Example tooltip.dateFormat(tooltip.axisTimeCombinations.HOUR_DAY) Methods module:Tooltip(_selection, _data) This function creates the graph using the selection as container Parameters: Name Type Description _selection D3Selection A d3 selection that represents the container(s) where the chart(s) will be rendered _data Object The data to attach and generate the chart Source: tooltip.js &lt;static&gt; dateFormat(_x) Exposes the ability to force the tooltip to use a certain date format Parameters: Name Type Description _x String Desired format Source: tooltip.js Returns: Current format or module to chain calls Type String | Module &lt;static&gt; dateLabel(_x) Gets or Sets the dateLabel of the data Parameters: Name Type Description _x String Desired dateLabel Source: tooltip.js Returns: Current dateLabel or Chart module to chain calls Type String | module &lt;static&gt; hide() Hides the tooltip Source: tooltip.js Returns: Tooltip module to chain calls Type Module &lt;static&gt; locale(_x) Pass locale for the tooltip to render the date in Parameters: Name Type Description _x String Must be a locale tag like 'en-US' or 'fr-FR' Source: tooltip.js Returns: Current locale or module to chain calls Type String | Module &lt;static&gt; nameLabel(_x) Gets or Sets the nameLabel of the data Parameters: Name Type Description _x String Desired nameLabel Source: tooltip.js Returns: Current nameLabel or Chart module to chain calls Type String | module &lt;static&gt; shouldShowDateInTitle(_x) Gets or Sets shouldShowDateInTitle Parameters: Name Type Description _x Boolean Desired value Source: tooltip.js Returns: Current shouldShowDateInTitle or Chart module to chain calls Type shouldShowDateInTitle | module &lt;static&gt; shouldShowDateInTitle(_x) Gets or Sets shouldShowDateInTitle Parameters: Name Type Description _x Boolean Desired value Source: tooltip.js Returns: Current shouldShowDateInTitle or Chart module to chain calls Type Boolean | module &lt;static&gt; show() Shows the tooltip Source: tooltip.js Returns: Tooltip module to chain calls Type Module &lt;static&gt; title(_x) Gets or Sets the title of the tooltip Parameters: Name Type Description _x String Desired title Source: tooltip.js Returns: Current title or module to chain calls Type String | module &lt;static&gt; topicLabel(_x) Gets or Sets the topicLabel of the data Parameters: Name Type Description _x String Desired topicLabel Source: tooltip.js Returns: Current topicLabel or Chart module to chain calls Type String | module &lt;static&gt; topicsOrder(_x) Pass an override for the ordering of your tooltip Parameters: Name Type Description _x Array.&lt;Object&gt; Array of the names of your tooltip items Source: tooltip.js Returns: Current overrideOrder or Chart module to chain calls Type Array.&lt;Object&gt; | module &lt;static&gt; topicsOrder(_x) Pass an override for the ordering of your tooltip Parameters: Name Type Description _x Array.&lt;String&gt; Array of the names of your tooltip items Source: tooltip.js Returns: Current overrideOrder or Chart module to chain calls Type Array.&lt;String&gt; | module &lt;static&gt; update(dataPoint, colorMapping, position) Updates the position and content of the tooltip Parameters: Name Type Description dataPoint Object Datapoint to represent colorMapping Object Color scheme of the topics position Number X-scale position in pixels Source: tooltip.js Returns: Tooltip module to chain calls Type Module &lt;static&gt; valueFormat(_x) Gets or Sets the valueFormat of the tooltip Parameters: Name Type Description _x String Desired valueFormat Source: tooltip.js Returns: Current valueFormat or module to chain calls Type String | module &lt;static&gt; valueLabel(_x) Gets or Sets the valueLabel of the data Parameters: Name Type Description _x String Desired valueLabel Source: tooltip.js Returns: Current valueLabel or Chart module to chain calls Type String | module × Search results Close "},"tutorial-bar.html":{"id":"tutorial-bar.html","title":"Tutorial: Bar Chart","body":" Getting started Demos Bar Chart Brush Chart Donut Chart Grouped Bar Chart Kitchen Sink Line Chart Sparkline Chart Stacked Area Chart Stacked Bar Chart Step Chart API Bar Brush Donut Grouped-bar Legend Line Mini-tooltip Sparkline Stacked-area Stacked-bar Step Tooltip Types Github Twitter Bar Chart Bar Chart with Tooltip The code barChart .width(containerWidth) .height(300) .hasPercentage(true) .isAnimated(true) .on('customMouseOver', tooltip.show) .on('customMouseMove', tooltip.update) .on('customMouseOut', tooltip.hide); barContainer.datum(dataset).call(barChart); tooltipContainer = d3.select('.bar-chart .metadata-group'); tooltipContainer.datum([]).call(tooltip); Data Input Check the data input schema of this chart. Export Chart Export this chart by pressing Demo Code Read the whole code of this demo in github Horizontal Bar Chart The code barChart .margin({ left: 120, right: 20, top: 20, bottom: 5 }) .percentageAxisToMaxRatio(1.3) .isHorizontal(true) .isAnimated(true) .colorSchema(colors.colorSchemas.britecharts) .width(containerWidth) .height(300); barContainer.datum(dataset).call(barChart); Demo Code Read the whole code of this demo in github Simple Bar Chart The code barChart .width(containerWidth) .height(300); barContainer.datum(dataset).call(barChart); Demo Code Read the whole code of this demo in github × Search results Close "},"tutorial-brush.html":{"id":"tutorial-brush.html","title":"Tutorial: Brush Chart","body":" Getting started Demos Bar Chart Brush Chart Donut Chart Grouped Bar Chart Kitchen Sink Line Chart Sparkline Chart Stacked Area Chart Stacked Bar Chart Step Chart API Bar Brush Donut Grouped-bar Legend Line Mini-tooltip Sparkline Stacked-area Stacked-bar Step Tooltip Types Github Twitter Brush Chart Simple Brush Chart Selected from to Brush chart to use with other charts as a time range selector. The code brushChart .width(containerWidth) .height(300) .on('customBrushStart', function(brushExtent) { // Do something with the brushExtent }); brushContainer.datum(dataset).call(brushChart); Data Input Check the data input schema of this chart. Demo Code Read the whole code of this demo in github × Search results Close "},"tutorial-donut.html":{"id":"tutorial-donut.html","title":"Tutorial: Donut Chart","body":" Small Donut Chart with Inline Legend The code donutChart .width(containerWidth) .height(containerWidth/1.8) .externalRadius(containerWidth/5) .internalRadius(containerWidth/10) .on('customMouseOver', function(data) { legendChart.highlight(data.data.id); }) .on('customMouseOut', function() { legendChart.clearHighlight(); }); donutContainer.datum(dataset).call(donutChart); Demo Code Read the whole code of this demo in github Donut Chart with fixed higlighted slice The code donutChart .highlightSliceById(1) .hasFixedHighlightedSlice(true) .width(containerWidth) .height(containerWidth/1.8) .externalRadius(containerWidth/5) .internalRadius(containerWidth/10); donutContainer.datum(dataset).call(donutChart); Demo Code Read the whole code of this demo in github × Search results Close "},"tutorial-grouped-bar.html":{"id":"tutorial-grouped-bar.html","title":"Tutorial: Grouped Bar Chart","body":" Grouped Bar Chart with Tooltip The code groupedBar .tooltipThreshold(400) .width(containerWidth) .isAnimated(true) .valueLabel('views') .groupLabel('stack') .nameLabel('date') .on('customMouseOver', chartTooltip.show) .on('customMouseMove', function(dataPoint, topicColorMap, dataPointXPosition) { chartTooltip.update(dataPoint, topicColorMap, dataPointXPosition); }) .on('customMouseOut', chartTooltip.hide); container.datum(dataset.data).call(groupedBar); chartTooltip .title('Testing tooltip'); tooltipContainer = d3.select('.metadata-group'); tooltipContainer.datum([]).call(chartTooltip); Colors You can also check other color schemas: Data Input Check the data input schema of this chart. Export Chart You can also export this chart by pressing: Demo Code Read the whole code of this demo in github Horizontal Grouped Bar Chart The code // groupedBarChart Setup and start groupedBar .isHorizontal(true) .tooltipThreshold(400) .width(containerWidth) .valueLabel('views') .groupLabel('stack') .isAnimated(true) .margin({ left: 80, top: 0, right: 0, bottom: 20 }) .nameLabel('date') .on('customMouseOver', function() { chartTooltip.show(); }) .on('customMouseMove', function(dataPoint, topicColorMap, dataPointXPosition) { chartTooltip.update(dataPoint, topicColorMap, dataPointXPosition); }) .on('customMouseOut', function() { chartTooltip.hide(); }); container.datum(dataset.data).call(groupedBar); // Tooltip Setup and start chartTooltip .title('Dummy Tooltip Title'); // Note that if the viewport width is less than the tooltipThreshold value, // this container won't exist, and the tooltip won't show up tooltipContainer = d3.select('.metadata-group'); tooltipContainer.datum([]).call(chartTooltip); Demo Code Read the whole code of this demo in github × Search results Close "},"tutorial-kitchen-sink.html":{"id":"tutorial-kitchen-sink.html","title":"Tutorial: Kitchen Sink","body":" Bar Chart Horizontal Bar Chart Line Chart Donut Chart Brush Chart Selected from to Step Chart Stacked Area Chart Grouped Bar Chart with Tooltip Horizontal Stacked Bar Chart × Search results Close "},"tutorial-line.html":{"id":"tutorial-line.html","title":"Tutorial: Line Chart","body":" Getting started Demos Bar Chart Brush Chart Donut Chart Grouped Bar Chart Kitchen Sink Line Chart Sparkline Chart Stacked Area Chart Stacked Bar Chart Step Chart API Bar Brush Donut Grouped-bar Legend Line Mini-tooltip Sparkline Stacked-area Stacked-bar Step Tooltip Types Github Twitter Line Chart Line Chart with fixed Aspect Ratio Selected from to The code lineChart .isAnimated(true) .aspectRatio(0.5) .grid('horizontal') .tooltipThreshold(600) .width(containerWidth) .dateLabel('fullDate') .on('customMouseOver', chartTooltip.show) .on('customMouseMove', chartTooltip.update) .on('customMouseOut', chartTooltip.hide); container.datum(dataset).call(lineChart); Colors You can also check other color schemas: Data Input Check the data input schema of this chart. Export Chart You can also export this chart by pressing: Demo Code Read the whole code of this demo in github Line Chart with a single data source This is the same chart as above, but when there is a single data source we apply a gradient to the line to give it a little flair. This chart has a fixed height like the one below. The code lineChart .tooltipThreshold(600) .height(300) .lineCurve('basis') .grid('vertical') .width(containerWidth); container.datum(dataset).call(lineChart); Export Chart You can also export this chart by pressing: Demo Code Read the whole code of this demo in github Line Chart with Fixed Height In this case, we have set a fixed height on the chart, as we are currently doing on the Sales report: The code lineChart .tooltipThreshold(600) .height(300) .width(containerWidth) .grid('full'); container.datum(dataset).call(lineChart); Demo Code Read the whole code of this demo in github × Search results Close "},"tutorial-sparkline.html":{"id":"tutorial-sparkline.html","title":"Tutorial: Sparkline Chart","body":" Getting started Demos Bar Chart Brush Chart Donut Chart Grouped Bar Chart Kitchen Sink Line Chart Sparkline Chart Stacked Area Chart Stacked Bar Chart Step Chart API Bar Brush Donut Grouped-bar Legend Line Mini-tooltip Sparkline Stacked-area Stacked-bar Step Tooltip Types Github Twitter Sparkline Chart Sparkline Chart This is the sparkline chart used for showing trends in data over time. We have included a resize listener to show how the different charts respond to changes on the viewport. The code sparklineChart .dateLabel('dateUTC') .isAnimated(true) .duration(2500) .height(containerWidth / 3) .width(containerWidth / 2); container.datum(dataset) .call(sparklineChart); Data Input Check the data input schema of this chart. Export Chart You can also export this chart by pressing: Demo Code Read the whole code of this demo in github × Search results Close "},"tutorial-stacked-area.html":{"id":"tutorial-stacked-area.html","title":"Tutorial: Stacked Area Chart","body":" Stacked Area Chart with fixed Aspect Ratio The code stackedArea .tooltipThreshold(600) .aspectRatio(0.6) .grid('full') .xAxisFormat('custom') .xAxisCustomFormat('%Y/%m/%d') .xTicks(2) .width(containerWidth) .dateLabel('date') .valueLabel('views') .on('customMouseOver', chartTooltip.show) .on('customMouseMove', chartTooltip.update) .on('customMouseOut', chartTooltip.hide); container.datum(dataset.data).call(stackedArea); // Tooltip Setup and start chartTooltip .topicLabel('values') .title('Tooltip Title'); // Note that if the viewport width is less than the tooltipThreshold value, // this container won't exist, and the tooltip won't show up tooltipContainer = d3Selection.select('.js-stacked-area-chart-fixed-container .metadata-group .vertical-marker-container'); tooltipContainer.datum([]).call(chartTooltip); Demo Code Read the whole code of this demo in github Stacked Area Chart with custom stack order The code stackedArea .tooltipThreshold(600) .aspectRatio(0.6) .grid('full') .xAxisFormat('custom') .xAxisCustomFormat('%Y/%m/%d') .xTicks(2) .width(containerWidth) .dateLabel('date') .valueLabel('views') .on('customMouseOver', chartTooltip.show) .on('customMouseMove', chartTooltip.update) .on('customMouseOut', chartTooltip.hide); container.datum(dataset.data).call(stackedArea); // Tooltip Setup and start chartTooltip .topicLabel('values') .title('Tooltip Title'); // Note that if the viewport width is less than the tooltipThreshold value, // this container won't exist, and the tooltip won't show up tooltipContainer = d3Selection.select('.js-stacked-area-chart-fixed-container .metadata-group .vertical-marker-container'); tooltipContainer.datum([]).call(chartTooltip); Demo Code Read the whole code of this demo in github × Search results Close "},"tutorial-stacked-bar.html":{"id":"tutorial-stacked-bar.html","title":"Tutorial: Stacked Bar Chart","body":" Stacked Bar Chart with Tooltip The code stackedBar .tooltipThreshold(400) .width(containerWidth) .isAnimated(true) .valueLabel('views') .stackLabel('stack') .nameLabel('date') .on('customMouseOver', chartTooltip.show) .on('customMouseMove', function(dataPoint, topicColorMap, dataPointXPosition) { chartTooltip.update(dataPoint, topicColorMap, dataPointXPosition); }) .on('customMouseOut', chartTooltip.hide); container.datum(dataset.data).call(stackedBar); chartTooltip .title('Testing tooltip'); tooltipContainer = d3.select('.metadata-group'); tooltipContainer.datum([]).call(chartTooltip); Colors You can also check other color schemas: Data Input Check the data input schema of this chart. Export Chart You can also export this chart by pressing: Demo Code Read the whole code of this demo in github Horizontal Stacked Bar Chart The code // StackedBarChart Setup and start stackedBar .isHorizontal(true) .tooltipThreshold(400) .width(containerWidth) .valueLabel('views') .stackLabel('stack') .isAnimated(true) .margin({ left: 80, top: 0, right: 0, bottom: 20 }) .nameLabel('date') .on('customMouseOver', function() { chartTooltip.show(); }) .on('customMouseMove', function(dataPoint, topicColorMap, x, y) { chartTooltip.update(dataPoint, topicColorMap, x, y); }) .on('customMouseOut', function() { chartTooltip.hide(); }); container.datum(dataset.data).call(stackedBar); // Tooltip Setup and start chartTooltip .title('Dummy Tooltip Title'); // Note that if the viewport width is less than the tooltipThreshold value, // this container won't exist, and the tooltip won't show up tooltipContainer = d3.select('.metadata-group'); tooltipContainer.datum([]).call(chartTooltip); Demo Code Read the whole code of this demo in github × Search results Close "},"tutorial-step.html":{"id":"tutorial-step.html","title":"Tutorial: Step Chart","body":" Getting started Demos Bar Chart Brush Chart Donut Chart Grouped Bar Chart Kitchen Sink Line Chart Sparkline Chart Stacked Area Chart Stacked Bar Chart Step Chart API Bar Brush Donut Grouped-bar Legend Line Mini-tooltip Sparkline Stacked-area Stacked-bar Step Tooltip Types Github Twitter Step Chart Step Chart The code // StepChart without Axis Labels: stepChart .width(500) .height(300); stepContainer.datum(dataset).call(stepChart); // StepChart with Axis Labels: // If the labels get cutoff when added, it's a good idea // to tweak the left margin to get the look you want stepChart .width(500) .height(300) .xAxisLabel('Fruit Type') .xAxisLabelOffset(45) .yAxisLabel('Quantity') .yAxisLabelOffset(-45) .margin({ top: 20, right: 20, bottom: 30, left: 65 }); stepContainer.datum(dataset).call(stepChart); Data Input Check the data input schema of this chart. Export Chart You can also export this chart by pressing: Demo Code Read the whole code of this demo in github × Search results Close "}}
    </script>

    <script type="text/javascript">
        $(document).ready(function() {
            Searcher.init();
        });

        $(window).on("message", function(msg) {
            var msgData = msg.originalEvent.data;

            if (msgData.msgid != "docstrap.quicksearch.start") {
                return;
            }

            var results = Searcher.search(msgData.searchTerms);

            window.parent.postMessage({"results": results, "msgid": "docstrap.quicksearch.done"}, "*");
        });
    </script>
</body>
</html>
