<html>
<head>
</head>
<body style="background: transparent;">
    <script src="scripts/docstrap.lib.js"></script>
    <script src="scripts/lunr.min.js"></script>
    <script src="scripts/fulltext-search.js"></script>

    <script type="text/x-docstrap-searchdb">
    {"stacked-area.js.html":{"id":"stacked-area.js.html","title":"Source: stacked-area.js","body":" API BarBrushDonutLegendLineMini-tooltipSparklineStacked-areaStepTooltip Demos _GETTINGSTARTEDbarbrushdonutkitchen-sinklinesparklinestacked-areastep Global Global Source: stacked-area.js define(function(require){ 'use strict'; const d3Array = require('d3-array'); const d3Axis = require('d3-axis'); const d3Collection = require('d3-collection'); const d3Dispatch = require('d3-dispatch'); const d3Ease = require('d3-ease'); const d3Format = require('d3-format'); const d3Scale = require('d3-scale'); const d3Shape = require('d3-shape'); const d3Selection = require('d3-selection'); const d3Time = require('d3-time'); const d3TimeFormat = require('d3-time-format'); const d3Transition = require('d3-transition'); const _ = require('underscore'); const colorHelper = require('./helpers/colors'); const exportChart = require('./helpers/exportChart'); const ONE_AND_A_HALF_YEARS = 47304000000; const ONE_DAY = 86400001; const uniq = (arrArg) =&gt; arrArg.filter((elem, pos, arr) =&gt; arr.indexOf(elem) == pos); /** * @typdef D3Layout * @type function */ /** * @typedef areaChartData * @type {Object} * @property {Object[]} data All data entries * @property {String} date Date of the entry * @property {String} name Name of the entry * @property {Number} value Value of the entry * * @example * { * 'data': [ * { * &quot;date&quot;: &quot;2011-01-05T00:00:00Z&quot;, * &quot;name&quot;: &quot;Direct&quot;, * &quot;value&quot;: 0 * } * ] * } */ /** * Stacked Area Chart reusable API module that allows us * rendering a multi area and configurable chart. * * @module Stacked-area * @tutorial stacked-area * @requires d3-array, d3-axis, d3-collection, d3-ease, d3-scale, d3-shape, d3-selection, d3-time, d3-time-format * * @example * let stackedArea = stackedArea(); * * stackedArea * .width(containerWidth); * * d3Selection.select('.css-selector') * .datum(dataset.data) * .call(stackedArea); * */ return function module() { let margin = { top: 70, right: 30, bottom: 60, left: 70 }, width = 960, height = 500, xScale, xAxis, xMonthAxis, yScale, yAxis, aspectRatio = null, monthAxisPadding = 30, numVerticalTicks = 5, yTickTextYOffset = -8, yTickTextXOffset = 40, tickPadding = 5, colorSchema = colorHelper.colorSchemas.britechartsColorSchema, colorOrder = colorSchema .reduce((acc, color, index) =&gt; { acc[color] = index; return acc; }, {}), areaOpacity = 0.8, colorScale, categoryColorMap, layers, layersInitial, area, // Area Animation maxAreaNumber = 8, areaAnimationDelayStep = 20, areaAnimationDelays = d3Array.range(areaAnimationDelayStep, maxAreaNumber* areaAnimationDelayStep, areaAnimationDelayStep), overlay, verticalMarkerContainer, verticalMarker, dataPoints = {}, pointsSize = 1.5, pointsColor = '#c0c6cc', pointsBorderColor = '#ffffff', ease = d3Ease.easeQuadInOut, areaAnimationDuration = 1000, defaultNumMonths = 10, svg, chartWidth, chartHeight, data, dataByDate, dataByDateFormatted, dataByDateZeroed, tooltipThreshold = 480, xAxisPadding = { top: 0, left: 15, bottom: 0, right: 0 }, dateLabel = 'date', valueLabel = 'value', keyLabel = 'name', // getters getValueLabel = d =&gt; d[valueLabel], getValues = ({values}) =&gt; values, getKey = ({key}) =&gt; key, getName = ({name}) =&gt; name, getDate = ({date}) =&gt; date, // formats parseUTC = d3TimeFormat.timeParse('%Y-%m-%dT%H:%M:%SZ'), yTickNumberFormat = d3Format.format('.3'), xTickHourFormat = d3TimeFormat.timeFormat('%H %p'), xTickDateFormat = d3TimeFormat.timeFormat('%e'), xTickMonthFormat = d3TimeFormat.timeFormat('%b'), // events dispatcher = d3Dispatch.dispatch('customMouseOver', 'customMouseOut', 'customMouseMove'); /** * This function creates the graph using the selection and data provided * @param {D3Selection} _selection A d3 selection that represents * the container(s) where the chart(s) will be rendered * @param {areaChartData} _data The data to attach and generate the chart */ function exports(_selection) { _selection.each(function(_data){ chartWidth = width - margin.left - margin.right; chartHeight = height - margin.top - margin.bottom; data = cleanData(_data); dataByDate = getDataByDate(data); buildLayers(); buildScales(); buildAxis(); buildSVG(this); drawAxis(); drawStackedAreas(); if(shouldShowTooltip()){ drawHoverOverlay(); drawVerticalMarker(); addMouseEvents(); } }); } /** * Adds events to the container group if the environment is not mobile * Adding: mouseover, mouseout and mousemove */ function addMouseEvents() { svg .on('mouseover', handleMouseOver) .on('mouseout', handleMouseOut) .on('mousemove', handleMouseMove); } /** * Creates the d3 x and y axis, setting orientations * @private */ function buildAxis() { let dataTimeSpan = xScale.domain()[1] - xScale.domain()[0]; let xMonthTicks = dataTimeSpan &gt; ONE_AND_A_HALF_YEARS ? defaultNumMonths : d3Time.timeMonth; let xMainFormat = xTickDateFormat; let xSecondaryFormat = xTickMonthFormat; if (dataTimeSpan &lt; ONE_DAY) { xMainFormat = xTickHourFormat; xSecondaryFormat = xTickDateFormat; } xAxis = d3Axis.axisBottom(xScale) .ticks(getMaxNumOfHorizontalTicks(chartWidth, dataByDate.length)) .tickSize(10, 0) .tickPadding(tickPadding) .tickFormat(xMainFormat); //TODO: Review this axis with real data xMonthAxis = d3Axis.axisBottom(xScale) .ticks(xMonthTicks) .tickSize(0, 0) .tickFormat(xSecondaryFormat); yAxis = d3Axis.axisRight(yScale) .ticks(numVerticalTicks) .tickFormat(yTickNumberFormat) .tickSize(chartWidth + yTickTextXOffset, 0, 0) .tickPadding(tickPadding); } /** * Builds containers for the chart, the axis and a wrapper for all of them * NOTE: The order of drawing of this group elements is really important, * as everything else will be drawn on top of them * @private */ function buildContainerGroups(){ let container = svg.append('g') .classed('container-group', true) .attr('transform', `translate(${margin.left},${margin.top})`); container .append('g').classed('x-axis-group', true) .append('g').classed('x axis', true); container.selectAll('.x-axis-group') .append('g').classed('month-axis', true); container .append('g').classed('y-axis-group axis', true); container .append('g').classed('chart-group', true); container .append('g').classed('metadata-group', true); } /** * Builds the stacked layers layout * @return {D3Layout} Layout for drawing the chart * @private */ function buildLayers(){ dataByDateFormatted = _.chain(dataByDate) .map((d) =&gt; _.extend(d, d.values)) .map((d) =&gt; { _(d).each((entry) =&gt; { if(entry['name']) { d[entry['name']] = entry.value; } }); d['date'] = new Date(d['key']); return d; }) .value(); dataByDateZeroed = _.chain(JSON.parse(JSON.stringify(dataByDate))) .map((d) =&gt; _.extend(d, d.values)) .map((d) =&gt; { _(d).each((entry) =&gt; { if(entry['name']) { d[entry['name']] = 0; } }); d['date'] = new Date(d['key']); return d; }) .value(); let keys = uniq(_(data).pluck('name')); let stack3 = d3Shape.stack() .keys(keys) .order(d3Shape.stackOrderNone) .offset(d3Shape.stackOffsetNone); layersInitial = stack3(dataByDateZeroed); layers = stack3(dataByDateFormatted); } /** * Creates the x, y and color scales of the chart * @private */ function buildScales() { xScale = d3Scale.scaleTime() .domain(d3Array.extent(data, ({date}) =&gt; date)) .range([0, chartWidth]); yScale = d3Scale.scaleLinear() .domain([0, getMaxValueByDate()]) .range([chartHeight, 0]) .nice([numVerticalTicks + 1]); colorScale = d3Scale.scaleOrdinal() .range(colorSchema) .domain(data.map(getName)); // TODO add spread and rest operators to britecharts /* let range = colorScale.range(); categoryColorMap = colorScale.domain().reduce((memo, item, i) =&gt; ({...memo, [item]: range[i], }), {}); */ let range = colorScale.range(); categoryColorMap = colorScale .domain() .reduce((memo, item, i) =&gt; { memo[item] = range[i]; return memo; }, {}); } /** * @param {HTMLElement} container DOM element that will work as the container of the graph * @private */ function buildSVG(container) { if (!svg) { svg = d3Selection.select(container) .append('svg') .classed('britechart stacked-area', true); buildContainerGroups(); } svg .attr('width', width) .attr('height', height); } /** * Parses dates and values into JS Date objects and numbers * @param {obj} data Raw data from JSON file * @return {obj} Parsed data with values and dates */ function cleanData(data) { // could be rewritten using spread operator /* return data.map((d) =&gt; {...d, date: parseUTC(d[dateLabel], [valueLabel] : +d[valueLabel]}) */ return data.map((d) =&gt; { d.date = parseUTC(d[dateLabel]); d.value = +d[valueLabel]; return d; }); } /** * Draws the x and y axis on the svg object within their * respective groups * @private */ function drawAxis(){ svg.select('.x-axis-group .axis.x') .attr('transform', `translate( 0, ${chartHeight} )`) .call(xAxis); svg.select('.x-axis-group .month-axis') .attr('transform', `translate(0, ${(chartHeight + monthAxisPadding)})`) .call(xMonthAxis); svg.select('.y-axis-group.axis') .attr('transform', `translate( ${-yTickTextXOffset}, 0)`) .call(yAxis); // Moving the YAxis tick labels to the right side d3Selection.selectAll('.y-axis-group .tick text') .attr('transform', `translate( ${-chartWidth - yTickTextXOffset}, ${yTickTextYOffset})` ); } /** * Creates SVG dot elements for each data entry and draws them * TODO: Plug */ function drawDataReferencePoints() { // Creates Dots on Data points var points = svg.select('.chart-group').selectAll('.dots') .data(layers) .enter().append('g') .attr('class', 'dots') .attr('d', ({values}) =&gt; area(values)) .attr('clip-path', 'url(#clip)') // Processes the points // TODO: Optimize this code points.selectAll('.dot') .data(({values}, index) =&gt; values.map((point) =&gt; ({index, point}))) .enter() .append('circle') .attr('class','dot') .attr('r', () =&gt; pointsSize) .attr('fill', () =&gt; pointsColor) .attr('stroke-width', '0') .attr('stroke', pointsBorderColor) .attr('transform', function(d) { let {point} = d; let key = xScale(point.date); dataPoints[key] = dataPoints[key] || []; dataPoints[key].push(d); let {date, y, y0} = point; return `translate( ${xScale(date)}, ${yScale(y + y0)} )`; }); } /** * Draws an overlay element over the graph * @private */ function drawHoverOverlay(){ overlay = svg.select('.metadata-group') .append('rect') .attr('class', 'overlay') .attr('y1', 0) .attr('y2', chartHeight) .attr('height', chartHeight) .attr('width', chartWidth) .attr('fill', 'rgba(0,0,0,0)') .style('display', 'none'); } /** * Draws the different areas into the chart-group element * @private */ function drawStackedAreas(){ // Creating Area function area = d3Shape.area() .curve(d3Shape.curveCardinal) .x( ({data}) =&gt; xScale(data.date) ) .y0( (d) =&gt; yScale(d[0]) ) .y1( (d) =&gt; yScale(d[1]) ); let series = svg.select('.chart-group').selectAll('.layer') .data(layersInitial) .enter() .append('g') .classed('layer-container', true); series .append('path') .attr('class', 'layer') .attr('d', area) .style('fill', ({key}) =&gt; categoryColorMap[key]); // Update svg.select('.chart-group').selectAll('.layer') .data(layers) .transition() .delay( (_, i) =&gt; areaAnimationDelays[i]) .duration(areaAnimationDuration) .ease(ease) .attr('d', area) .style('opacity', areaOpacity) .style('fill', ({key}) =&gt; categoryColorMap[key]); // Exit series.exit() .transition() .style('opacity', 0) .remove(); } /** * Creates the vertical marker * @return void */ function drawVerticalMarker(){ verticalMarkerContainer = svg.select('.metadata-group') .append('g') .attr('class', 'vertical-marker-container') .attr('transform', 'translate(9999, 0)'); verticalMarker = verticalMarkerContainer.selectAll('path') .data([{ x1: 0, y1: 0, x2: 0, y2: 0 }]) .enter() .append('line') .classed('vertical-marker', true) .attr('x1', 0) .attr('y1', chartHeight) .attr('x2', 0) .attr('y2', 0); } /** * Removes all the datapoints highlighter circles added to the marker container * @return void */ function eraseDataPointHighlights() { verticalMarkerContainer.selectAll('.circle-container').remove(); } /** * Calculates the maximum number of ticks for the x axis * @param {Number} width Chart width * @param {Number} dataPointNumber Number of entries on the data * @return {Number} Number of ticks to render */ function getMaxNumOfHorizontalTicks(width, dataPointNumber) { let singleTickWidth = 30, spacing = 30, ticksForWidth = Math.ceil(width / (singleTickWidth + spacing)); return Math.min(dataPointNumber, ticksForWidth); } /** * Orders the data by date for consumption on the chart tooltip * @param {areaChartData} data Chart data * @return {Object[]} Chart data ordered by date * @private */ function getDataByDate(data) { return d3Collection.nest() .key(getDate).sortKeys(d3Array.ascending) .entries(data); } /** * Computes the maximum sum of values for any date * * @return {Number} Max value */ function getMaxValueByDate() { let keys = uniq(_(data).pluck('name')); let maxValueByDate = d3Array.max(dataByDateFormatted, function(d){ let vals = keys.map((key) =&gt; d[key]); return d3Array.sum(vals); }); return maxValueByDate; } /** * Extract X position on the chart from a given mouse event * @param {obj} event D3 mouse event * @return {Number} Position on the x axis of the mouse * @private */ function getMouseXPosition(event) { return d3Selection.mouse(event)[0]; } /** * Finds out the data entry that is closer to the given position on pixels * @param {Number} mouseX X position of the mouse * @return {obj} Data entry that is closer to that x axis position */ function getNearestDataPoint(mouseX) { let epsilon, nearest; //could use spread operator, would prevent mutation of original data /* let dataByDateParsed = dataByDate.map((item) =&gt; ({...item, key: new Date(item.key)})) */ let dataByDateParsed = dataByDate.map((item) =&gt; { item.key = new Date(item.key); return item; }); epsilon = (xScale(dataByDateParsed[1].key) - xScale(dataByDateParsed[0].key)) / 2; nearest = dataByDateParsed.find(({key}) =&gt; Math.abs(xScale(key) - mouseX) &lt;= epsilon); return nearest; } /** * MouseMove handler, calculates the nearest dataPoint to the cursor * and updates metadata related to it * @private */ function handleMouseMove(){ let dataPoint = getNearestDataPoint(getMouseXPosition(this) - margin.left), dataPointXPosition; if(dataPoint) { dataPointXPosition = xScale(new Date( dataPoint.key )); // Move verticalMarker to that datapoint moveVerticalMarker(dataPointXPosition); // Add data points highlighting highlightDataPoints(dataPoint); // Emit event with xPosition for tooltip or similar feature dispatcher.call('customMouseMove', this, dataPoint, categoryColorMap, dataPointXPosition); } } /** * MouseOut handler, hides overlay and removes active class on verticalMarkerLine * It also resets the container of the vertical marker * @private */ function handleMouseOut(data){ overlay.style('display', 'none'); verticalMarker.classed('bc-is-active', false); verticalMarkerContainer.attr('transform', 'translate(9999, 0)'); dispatcher.call('customMouseOut', this, data); } /** * Mouseover handler, shows overlay and adds active class to verticalMarkerLine * @private */ function handleMouseOver(data){ overlay.style('display', 'block'); verticalMarker.classed('bc-is-active', true); dispatcher.call('customMouseOver', this, data); } /** * Creates coloured circles marking where the exact data y value is for a given data point * @param {obj} dataPoint Data point to extract info from * @private */ function highlightDataPoints({values}) { let accumulator = 0; eraseDataPointHighlights(); // sorting the values based on the order of the colors, // so that the order always stays constant values = values .filter(v =&gt; !!v) .sort((a, b) =&gt; colorOrder[a.el] &gt; colorOrder[b.el]); values.forEach(({name}, index) =&gt; { let marker = verticalMarkerContainer .append('g') .classed('circle-container', true), circleSize = 12; accumulator = accumulator + values[index][valueLabel]; marker.append('circle') .classed('data-point-highlighter', true) .attr('cx', circleSize) .attr('cy', 0) .attr('r', 5) .style('stroke-width', 2) .style('stroke', categoryColorMap[name]); marker.attr('transform', `translate( ${(- circleSize)}, ${(yScale(accumulator))} )` ); }); } /** * Helper method to update the x position of the vertical marker * @param {obj} dataPoint Data entry to extract info * @return void */ function moveVerticalMarker(verticalMarkerXPosition){ verticalMarkerContainer.attr('transform', `translate(${verticalMarkerXPosition},0)`); } /** * Determines if we should add the tooltip related logic depending on the * size of the chart and the tooltipThreshold variable value * @return {boolean} Should we build the tooltip? * @private */ function shouldShowTooltip() { return width &gt; tooltipThreshold; } // Accessors /** * Gets or Sets the aspect ratio of the chart * @param {Number} _x Desired aspect ratio for the graph * @return { (Number | Module) } Current aspect ratio or Area Chart module to chain calls * @public */ exports.aspectRatio = function(_x) { if (!arguments.length) { return aspectRatio; } aspectRatio = _x; return this; }; /** * Gets or Sets the colorSchema of the chart * @param {String[]} _x Desired colorSchema for the graph * @return { colorSchema | module} Current colorSchema or Chart module to chain calls * @public */ exports.colorSchema = function(_x) { if (!arguments.length) { return colorSchema; } colorSchema = _x; return this; }; /** * Gets or Sets the dateLabel of the chart * @param {Number} _x Desired dateLabel for the graph * @return { dateLabel | module} Current dateLabel or Chart module to chain calls * @public */ exports.dateLabel = function(_x) { if (!arguments.length) { return dateLabel; } dateLabel = _x; return this; }; /** * Gets or Sets the height of the chart * @param {Number} _x Desired width for the graph * @return { height | module} Current height or Area Chart module to chain calls * @public */ exports.height = function(_x) { if (!arguments.length) { return height; } if (aspectRatio) { width = Math.ceil(_x / aspectRatio); } height = _x; return this; }; /** * Gets or Sets the keyLabel of the chart * @param {Number} _x Desired keyLabel for the graph * @return { keyLabel | module} Current keyLabel or Chart module to chain calls * @public */ exports.keyLabel = function(_x) { if (!arguments.length) { return keyLabel; } keyLabel = _x; return this; }; /** * Gets or Sets the margin of the chart * @param {Object} _x Margin object to get/set * @return { margin | module} Current margin or Area Chart module to chain calls * @public */ exports.margin = function(_x) { if (!arguments.length) { return margin; } margin = _x; return this; }; /** * Gets or Sets the tooltipThreshold of the chart * @param {Object} _x Margin object to get/set * @return { tooltipThreshold | module} Current tooltipThreshold or Area Chart module to chain calls * @public */ exports.tooltipThreshold = function(_x) { if (!arguments.length) { return tooltipThreshold; } tooltipThreshold = _x; return this; }; /** * Gets or Sets the valueLabel of the chart * @param {Number} _x Desired valueLabel for the graph * @return { valueLabel | module} Current valueLabel or Chart module to chain calls * @public */ exports.valueLabel = function(_x) { if (!arguments.length) { return valueLabel; } valueLabel = _x; return this; }; /** * Gets or Sets the width of the chart * @param {Number} _x Desired width for the graph * @return { width | module} Current width or Area Chart module to chain calls * @public */ exports.width = function(_x) { if (!arguments.length) { return width; } if (aspectRatio) { height = Math.ceil(_x * aspectRatio); } width = _x; return this; }; /** * Chart exported to png and a download action is fired * @public */ exports.exportChart = function(filename, title) { exportChart.call(exports, svg, filename, title); }; /** * Exposes an 'on' method that acts as a bridge with the event dispatcher * We are going to expose this events: * customMouseOver, customMouseMove and customMouseOut * * @return {module} Bar Chart * @public */ exports.on = function() { let value = dispatcher.on.apply(dispatcher, arguments); return value === dispatcher ? exports : value; }; return exports; }; }); × Search results Close "},"bar.js.html":{"id":"bar.js.html","title":"Source: bar.js","body":" API BarBrushDonutLegendLineMini-tooltipSparklineStacked-areaStepTooltip Demos _GETTINGSTARTEDbarbrushdonutkitchen-sinklinesparklinestacked-areastep Global Global Source: bar.js define(function(require) { 'use strict'; const d3Array = require('d3-array'); const d3Axis = require('d3-axis'); const d3Dispatch = require('d3-dispatch'); const d3Format = require('d3-format'); const d3Scale = require('d3-scale'); const d3Selection = require('d3-selection'); const d3Transition = require('d3-transition'); const textHelper = require('./helpers/text'); const exportChart = require('./helpers/exportChart'); /** * @typedef BarChartData * @type {Object[]} * @property {Number} value Value of the group (required) * @property {String} name Name of the group (required) * * @example * [ * { * value: 1, * name: 'glittering' * }, * { * value: 1, * name: 'luminous' * } * ] */ /** * Bar Chart reusable API class that renders a * simple and configurable bar chart. * * @module Bar * @tutorial bar * @requires d3-array, d3-axis, d3-dispatch, d3-scale, d3-selection * * @example * var barChart = bar(); * * barChart * .height(500) * .width(800); * * d3Selection.select('.css-selector') * .datum(dataset) * .call(barChart); * */ return function module() { let margin = { top: 20, right: 20, bottom: 10, left: 40 }, width = 960, height = 500, data, chartWidth, chartHeight, xScale, yScale, numOfVerticalTicks = 5, numOfHorizontalTicks = 5, percentageAxisToMaxRatio = 1, enablePercentageLabels = false, percentageLabelMargin = 7, percentageLabelSize = 14, horizontalLabelFormat = '.0%', verticalLabelFormat = '.0f', xAxis, yAxis, xAxisPadding = { top: 0, left: 0, bottom: 0, right: 0 }, yAxisPaddingBetweenChart = 10, yAxisLineWrapLimit = 2, horizontal = false, svg, valueLabel = 'value', nameLabel = 'name', maskGridLines, baseLine, // Dispatcher object to broadcast the mouse events // Ref: https://github.com/mbostock/d3/wiki/Internals#d3_dispatch dispatcher = d3Dispatch.dispatch('customMouseOver', 'customMouseOut', 'customMouseMove'), // extractors getName = ({name}) =&gt; name, getValue = ({value}) =&gt; value, _percentageLabelHorizontalX = ({value}) =&gt; xScale(value) + percentageLabelMargin, _percentageLabelHorizontalY= ({name}) =&gt; yScale(name) + (yScale.bandwidth() / 2) + (percentageLabelSize * (3/8)), _percentageLabelVerticalX = ({name}) =&gt; xScale(name), _percentageLabelVerticalY = ({value}) =&gt; yScale(value) - percentageLabelMargin, _percentageLabelHorizontalFormatValue = ({value}) =&gt; d3Format.format(horizontalLabelFormat)(value), _percentageLabelVerticalFormatValue = ({value}) =&gt; d3Format.format(verticalLabelFormat)(parseFloat(value) * 100); /** * This function creates the graph using the selection as container * @param {D3Selection} _selection A d3 selection that represents * the container(s) where the chart(s) will be rendered * @param {BarChartData} _data The data to attach and generate the chart */ function exports(_selection){ _selection.each(function(_data){ chartWidth = width - margin.left - margin.right - (yAxisPaddingBetweenChart * 1.2); chartHeight = height - margin.top - margin.bottom; data = cleanData(_data); buildScales(); buildAxis(); buildSVG(this); drawGridLines(); drawBars(); drawAxis(); if (enablePercentageLabels) { drawPercentageLabels(); } }); } /** * Creates the d3 x and y axis, setting orientations * @private */ function buildAxis(){ if (!horizontal) { xAxis = d3Axis.axisBottom(xScale); yAxis = d3Axis.axisLeft(yScale) .ticks(numOfVerticalTicks, '%'); } else { xAxis = d3Axis.axisBottom(xScale) .ticks(numOfHorizontalTicks, '%') .tickSizeInner([-chartHeight]); yAxis = d3Axis.axisLeft(yScale); } } /** * Builds containers for the chart, the axis and a wrapper for all of them * Also applies the Margin convention * @private */ function buildContainerGroups(){ let container = svg.append('g') .classed('container-group', true) .attr('transform', `translate(${margin.left + yAxisPaddingBetweenChart}, ${margin.top})`); container .append('g').classed('grid-lines-group', true); container .append('g').classed('chart-group', true); container .append('g').classed('x-axis-group axis', true); container .append('g') .attr('transform', `translate(${-1 * (yAxisPaddingBetweenChart)}, 0)`) .classed('y-axis-group axis', true); container .append('g').classed('metadata-group', true); } /** * Creates the x and y scales of the graph * @private */ function buildScales() { let percentageAxis = Math.min(percentageAxisToMaxRatio * d3Array.max(data, getValue), 1) if (!horizontal) { xScale = d3Scale.scaleBand() .domain(data.map(getName)) .rangeRound([0, chartWidth]) .padding(0.1); yScale = d3Scale.scaleLinear() .domain([0, percentageAxis]) .rangeRound([chartHeight, 0]); } else { xScale = d3Scale.scaleLinear() .domain([0, percentageAxis]) .rangeRound([0, chartWidth]); yScale = d3Scale.scaleBand() .domain(data.map(getName)) .rangeRound([chartHeight, 0]) .padding(0.1); } } /** * Builds the SVG element that will contain the chart * @param {HTMLElement} container DOM element that will work as the container of the graph * @private */ function buildSVG(container){ if (!svg) { svg = d3Selection.select(container) .append('svg') .classed('britechart bar-chart', true); buildContainerGroups(); } svg .attr('width', width + margin.left + margin.right) .attr('height', height + margin.top + margin.bottom); } /** * Cleaning data adding the proper format * @param {BarChartData} data Data * @private */ function cleanData(data) { return data.map((d) =&gt; { d.value = +d[valueLabel]; d.name = String(d[nameLabel]); return d; }); } /** * Utility function that wraps a text into the given width * @param {D3Selection} text Text to write * @param {Number} containerWidth * @private */ function wrapText(text, containerWidth) { textHelper.wrapTextWithEllipses(text, containerWidth, 0, yAxisLineWrapLimit) } /** * Draws the x and y axis on the svg object within their * respective groups * @private */ function drawAxis(){ svg.select('.x-axis-group.axis') .attr('transform', `translate(0, ${chartHeight})`) .call(xAxis); svg.select('.y-axis-group.axis') .call(yAxis); svg.selectAll('.y-axis-group .tick text') .call(wrapText, margin.left - yAxisPaddingBetweenChart) } /** * Draws the bars along the x axis * @param {D3Selection} bars Selection of bars * @return {void} */ function drawHorizontalBars(bars) { // Enter + Update bars.enter() .append('rect') .classed('bar', true) .attr('y', chartHeight) .attr('x', 0) .attr('height', yScale.bandwidth()) .attr('width', ({value}) =&gt; xScale(value)) .on('mouseover', function() { dispatcher.call('customMouseOver', this); }) .on('mousemove', function(d) { dispatcher.call('customMouseMove', this, d, d3Selection.mouse(this), [chartWidth, chartHeight]); }) .on('mouseout', function() { dispatcher.call('customMouseOut', this); }) .merge(bars) .attr('x', 0) .attr('y', ({name}) =&gt; yScale(name)) .attr('height', yScale.bandwidth()) .attr('width', ({value}) =&gt; xScale(value)); } /** * Draws the bars along the y axis * @param {D3Selection} bars Selection of bars * @return {void} */ function drawVerticalBars(bars) { // Enter + Update bars.enter() .append('rect') .classed('bar', true) .attr('x', chartWidth) .attr('y', ({value}) =&gt; yScale(value)) .attr('width', xScale.bandwidth()) .attr('height', ({value}) =&gt; chartHeight - yScale(value)) .on('mouseover', function() { dispatcher.call('customMouseOver', this); }) .on('mousemove', function(d) { dispatcher.call('customMouseMove', this, d, d3Selection.mouse(this), [chartWidth, chartHeight]); }) .on('mouseout', function() { dispatcher.call('customMouseOut', this); }) .merge(bars) .attr('x', ({name}) =&gt; xScale(name)) .attr('y', ({value}) =&gt; yScale(value)) .attr('width', xScale.bandwidth()) .attr('height', ({value}) =&gt; chartHeight - yScale(value)); } /** * Draws percentage labels at the end of each bar * @private * @return {void} */ function drawPercentageLabels() { let labelXPosition = horizontal ? _percentageLabelHorizontalX : _percentageLabelVerticalX; let labelYPosition = horizontal ? _percentageLabelHorizontalY : _percentageLabelVerticalY; let text = horizontal ? _percentageLabelHorizontalFormatValue : _percentageLabelVerticalFormatValue; let percentageLabels = svg.select('.metadata-group') .append('g') .classed('percentage-label-group', true) .selectAll('text') .data(data.reverse()) .enter() .append('text'); percentageLabels .classed('percentage-label', true) .attr('x', labelXPosition) .attr('y', labelYPosition) .text(text) .attr('font-size', percentageLabelSize + 'px') } /** * Draws the bar elements within the chart group * @private */ function drawBars(){ let bars = svg.select('.chart-group').selectAll('.bar').data(data); if (!horizontal) { drawVerticalBars(bars); } else { drawHorizontalBars(bars) } // Exit bars.exit() .transition() .style('opacity', 0) .remove(); } /** * Draws grid lines on the background of the chart * @return void */ function drawGridLines(){ if (!horizontal) { drawVerticalGridLines(); } else { drawHorizontalGridLines(); } } /** * Draws the grid lines for an horizontal bar chart * @return {void} */ function drawHorizontalGridLines() { maskGridLines = svg.select('.grid-lines-group') .selectAll('line.vertical-grid-line') .data(xScale.ticks(4)) .enter() .append('line') .attr('class', 'vertical-grid-line') .attr('y1', (xAxisPadding.left)) .attr('y2', chartHeight) .attr('x1', (d) =&gt; xScale(d)) .attr('x2', (d) =&gt; xScale(d)) //draw a horizontal line to extend y-axis till the edges baseLine = svg.select('.grid-lines-group') .selectAll('line.extended-y-line') .data([0]) .enter() .append('line') .attr('class', 'extended-y-line') .attr('y1', (xAxisPadding.left)) .attr('y2', chartHeight) .attr('x1', 0) .attr('x2', 0); } /** * Draws the grid lines for a vertical bar chart * @return {void} */ function drawVerticalGridLines() { maskGridLines = svg.select('.grid-lines-group') .selectAll('line.horizontal-grid-line') .data(yScale.ticks(4)) .enter() .append('line') .attr('class', 'horizontal-grid-line') .attr('x1', (xAxisPadding.left)) .attr('x2', chartWidth) .attr('y1', (d) =&gt; yScale(d)) .attr('y2', (d) =&gt; yScale(d)) //draw a horizontal line to extend x-axis till the edges baseLine = svg.select('.grid-lines-group') .selectAll('line.extended-x-line') .data([0]) .enter() .append('line') .attr('class', 'extended-x-line') .attr('x1', (xAxisPadding.left)) .attr('x2', chartWidth) .attr('y1', height - margin.bottom - margin.top) .attr('y2', height - margin.bottom - margin.top); } /** * Chart exported to png and a download action is fired * @public */ exports.exportChart = function(filename) { exportChart.call(exports, svg, filename); }; /** * Gets or Sets the height of the chart * @param {number} _x Desired width for the graph * @return { height | module} Current height or Bar Chart module to chain calls * @public */ exports.height = function(_x) { if (!arguments.length) { return height; } height = _x; return this; }; /** * Gets or Sets the margin of the chart * @param {object} _x Margin object to get/set * @return { margin | module} Current margin or Bar Chart module to chain calls * @public */ exports.margin = function(_x) { if (!arguments.length) { return margin; } margin = _x; return this; }; /** * Gets or Sets the width of the chart * @param {number} _x Desired width for the graph * @return { width | module} Current width or Bar Chart module to chain calls * @public */ exports.width = function(_x) { if (!arguments.length) { return width; } width = _x; return this; }; /** * Gets or Sets the horizontal direction of the chart * @param {number} _x Desired horizontal direction for the graph * @return { horizontal | module} Current horizontal direction or Bar Chart module to chain calls * @public */ exports.horizontal = function(_x) { if (!arguments.length) { return horizontal; } horizontal = _x; return this; }; /** * Exposes an 'on' method that acts as a bridge with the event dispatcher * We are going to expose this events: * customMouseOver, customMouseMove and customMouseOut * * @return {module} Bar Chart * @public */ exports.on = function() { let value = dispatcher.on.apply(dispatcher, arguments); return value === dispatcher ? exports : value; }; /** * Chart exported to png and a download action is fired * @public */ exports.exportChart = function(filename, title) { exportChart.call(exports, svg, filename, title); }; /** * Configurable extension of the x axis * if your max point was 50% you might want to show x axis to 60%, pass 1.2 * @param {number} _x ratio to max data point to add to the x axis * @return { ratio | module} Current ratio or Bar Chart module to chain calls * @public */ exports.percentageAxisToMaxRatio = function(_x) { if (!arguments.length) { return percentageAxisToMaxRatio; } percentageAxisToMaxRatio = _x; return this; } /** * Default 10px. Offset between end of bar and start of the percentage bars * @param {number} _x percentage margin offset from end of bar * @return {number | module} Currnet offset or Bar Chart module to chain calls */ exports.percentageLabelMargin = function(_x) { if (!arguments.length) { return percentageLabelMargin; } percentageLabelMargin = _x; return this; } /** * Default false. If true, adds percentage labels at the end of the bars * @param {Boolean} _x * @return {Boolean | module} Current value of enablePercentageLables or Bar Chart module to chain calls */ exports.enablePercentageLabels = function(_x) { if (!arguments.length) { return enablePercentageLabels; } enablePercentageLabels = _x; return this; } /** * Default 10. Space between y axis and chart * @param {number} _x space between y axis and chart * @return {number| module} Current value of yAxisPaddingBetweenChart or Bar Chart module to chain calls */ exports.yAxisPaddingBetweenChart = function(_x) { if (!arguments.length) { return yAxisPaddingBetweenChart; } yAxisPaddingBetweenChart = _x; return this; } return exports; }; }); × Search results Close "},"brush.js.html":{"id":"brush.js.html","title":"Source: brush.js","body":" API BarBrushDonutLegendLineMini-tooltipSparklineStacked-areaStepTooltip Demos _GETTINGSTARTEDbarbrushdonutkitchen-sinklinesparklinestacked-areastep Global Global Source: brush.js define(function(require) { 'use strict'; const d3Array = require('d3-array'); const d3Axis = require('d3-axis'); const d3Brush = require('d3-brush'); const d3Ease = require('d3-ease'); const d3Scale = require('d3-scale'); const d3Shape = require('d3-shape'); const d3Selection = require('d3-selection'); const d3Time = require('d3-time'); const d3TimeFormat = require('d3-time-format'); const d3Transition = require('d3-transition'); const colorHelper = require('./helpers/colors'); /** * @typedef BrushChartData * @type {Object[]} * @property {Number} value Value to chart (required) * @property {Date} date Date of the value (required) * * @example * [ * { * value: 1, * date: '2011-01-06T00:00:00Z' * }, * { * value: 2, * date: '2011-01-07T00:00:00Z' * } * ] */ /** * Brush Chart reusable API class that renders a * simple and configurable brush chart. * * @module Brush * @tutorial brush * @requires d3-array, d3-axis, d3-brush, d3-ease, d3-scale, d3-shape, d3-selection, d3-time, d3-time-format * * @example * let brushChart = brush(); * * brushChart * .height(500) * .width(800); * * d3Selection.select('.css-selector') * .datum(dataset) * .call(brushChart); * */ return function module() { let margin = { top: 20, right: 20, bottom: 30, left: 20 }, width = 960, height = 500, data, svg, ease = d3Ease.easeQuadOut, dateLabel = 'date', valueLabel = 'value', dateRange = [null, null], chartWidth, chartHeight, xScale, yScale, xAxis, brush, chartBrush, handle, onBrush = null, gradient = colorHelper.colorGradients.greenBlueGradient, // formats defaultTimeFormat = '%m/%d/%Y', xTickMonthFormat = d3TimeFormat.timeFormat('%b'), // extractors getValue = ({value}) =&gt; value, getDate = ({date}) =&gt; date; /** * This function creates the graph using the selection as container * @param {D3Selection} _selection A d3 selection that represents * the container(s) where the chart(s) will be rendered * @param {BrushChartData} _data The data to attach and generate the chart */ function exports(_selection){ _selection.each(function(_data){ chartWidth = width - margin.left - margin.right; chartHeight = height - margin.top - margin.bottom; data = cleanData(cloneData(_data)); buildScales(); buildAxis(); buildSVG(this); buildGradient(); buildBrush(); drawArea(); drawAxis(); drawBrush(); drawHandles(); }); } /** * Creates the d3 x axis, setting orientation * @private */ function buildAxis(){ xAxis = d3Axis.axisBottom(xScale) .tickFormat(xTickMonthFormat); } /** * Creates the brush element and attaches a listener * @return {void} */ function buildBrush() { brush = d3Brush.brushX() .extent([[0, 0], [chartWidth, chartHeight]]) .on('brush', handleBrush) .on('end', handleBrushEnded); } /** * Builds containers for the chart, the axis and a wrapper for all of them * Also applies the Margin convention * @private */ function buildContainerGroups(){ let container = svg.append('g') .classed('container-group', true) .attr('transform', `translate(${margin.left}, ${margin.top})`); container .append('g') .classed('chart-group', true); container .append('g') .classed('metadata-group', true); container .append('g') .classed('x-axis-group', true); container .append('g') .classed('brush-group', true); } /** * Creates the gradient on the area * @return {void} */ function buildGradient() { let metadataGroup = svg.select('.metadata-group'); metadataGroup.append('linearGradient') .attr('id', 'brush-area-gradient') .attr('gradientUnits', 'userSpaceOnUse') .attr('x1', 0) .attr('x2', xScale(data[data.length - 1].date)) .attr('y1', 0) .attr('y2', 0) .selectAll('stop') .data([ {offset: '0%', color: gradient[0]}, {offset: '100%', color: gradient[1]} ]) .enter().append('stop') .attr('offset', ({offset}) =&gt; offset) .attr('stop-color', ({color}) =&gt; color); } /** * Creates the x and y scales of the graph * @private */ function buildScales(){ xScale = d3Scale.scaleTime() .domain(d3Array.extent(data, getDate )) .range([0, chartWidth]); yScale = d3Scale.scaleLinear() .domain([0, d3Array.max(data, getValue)]) .range([chartHeight, 0]); } /** * Builds the SVG element that will contain the chart * @param {HTMLElement} container DOM element that will work as the container of the graph * @private */ function buildSVG(container){ if (!svg) { svg = d3Selection.select(container) .append('svg') .classed('britechart brush-chart', true); buildContainerGroups(); } svg .transition() .ease(ease) .attr('width', width) .attr('height', height); } /** * Cleaning data adding the proper format * * @param {BrushChartData} data Data */ function cleanData(data) { let parseDate = d3TimeFormat.timeParse(defaultTimeFormat); return data.map(function (d) { d.date = parseDate(d[dateLabel]); d.value = +d[valueLabel]; return d; }); } /** * Clones the passed array of data * @param {Object[]} dataToClone Data to clone * @return {Object[]} Cloned data */ function cloneData(dataToClone) { return JSON.parse(JSON.stringify(dataToClone)); } /** * Draws the x axis on the svg object within its group * * @private */ function drawAxis(){ svg.select('.x-axis-group') .append('g') .attr('class', 'x axis') .attr('transform', `translate(0, ${chartHeight})`) .call(xAxis); } /** * Draws the area that is going to represent the data * * @return {void} */ function drawArea() { // Create and configure the area generator let area = d3Shape.area() .x(({date}) =&gt; xScale(date)) .y0(chartHeight) .y1(({value}) =&gt; yScale(value)) .curve(d3Shape.curveBasis); // Create the area path svg.select('.chart-group') .append('path') .datum(data) .attr('class', 'brush-area') .attr('d', area); } /** * Draws the Brush components on its group * @return {void} */ function drawBrush() { chartBrush = svg.select('.brush-group') .call(brush); // Update the height of the brushing rectangle chartBrush.selectAll('rect') .classed('brush-rect', true) .attr('height', chartHeight); } /** * Draws a handle for the Brush section * @return {void} */ function drawHandles() { let handleFillColor = colorHelper.colorSchemasHuman.britechartsGreySchema[1]; // Styling handle = chartBrush .selectAll('.handle.brush-rect') .style('fill', handleFillColor); } /** * When a brush event happens, we can extract info from the extension * of the brush. * * @return {void} */ function handleBrush() { let s = d3Selection.event.selection, dateExtent = s.map(xScale.invert); if (typeof onBrush === 'function') { onBrush.call(null, dateExtent); } // updateHandlers(dateExtent); } /** * Processes the end brush event, snapping the boundaries to days * as showed on the example on https://bl.ocks.org/mbostock/6232537 * @return {void} * @private */ function handleBrushEnded() { if (!d3Selection.event.sourceEvent) return; // Only transition after input. if (!d3Selection.event.selection) return; // Ignore empty selections. let d0 = d3Selection.event.selection.map(xScale.invert), d1 = d0.map(d3Time.timeDay.round); // If empty when rounded, use floor &amp; ceil instead. if (d1[0] &gt;= d1[1]) { d1[0] = d3Time.timeDay.floor(d0[0]); d1[1] = d3Time.timeDay.offset(d1[0]); } d3Selection.select(this) .transition() .call(d3Selection.event.target.move, d1.map(xScale)); } /** * Sets a new brush extent within the passed percentage positions * @param {Number} a Percentage of data that the brush start with * @param {Number} b Percentage of data that the brush ends with * @example * setBrushByPercentages(0.25, 0.5) */ function setBrushByPercentages(a, b) { let x0 = a * chartWidth, x1 = b * chartWidth; brush .move(chartBrush, [x0, x1]); } /** * Sets a new brush extent within the passed dates * @param {String | Date} dateA Initial Date * @param {String | Date} dateB End Date */ function setBrushByDates(dateA, dateB) { let x0 = xScale(new Date(dateA)), x1 = xScale(new Date(dateB)); brush .move(chartBrush, [x0, x1]); } /** * Updates visibility and position of the brush handlers * @param {Number[]} dateExtent Date range * @return {void} */ function updateHandlers(dateExtent) { if (dateExtent == null) { handle.attr('display', 'none'); } else { handle .attr('display', null) .attr('transform', function(d, i) { return `translate(${dateExtent[i]},${chartHeight / 2})`; }); } } // API /** * Gets or Sets the dateRange for the selected part of the brush * @param {String[]} _x Desired dateRange for the graph * @return { dateRange | module} Current dateRange or Chart module to chain calls * @public */ exports.dateRange = function(_x) { if (!arguments.length) { return dateRange; } dateRange = _x; if (Array.isArray(dateRange)) { setBrushByDates(...dateRange); } return this; }; /** * Gets or Sets the gradient of the chart * @param {String[]} _x Desired gradient for the graph * @return { gradient | module} Current gradient or Chart module to chain calls * @public */ exports.gradient = function(_x) { if (!arguments.length) { return gradient; } gradient = _x; return this; }; /** * Gets or Sets the height of the chart * @param {number} _x Desired width for the graph * @return { height | module} Current height or Chart module to chain calls * @public */ exports.height = function(_x) { if (!arguments.length) { return height; } height = _x; return this; }; /** * Gets or Sets the margin of the chart * @param {object} _x Margin object to get/set * @return { margin | module} Current margin or Chart module to chain calls * @public */ exports.margin = function(_x) { if (!arguments.length) { return margin; } margin = _x; return this; }; /** * Gets or Sets the callback that will be called when the user brushes over the area * @param {Function} _x Callback to call * @return {Function | module} Current callback function or the Chart Module */ exports.onBrush = function(_x) { if (!arguments.length) return onBrush; onBrush = _x; return this; }; /** * Gets or Sets the width of the chart * @param {number} _x Desired width for the graph * @return { width | module} Current width or Chart module to chain calls * @public */ exports.width = function(_x) { if (!arguments.length) { return width; } width = _x; return this; }; return exports; }; }); × Search results Close "},"line.js.html":{"id":"line.js.html","title":"Source: line.js","body":" API BarBrushDonutLegendLineMini-tooltipSparklineStacked-areaStepTooltip Demos _GETTINGSTARTEDbarbrushdonutkitchen-sinklinesparklinestacked-areastep Global Global Source: line.js define(function(require){ 'use strict'; const d3Array = require('d3-array'); const d3Axis = require('d3-axis'); const d3Collection = require('d3-collection'); const d3Dispatch = require('d3-dispatch'); const d3Ease = require('d3-ease'); const d3Format = require('d3-format'); const d3Scale = require('d3-scale'); const d3Shape = require('d3-shape'); const d3Selection = require('d3-selection'); const d3Time = require('d3-time'); const d3TimeFormat = require('d3-time-format'); const d3Transition = require('d3-transition'); const _ = require('underscore'); const colorHelper = require('./helpers/colors'); const exportChart = require('./helpers/exportChart'); const { axisTimeCombinations, lineGradientId, timeBenchmarks } = require('./helpers/constants.js'); /** * @typedef D3Selection * @type {Array[]} * @property {Number} length Size of the selection * @property {DOMElement} parentNode Parent of the selection */ /** * @typedef lineChartDataByTopic * @type {Object} * @property {String} topicName Topic name (required) * @property {Number} topic Topic identifier (required) * @property {Object[]} dates All date entries with values for that topic (required) * * @example * { * topicName: 'San Francisco', * topic: 123, * dates: [ * { * date: '2017-01-16T16:00:00-08:00', * value: 1 * }, * { * date: '2017-01-16T17:00:00-08:00', * value: 2 * } * ] * } */ /** * @typedef LineChartData * @type {Object[]} * @property {lineChartDataByTopic[]} dataByTopic Data values to chart (required) * * @example * { * dataByTopic: [ * { * topicName: 'San Francisco', * topic: 123, * dates: [ * { * date: '2017-01-16T16:00:00-08:00', * value: 1 * }, * { * date: '2017-01-16T17:00:00-08:00', * value: 2 * } * ] * }, * { * topicName: 'Other', * topic: 345, * dates: [ * {...}, * {...} * ] * } * ] * } */ /** * Line Chart reusable API module that allows us * rendering a multi line and configurable chart. * * @module Line * @tutorial line * @requires d3-array, d3-axis, d3-brush, d3-ease, d3-format, d3-scale, d3-shape, d3-selection, d3-time, d3-time-format * * @example * let lineChart = line(); * * lineChart * .aspectRatio(0.5) * .width(500); * * d3Selection.select('.css-selector') * .datum(dataset) * .call(lineChart); * */ return function line() { let margin = { top: 60, right: 30, bottom: 40, left: 70 }, width = 960, height = 500, aspectRatio = null, tooltipThreshold = 480, svg, chartWidth, chartHeight, xScale, yScale, colorScale, xAxis, xMonthAxis, yAxis, xAxisPadding = { top: 0, left: 15, bottom: 0, right: 0 }, tickPadding = 5, colorSchema = colorHelper.colorSchemas.britechartsColorSchema, singleLineGradientColors = colorHelper.colorGradients.greenBlueGradient, topicColorMap, defaultAxisSettings = axisTimeCombinations.DAY_MONTH, forceAxisSettings = null, singleTickWidth = 20, horizontalTickSpacing = 40, ease = d3Ease.easeQuadInOut, animationDuration = 1500, dataByTopic, dataByDate, dateLabel = 'date', valueLabel = 'value', topicLabel = 'topic', topicNameLabel = 'topicName', numVerticalTics = 5, defaultNumMonths = 10, overlay, overlayColor = 'rgba(0, 0, 0, 0)', verticalMarkerContainer, verticalMarkerLine, maskGridLines, baseLine, // extractors getDate = ({date}) =&gt; date, getValue = ({value}) =&gt; value, getTopic = ({topic}) =&gt; topic, getLineColor = ({topic}) =&gt; colorScale(topic), // formats yTickNumberFormat = d3Format.format('.3'), xTickHourFormat = d3TimeFormat.timeFormat('%H %p'), xTickDateFormat = d3TimeFormat.timeFormat('%e'), xTickMonthFormat = d3TimeFormat.timeFormat('%b'), xTickYearFormat = d3TimeFormat.timeFormat('%Y'), // events dispatcher = d3Dispatch.dispatch('customMouseOver', 'customMouseOut', 'customMouseMove'); const formatMap = { hour: xTickHourFormat, day: xTickDateFormat, month: xTickMonthFormat }; /** * This function creates the graph using the selection and data provided * * @param {D3Selection} _selection A d3 selection that represents * the container(s) where the chart(s) will be rendered * @param {LineChartData} _data The data to attach and generate the chart */ function exports(_selection) { _selection.each(function(_data) { ({ dataByTopic, dataByDate } = cleanData(_data)); chartWidth = width - margin.left - margin.right; chartHeight = height - margin.top - margin.bottom; buildScales(); buildAxis(); buildSVG(this); drawGridLines(); drawAxis(); buildGradient(); drawLines(); if (shouldShowTooltip()) { drawVerticalMarker(); drawHoverOverlay(); addMouseEvents(); } }); } /** * Adds events to the container group if the environment is not mobile * Adding: mouseover, mouseout and mousemove */ function addMouseEvents() { svg .on('mouseover', handleMouseOver) .on('mouseout', handleMouseOut) .on('mousemove', handleMouseMove); } /** * Adjusts the position of the y axis' ticks * @param {D3Selection} selection Y axis group * @return void */ function adjustYTickLabels(selection) { selection.selectAll('.tick text') .attr('transform', 'translate(0, -7)'); } /** * Returns tick object to be used when building the x axis * @return {object} tick settings for major and minr axis */ function getXAxisSettings() { let settings = forceAxisSettings || defaultAxisSettings; let minorTickValue, majorTickValue; let dateTimeSpan = xScale.domain()[1] - xScale.domain()[0]; let { ONE_AND_A_HALF_YEARS, ONE_DAY } = timeBenchmarks; // might want to add minute-hour if (dateTimeSpan &lt; ONE_DAY) { settings = axisTimeCombinations.HOUR_DAY; majorTickValue = d3Time.timeDay.every(1); } else if (dateTimeSpan &lt; ONE_AND_A_HALF_YEARS) { settings = axisTimeCombinations.DAY_MONTH; majorTickValue = d3Time.timeMonth.every(1); } else { settings = axisTimeCombinations.MONTH_YEAR; minorTickValue = 10; majorTickValue = d3Time.timeYear.every(1); } let [minor, major] = settings.split('-'); minorTickValue = dataByDate.length &lt; 5 ? d3Time.timeDay : getMaxNumOfHorizontalTicks(width, dataByDate.length); return { minor: { format: formatMap[minor], tick: minorTickValue, }, major: { format: formatMap[major], tick: majorTickValue, } }; } /** * Creates the d3 x and y axis, setting orientations * @private */ function buildAxis() { let rangeDiff = yScale.domain()[1] - yScale.domain()[0]; let yTickNumber = rangeDiff &lt; numVerticalTics - 1 ? rangeDiff : numVerticalTics; let {minor, major} = getXAxisSettings(); xAxis = d3Axis.axisBottom(xScale) .ticks(minor.tick) .tickSize(10, 0) .tickPadding(tickPadding) .tickFormat(minor.format); xMonthAxis = d3Axis.axisBottom(xScale) .ticks(major.tick) .tickSize(0, 0) .tickFormat(major.format); yAxis = d3Axis.axisLeft(yScale) .ticks(yTickNumber) .tickSize([0]) .tickPadding(tickPadding) .tickFormat(yTickNumberFormat); } /** * Builds containers for the chart, the axis and a wrapper for all of them * NOTE: The order of drawing of this group elements is really important, * as everything else will be drawn on top of them * @private */ function buildContainerGroups(){ let container = svg.append('g') .classed('container-group', true) .attr('transform', `translate(${margin.left},${margin.top})`); container .append('g').classed('x-axis-group', true) .append('g').classed('axis x', true); container.selectAll('.x-axis-group') .append('g').classed('month-axis', true); container .append('g').classed('y-axis-group axis y', true); container .append('g').classed('grid-lines-group', true); container .append('g').classed('chart-group', true); container .append('g').classed('metadata-group', true); } /** * Builds the gradient element to be used later * @return {void} */ function buildGradient() { svg.select('.metadata-group') .append('linearGradient') .attr('id', lineGradientId) .attr('x1', '0%') .attr('y1', '0%') .attr('x2', '100%') .attr('y2', '0%') .selectAll('stop') .data([ {offset:'0%', color: singleLineGradientColors[0]}, {offset:'100%', color: singleLineGradientColors[1]} ]) .enter() .append('stop') .attr('offset', ({offset}) =&gt; offset) .attr('stop-color', ({color}) =&gt; color) } /** * Creates the x and y scales of the graph * @private */ function buildScales(){ let minX = d3Array.min(dataByTopic, ({dates}) =&gt; d3Array.min(dates, getDate)), maxX = d3Array.max(dataByTopic, ({dates}) =&gt; d3Array.max(dates, getDate)), minY = d3Array.min(dataByTopic, ({dates}) =&gt; d3Array.min(dates, getValue)), maxY = d3Array.max(dataByTopic, ({dates}) =&gt; d3Array.max(dates, getValue)); xScale = d3Scale.scaleTime() .rangeRound([0, chartWidth]) .domain([minX, maxX]); yScale = d3Scale.scaleLinear() .rangeRound([chartHeight, 0]) .domain([Math.abs(minY), Math.abs(maxY)]) .nice(3); colorScale = d3Scale.scaleOrdinal() .range(colorSchema) .domain(dataByTopic.map(getTopic)); // TODO add spread and rest operators to britecharts /* let range = colorScale.range(); topicColorMap = colorScale.domain().reduce((memo, item, i) =&gt; ({...memo, [item]: range[i], }), {}); */ let range = colorScale.range(); topicColorMap = colorScale.domain().reduce((memo, item, i) =&gt; { memo[item] = range[i]; return memo; }, {}); } /** * Builds the SVG element that will contain the chart * * @param {HTMLElement} container DOM element that will work as the container of the graph * @private */ function buildSVG(container){ if (!svg) { svg = d3Selection.select(container) .append('svg') .classed('britechart line-chart', true); buildContainerGroups(); } svg .attr('width', width) .attr('height', height); } /** * Parses dates and values into JS Date objects and numbers * @param {obj} dataByTopic Raw data grouped by topic * @return {obj} Parsed data with dataByTopic and dataByDate */ function cleanData({dataByTopic, dataByDate}) { if (dataByTopic) { let flatData = []; dataByTopic.forEach((topic) =&gt; { topic.dates.forEach((date) =&gt; { flatData.push({ topicName: topic[topicNameLabel], name: topic[topicLabel], date: date[dateLabel], value: date[valueLabel] }); }); }); // Nest data by date and format dataByDate = d3Collection.nest() .key( getDate ) .entries(flatData) .map((d) =&gt; { return { date: new Date(d.key), topics: d.values } }); // Normalize dates in keys dataByDate = dataByDate.map((d) =&gt; { d.date = new Date(d.date); return d; }); // Normalize dataByTopic dataByTopic.forEach(function(kv) { kv.dates.forEach(function(d) { d.date = new Date(d[dateLabel]); d.value = +d[valueLabel]; }); }); } return {dataByTopic, dataByDate}; } /** * Removes all the datapoints highlighter circles added to the marker container * @return void */ function cleanDataPointHighlights(){ verticalMarkerContainer.selectAll('.circle-container').remove(); } /** * Draws the x and y axis on the svg object within their * respective groups * @private */ function drawAxis(){ svg.select('.x-axis-group .axis.x') .attr('transform', `translate(0, ${chartHeight})`) .call(xAxis); svg.select('.x-axis-group .month-axis') .attr('transform', `translate(0, ${(chartHeight + 28)})`) .call(xMonthAxis); svg.select('.y-axis-group.axis.y') .transition() .ease(ease) .attr('transform', `translate(${-xAxisPadding.left}, 0)`) .call(yAxis) .call(adjustYTickLabels); } /** * Draws the line elements within the chart group * @private */ function drawLines(){ let lines, topicLine, maskingRectangle; topicLine = d3Shape.line() .x(({date}) =&gt; xScale(date)) .y(({value}) =&gt; yScale(value)); lines = svg.select('.chart-group').selectAll('.line') .data(dataByTopic); lines.enter() .append('g') .attr('class', 'topic') .append('path') .attr('class', 'line') .attr('d', ({dates}) =&gt; topicLine(dates)) .style('stroke', (d) =&gt; ( dataByTopic.length === 1 ? `url(#${lineGradientId})` : getLineColor(d) )); lines .exit() .remove(); // We use a white rectangle to simulate the line drawing animation maskingRectangle = svg.append('rect') .attr('class', 'masking-rectangle') .attr('width', width) .attr('height', height) .attr('x', 0) .attr('y', 0); maskingRectangle.transition() .duration(animationDuration) .ease(ease) .attr('x', width) .on('end', () =&gt; maskingRectangle.remove()); } /** * Draws grid lines on the background of the chart * @return void */ function drawGridLines(){ maskGridLines = svg.select('.grid-lines-group') .selectAll('line.horizontal-grid-line') .data(yScale.ticks(5)) .enter() .append('line') .attr('class', 'horizontal-grid-line') .attr('x1', (-xAxisPadding.left - 30)) .attr('x2', chartWidth) .attr('y1', (d) =&gt; yScale(d)) .attr('y2', (d) =&gt; yScale(d)); //draw a horizontal line to extend x-axis till the edges baseLine = svg.select('.grid-lines-group') .selectAll('line.extended-x-line') .data([0]) .enter() .append('line') .attr('class', 'extended-x-line') .attr('x1', (-xAxisPadding.left - 30)) .attr('x2', chartWidth) .attr('y1', height - margin.bottom - margin.top) .attr('y2', height - margin.bottom - margin.top); } /** * Draws an overlay element over the graph * @inner * @return void */ function drawHoverOverlay(){ overlay = svg.select('.metadata-group') .append('rect') .attr('class','overlay') .attr('y1', 0) .attr('y2', height) .attr('height', height - margin.top - margin.bottom) .attr('width', width - margin.left - margin.right) .attr('fill', overlayColor) .style('display', 'none'); } /** * Creates the vertical marker * @return void */ function drawVerticalMarker(){ verticalMarkerContainer = svg.select('.metadata-group') .append('g') .attr('class', 'hover-marker vertical-marker-container') .attr('transform', 'translate(9999, 0)'); verticalMarkerLine = verticalMarkerContainer.selectAll('path') .data([{ x1: 0, y1: 0, x2: 0, y2: 0 }]) .enter() .append('line') .classed('vertical-marker', true) .attr('x1', 0) .attr('y1', height - margin.top - margin.bottom) .attr('x2', 0) .attr('y2', 0); } /** * Finds out which datapoint is closer to the given x position * @param {Number} x0 Date value for data point * @param {Object} d0 Previous datapoint * @param {Object} d1 Next datapoint * @return {Object} d0 or d1, the datapoint with closest date to x0 */ function findOutNearestDate(x0, d0, d1){ return (new Date(x0).getTime() - new Date(d0.date).getTime()) &gt; (new Date(d1.date).getTime() - new Date(x0).getTime()) ? d0 : d1; } /** * Calculates the maximum number of ticks for the x axis * @param {Number} width Chart width * @param {Number} dataPointNumber Number of entries on the data * @return {Number} Number of ticks to render */ function getMaxNumOfHorizontalTicks(width, dataPointNumber) { let ticksForWidth = Math.ceil(width / (singleTickWidth + horizontalTickSpacing)); return Math.min(dataPointNumber, ticksForWidth); } /** * Extract X position on the graph from a given mouse event * @param {Object} event D3 mouse event * @return {Number} Position on the x axis of the mouse */ function getMouseXPosition(event) { return d3Selection.mouse(event)[0]; } /** * Finds out the data entry that is closer to the given position on pixels * @param {Number} mouseX X position of the mouse * @return {Object} Data entry that is closer to that x axis position */ function getNearestDataPoint(mouseX) { let dateFromInvertedX = xScale.invert(mouseX); let bisectDate = d3Array.bisector(getDate).left; let dataEntryIndex = bisectDate(dataByDate, dateFromInvertedX, 1); let dataEntryForXPosition = dataByDate[dataEntryIndex]; let previousDataEntryForXPosition = dataByDate[dataEntryIndex - 1]; let nearestDataPoint; if (previousDataEntryForXPosition &amp;&amp; dataEntryForXPosition) { nearestDataPoint = findOutNearestDate(dateFromInvertedX, dataEntryForXPosition, previousDataEntryForXPosition); } else { nearestDataPoint = dataEntryForXPosition; } return nearestDataPoint; } /** * MouseMove handler, calculates the nearest dataPoint to the cursor * and updates metadata related to it * @private */ function handleMouseMove(){ let xPositionOffset = -margin.left, //Arbitrary number, will love to know how to assess it dataPoint = getNearestDataPoint(getMouseXPosition(this) + xPositionOffset), dataPointXPosition; if (dataPoint) { dataPointXPosition = xScale(new Date(dataPoint.date)); // More verticalMarker to that datapoint moveVerticalMarker(dataPointXPosition); // Add data points highlighting highlightDataPoints(dataPoint); // Emit event with xPosition for tooltip or similar feature dispatcher.call('customMouseMove', this, dataPoint, topicColorMap, dataPointXPosition); } } /** * MouseOut handler, hides overlay and removes active class on verticalMarkerLine * It also resets the container of the vertical marker * @private */ function handleMouseOut(data){ overlay.style('display', 'none'); verticalMarkerLine.classed('bc-is-active', false); verticalMarkerContainer.attr('transform', 'translate(9999, 0)'); dispatcher.call('customMouseOut', this, data); } /** * Mouseover handler, shows overlay and adds active class to verticalMarkerLine * @private */ function handleMouseOver(data){ overlay.style('display', 'block'); verticalMarkerLine.classed('bc-is-active', true); dispatcher.call('customMouseOver', this, data); } /** * Creates coloured circles marking where the exact data y value is for a given data point * @param {Object} dataPoint Data point to extract info from * @private */ function highlightDataPoints(dataPoint) { cleanDataPointHighlights(); // sorting the topics based on the order of the colors, // so that the order always stays constant dataPoint.topics = dataPoint.topics .filter(t =&gt; !!t) .sort((a, b) =&gt; topicColorMap[a.name] &gt; topicColorMap[b.name]); dataPoint.topics.forEach(({name}, index) =&gt; { let marker = verticalMarkerContainer .append('g') .classed('circle-container', true), circleSize = 12; marker.append('circle') .classed('data-point-highlighter', true) .attr('cx', circleSize) .attr('cy', 0) .attr('r', 5) .style('stroke', topicColorMap[name]); marker.attr('transform', `translate( ${(- circleSize)}, ${(yScale(dataPoint.topics[index].value))} )` ); }); } /** * Helper method to update the x position of the vertical marker * @param {Object} dataPoint Data entry to extract info * @return void */ function moveVerticalMarker(verticalMarkerXPosition){ verticalMarkerContainer.attr('transform', `translate(${verticalMarkerXPosition},0)`); } /** * Determines if we should add the tooltip related logic depending on the * size of the chart and the tooltipThreshold variable value * @return {Boolean} Should we build the tooltip? */ function shouldShowTooltip() { return width &gt; tooltipThreshold; } // API Methods /** * Gets or Sets the aspect ratio of the chart * @param {Number} _x Desired aspect ratio for the graph * @return { (Number | Module) } Current aspect ratio or Line Chart module to chain calls * @public */ exports.aspectRatio = function(_x) { if (!arguments.length) { return aspectRatio; } aspectRatio = _x; return this; }; /** * Gets or Sets the colorSchema of the chart * @param {String[]} _x Desired colorSchema for the graph * @return { colorSchema | module} Current colorSchema or Chart module to chain calls * @public */ exports.colorSchema = function(_x) { if (!arguments.length) { return colorSchema; } colorSchema = _x; return this; }; /** * Gets or Sets the dateLabel of the chart * @param {Number} _x Desired dateLabel for the graph * @return { dateLabel | module} Current dateLabel or Chart module to chain calls * @public */ exports.dateLabel = function(_x) { if (!arguments.length) { return dateLabel; } dateLabel = _x; return this; }; /** * Gets or Sets the height of the chart * @param {Number} _x Desired width for the graph * @return { (Number | Module) } Current height or Line Chart module to chain calls * @public */ exports.height = function(_x) { if (!arguments.length) { return height; } if (aspectRatio) { width = Math.ceil(_x / aspectRatio); } height = _x; return this; }; /** * Gets or Sets the margin of the chart * @param {Object} _x Margin object to get/set * @return { (Number | Module) } Current margin or Line Chart module to chain calls * @public */ exports.margin = function(_x) { if (!arguments.length) { return margin; } margin = _x; return this; }; /** * Gets or Sets the minimum width of the graph in order to show the tooltip * NOTE: This could also depend on the aspect ratio * @param {Number} _x Desired tooltip threshold for the graph * @return { (Number | Module) } Current tooltip threshold or Line Chart module to chain calls * @public */ exports.tooltipThreshold = function(_x) { if (!arguments.length) { return tooltipThreshold; } tooltipThreshold = _x; return this; }; /** * Gets or Sets the topicLabel of the chart * @param {Number} _x Desired topicLabel for the graph * @return { topicLabel | module} Current topicLabel or Chart module to chain calls * @public */ exports.topicLabel = function(_x) { if (!arguments.length) { return topicLabel; } topicLabel = _x; return this; }; /** * Gets or Sets the valueLabel of the chart * @param {Number} _x Desired valueLabel for the graph * @return { valueLabel | module} Current valueLabel or Chart module to chain calls * @public */ exports.valueLabel = function(_x) { if (!arguments.length) { return valueLabel; } valueLabel = _x; return this; }; /** * Gets or Sets the width of the chart * @param {Number} _x Desired width for the graph * @return { (Number | Module) } Current width or Line Chart module to chain calls * @public */ exports.width = function(_x) { if (!arguments.length) { return width; } if (aspectRatio) { height = Math.ceil(_x * aspectRatio); } width = _x; return this; }; /** * Chart exported to png and a download action is fired * @public */ exports.exportChart = function(filename, title) { exportChart.call(exports, svg, filename, title); }; /** * Exposes an 'on' method that acts as a bridge with the event dispatcher * We are going to expose this events: * customMouseHover, customMouseMove and customMouseOut * * @return {module} Bar Chart * @public */ exports.on = function() { let value = dispatcher.on.apply(dispatcher, arguments); return value === dispatcher ? exports : value; }; /** * Exposes the ability to force the chart to show a certain x axis grouping * @param {String} _x Desired format * @return { (String|Module) } Current format or module to chain calls */ exports.forceAxisFormat = function(_x) { if (!arguments.length) { return forceAxisSettings || defaultAxisSettings; } forceAxisSettings = _x; return this; }; /** * constants to be used to force the x axis to respect a certain granularity * current options: HOUR_DAY, DAY_MONTH, MONTH_YEAR * @example line.forceAxisFormat(line.axisTimeCombinations.HOUR_DAY) */ exports.axisTimeCombinations = axisTimeCombinations; return exports; }; }); × Search results Close "},"donut.js.html":{"id":"donut.js.html","title":"Source: donut.js","body":" API BarBrushDonutLegendLineMini-tooltipSparklineStacked-areaStepTooltip Demos _GETTINGSTARTEDbarbrushdonutkitchen-sinklinesparklinestacked-areastep Global Global Source: donut.js define(function(require){ 'use strict'; const d3Dispatch = require('d3-dispatch'); const d3Ease = require('d3-ease'); const d3Interpolate = require('d3-interpolate'); const d3Scale = require('d3-scale'); const d3Shape = require('d3-shape'); const d3Selection = require('d3-selection'); const d3Transition = require('d3-transition'); const exportChart = require('./helpers/exportChart'); const textHelper = require('./helpers/text'); const colorHelper = require('./helpers/colors'); /** * @typedef DonutChartData * @type {Object[]} * @property {Number} quantity Quantity of the group (required) * @property {Number} percentage Percentage of the total (required) * @property {String} name Name of the group (required) * @property {Number} id Identifier for the group required for legend feature (optional) * * @example * [ * { * quantity: 1, * percentage: 50, * name: 'glittering', * id: 1 * }, * { * quantity: 1, * percentage: 50, * name: 'luminous', * id: 2 * } * ] */ /** * Reusable Donut Chart API class that renders a * simple and configurable donut chart. * * @module Donut * @tutorial donut * @requires d3-dispatch, d3-ease, d3-interpolate, d3-scale, d3-shape, d3-selection * * @example * var donutChart = donut(); * * donutChart * .externalRadius(500) * .internalRadius(200); * * d3Selection.select('.css-selector') * .datum(dataset) * .call(donutChart); * */ return function module() { let margin = { top: 0, right: 0, bottom: 0, left: 0 }, width = 300, height = 300, ease = d3Ease.easeCubicInOut, arcTransitionDuration = 750, pieDrawingTransitionDuration = 1200, pieHoverTransitionDuration = 150, radiusHoverOffset = 12, paddingAngle = 0.016, data, chartWidth, chartHeight, externalRadius = 140, internalRadius = 45.5, legendWidth = externalRadius + internalRadius, layout, shape, slices, svg, quantityLabel = 'quantity', nameLabel = 'name', percentageLabel = 'percentage', // colors colorScale = d3Scale.schemeCategory20c, colorSchema = colorHelper.colorSchemas.britechartsColorSchema, // utils storeAngle = function(d) { this._current = d; }, reduceOuterRadius = d =&gt; { d.outerRadius = externalRadius - radiusHoverOffset; }, sortComparator = (a, b) =&gt; b.quantity - a.quantity, // extractors getQuantity = ({quantity}) =&gt; quantity, getSliceFill = ({data}) =&gt; colorScale(data.name), // events dispatcher = d3Dispatch.dispatch('customMouseOver', 'customMouseOut', 'customMouseMove'); /** * This function creates the graph using the selection as container * * @param {D3Selection} _selection A d3 selection that represents * the container(s) where the chart(s) will be rendered * @param {DonutChartData} _data The data to attach and generate the chart */ function exports(_selection) { _selection.each(function(_data) { chartWidth = width - margin.left - margin.right; chartHeight = height - margin.top - margin.bottom; data = cleanData(_data); buildLayout(); buildColorScale(); buildShape(); buildSVG(this); drawSlices(); initTooltip(); }); } /** * Builds color scale for chart, if any colorSchema was defined * @private */ function buildColorScale() { if (colorSchema) { colorScale = d3Scale.scaleOrdinal().range(colorSchema); } } /** * Builds containers for the chart, the legend and a wrapper for all of them * @private */ function buildContainerGroups() { let container = svg .append('g') .classed('container-group', true) .attr('transform', `translate(${width / 2}, ${height / 2})`); container.append('g').classed('chart-group', true); container.append('g').classed('legend-group', true); } /** * Builds the pie layout that will produce data ready to draw * @private */ function buildLayout() { layout = d3Shape.pie() .padAngle(paddingAngle) .value(getQuantity) .sort(sortComparator); } /** * Builds the shape function * @private */ function buildShape() { shape = d3Shape.arc() .innerRadius(internalRadius) .padRadius(externalRadius); } /** * Builds the SVG element that will contain the chart * * @param {HTMLElement} container DOM element that will work as the container of the graph * @private */ function buildSVG(container) { if (!svg) { svg = d3Selection.select(container) .append('svg') .classed('britechart donut-chart', true) .data([data]); //TO REVIEW buildContainerGroups(); } svg .transition() .ease(ease) .attr('width', width + margin.left + margin.right) .attr('height', height + margin.top + margin.bottom); } /** * Cleaning data adding the proper format * @param {DonutChartData} data Data * @private */ function cleanData(data) { return data.map((d) =&gt; { d.quantity = +d[quantityLabel]; d.name = String(d[nameLabel]); d.percentage = String(d[percentageLabel]); return d; }); } /** * Draws the values on the donut slice inside the text element * * @param {Object} obj Data object * @private */ function drawLegend(obj) { if (obj.data) { svg.select('.donut-text') .text(() =&gt; `${obj.data.percentage}% ${ obj.data.name}`) .attr('dy', '.2em') .attr('text-anchor', 'middle'); svg.select('.donut-text').call(wrapText, legendWidth); } } /** * Draws the slices of the donut * @private */ function drawSlices() { if (!slices) { slices = svg.select('.chart-group') .selectAll('g.arc') .data(layout(data)); slices.enter() .append('g') .each(storeAngle) .each(reduceOuterRadius) .classed('arc', true) .on('mouseover', handleMouseOver) .on('mouseout', handleMouseOut) .merge(slices) .append('path') .attr('fill', getSliceFill) .on('mouseover', tweenGrowthFactory(externalRadius, 0)) .on('mouseout', tweenGrowthFactory(externalRadius - radiusHoverOffset, pieHoverTransitionDuration)) .transition() .ease(ease) .duration(pieDrawingTransitionDuration) .attrTween('d', tweenLoading); } else { slices = svg.select('.chart-group') .selectAll('path') .data(layout(data)); slices .attr('d', shape); // Redraws the angles of the data slices .transition() .duration(arcTransitionDuration) .attrTween('d', tweenArc); } } /** * Cleans any value that could be on the legend text element * @private */ function cleanLegend() { svg.select('.donut-text').text(''); } function handleMouseOver(datum) { drawLegend(datum); dispatcher.call('customMouseOver', this, datum); } function handleMouseOut() { cleanLegend(); dispatcher.call('customMouseOut', this); } /** * Creates the text element that will hold the legend of the chart */ function initTooltip() { svg.select('.legend-group') .append('text') .attr('class', 'donut-text'); } /** * Stores current angles and interpolates with new angles * Check out {@link http://bl.ocks.org/mbostock/1346410| this example} * * @param {Object} a New data for slice * @return {Function} Tweening function for the donut shape * @private */ function tweenArc(a) { let i = d3Interpolate.interpolate(this._current, a); this._current = i(0); return function(t) { return shape(i(t)); }; } /** * Generates animations with tweens depending on the attributes given * * @param {Number} outerRadius Final outer radius value * @param {Number} delay Delay of animation * @return {Function} Function that when called will tween the element * @private */ function tweenGrowthFactory(outerRadius, delay) { return function() { d3Selection.select(this) .transition() .delay(delay) .attrTween('d', function(d) { let i = d3Interpolate.interpolate(d.outerRadius, outerRadius); return (t) =&gt; { d.outerRadius = i(t); return shape(d); }; }); }; } /** * Animation for chart loading * Check out {@link http://bl.ocks.org/mbostock/4341574| this example} * * @param {Object} b Data point * @return {Function} Tween function * @private */ function tweenLoading(b) { let i; b.innerRadius = 0; i = d3Interpolate.interpolate({ startAngle: 0, endAngle: 0}, b); return function(t) { return shape(i(t)); }; } /** * Utility function that wraps a text into the given width * * @param {D3Selection} text Text to write * @param {Number} legendWidth Width of the container * @private */ function wrapText(text, legendWidth) { let fontSize = externalRadius / 5; textHelper.wrapText.call(null, 0, fontSize, legendWidth, text.node()); } /** * Gets or Sets the colorSchema of the chart * @param {String[]} _x Desired colorSchema for the graph * @return { colorSchema | module} Current colorSchema or Chart module to chain calls * @public */ exports.colorSchema = function(_x) { if (!arguments.length) { return colorSchema; } colorSchema = _x; return this; }; /** * Gets or Sets the externalRadius of the chart * @param {Number} _x ExternalRadius number to get/set * @return { (Number | Module) } Current externalRadius or Donut Chart module to chain calls * @public */ exports.externalRadius = function(_x) { if (!arguments.length) { return externalRadius; } externalRadius = _x; return this; }; /** * Gets or Sets the height of the chart * @param {Number} _x Desired width for the graph * @return { (Number | Module) } Current height or Donut Chart module to chain calls * @public */ exports.height = function(_x) { if (!arguments.length) { return height; } height = _x; return this; }; /** * Gets or Sets the internalRadius of the chart * @param {Number} _x InternalRadius number to get/set * @return { (Number | Module) } Current internalRadius or Donut Chart module to chain calls * @public */ exports.internalRadius = function(_x) { if (!arguments.length) { return internalRadius; } internalRadius = _x; return this; }; /** * Gets or Sets the margin of the chart * @param {Object} _x Margin object to get/set * @return { (Number | Module) } Current margin or Donut Chart module to chain calls * @public */ exports.margin = function(_x) { if (!arguments.length) { return margin; } margin = _x; return this; }; /** * Gets or Sets the width of the chart * @param {Number} _x Desired width for the graph * @return { (Number | Module) } Current width or Donut Chart module to chain calls * @public */ exports.width = function(_x) { if (!arguments.length) { return width; } width = _x; return this; }; /** * Chart exported to png and a download action is fired * @public */ exports.exportChart = function(filename, title) { exportChart.call(exports, svg, filename, title); }; /** * Exposes an 'on' method that acts as a bridge with the event dispatcher * We are going to expose this events: * customMouseOver, customMouseMove and customMouseOut * * @return {module} Bar Chart * @public */ exports.on = function() { let value = dispatcher.on.apply(dispatcher, arguments); return value === dispatcher ? exports : value; }; return exports; }; }); × Search results Close "},"legend.js.html":{"id":"legend.js.html","title":"Source: legend.js","body":" API BarBrushDonutLegendLineMini-tooltipSparklineStacked-areaStepTooltip Demos _GETTINGSTARTEDbarbrushdonutkitchen-sinklinesparklinestacked-areastep Global Global Source: legend.js define(function(require){ 'use strict'; const d3 = require('d3'); const d3Format = require('d3-format'); const d3Scale = require('d3-scale'); const d3Selection = require('d3-selection'); const d3Transition = require('d3-transition'); const colorHelper = require('./helpers/colors'); /** * @typedef LegendChartData * @type {Object[]} * @property {Number} id Id of the group (required) * @property {Number} quantity Quantity of the group (required) * @property {String} name Name of the group (required) * * @example * [ * { * id: 1, * quantity: 2, * name: 'glittering' * }, * { * id: 2, * quantity: 3, * name: 'luminous' * } */ /** * @fileOverview Legend Component reusable API class that renders a * simple and configurable legend element. * * @example * var donutChart = donut(), * legendBox = legend(); * * donutChart * .externalRadius(500) * .internalRadius(200) * .on('customMouseOver', function(data) { * legendBox.highlight(data.data.id); * }) * .on('customMouseOut', function() { * legendBox.clearHighlight(); * }); * * d3Selection.select('.css-selector') * .datum(dataset) * .call(donutChart); * * d3Selection.select('.other-css-selector') * .datum(dataset) * .call(legendBox); * * @module Legend * @tutorial legend * @exports charts/legend * @requires d3 */ return function module() { let margin = { top: 0, right: 0, bottom: 0, left: 0 }, width = 320, height = 180, lineMargin = 12, circleRadius = 8, circleYOffset = -5, textSize = 12, textLetterSpacing = 0.5, valueReservedSpace = 40, numberLetterSpacing = 0.8, numberFormat = d3Format.format('s'), isFadedClassName = 'is-faded', // colors colorScale, colorSchema = colorHelper.colorSchemas.britechartsColorSchema, getId = ({id}) =&gt; id, getName = ({name}) =&gt; name, getFormattedQuantity = ({quantity}) =&gt; numberFormat(quantity), entries, chartWidth, chartHeight, data, svg; /** * This function creates the graph using the selection as container * @param {D3Selection} _selection A d3 selection that represents * the container(s) where the chart(s) will be rendered * @param {object} _data The data to attach and generate the chart */ function exports(_selection) { _selection.each(function(_data){ chartWidth = width - margin.left - margin.right; chartHeight = height - margin.top - margin.bottom; data = _data; buildColorScale(); buildSVG(this); drawEntries(); }); } /** * Builds containers for the legend * Also applies the Margin convention * @private */ function buildContainerGroups() { let container = svg .append('g') .classed('legend-container-group', true) .attr('transform', `translate(${margin.left},${margin.top})`); container .append('g') .classed('legend-group', true); } /** * Builds color scale for chart, if any colorSchema was defined * @private */ function buildColorScale() { colorScale = d3Scale.scaleOrdinal().range(colorSchema); } /** * Builds the SVG element that will contain the chart * @param {HTMLElement} container DOM element that will work as the container of the graph * @private */ function buildSVG(container) { if (!svg) { svg = d3Selection.select(container) .append('svg') .classed('britechart britechart-legend', true); buildContainerGroups(); } svg .transition() .attr('width', width + margin.left + margin.right) .attr('height', height + margin.top + margin.bottom); } /** * Removes the faded class from all the entry lines */ function cleanFadedLines() { svg.select('.legend-group') .selectAll('g.legend-line') .classed(isFadedClassName, false); } /** * Draws the entries of the legend * @private */ function drawEntries() { entries = svg.select('.legend-group') .selectAll('g.legend-line') .data(data); // Enter entries.enter() .append('g') .classed('legend-line', true) .attr('data-item', getId) .attr('transform', function(d, i) { let horizontalOffset = 2 * circleRadius + 10, lineHeight = chartHeight/ (data.length + 1), verticalOffset = (i + 1) * lineHeight; return `translate(${horizontalOffset},${verticalOffset})`; }) .merge(entries) .append('circle') .classed('legend-circle', true) .attr('cx', 0) .attr('cy', circleYOffset) .attr('r', circleRadius) .style('fill', function({quantity}) { return colorScale(quantity); }) .style('stroke-width', 1); svg.select('.legend-group') .selectAll('g.legend-line') .append('text') .classed('legend-entry-name', true) .text(getName) .attr('x', (2 * circleRadius) + lineMargin) .style('font-size', `${textSize}px`) .style('letter-spacing', `${textLetterSpacing}px`); svg.select('.legend-group') .selectAll('g.legend-line') .append('text') .classed('legend-entry-value', true) .text(getFormattedQuantity) .attr('x', chartWidth - valueReservedSpace) .style('font-size', `${textSize}px`) .style('letter-spacing', `${numberLetterSpacing}px`) .style('text-anchor', 'end') .style('startOffset', '100%'); // Exit svg.select('.legend-group') .selectAll('g.legend-line') .exit() .transition() .style('opacity', 0) .remove(); } /** * Applies the faded class to all lines but the one that has the given id * @param {number} exceptionItemId Id of the line that needs to stay the same */ function fadeLinesBut(exceptionItemId) { svg.select('.legend-group') .selectAll('g.legend-line') .classed(isFadedClassName, true); d3Selection.select(`[data-item=&quot;${exceptionItemId}&quot;]`) .classed(isFadedClassName, false); } /** * Clears the highlighted line entry */ exports.clearHighlight = function() { cleanFadedLines(); }; /** * Gets or Sets the colorSchema of the chart * @param {Array} _x Color scheme array to get/set * @return { (Number | Module) } Current colorSchema or Donut Chart module to chain calls * @public */ exports.colorSchema = function(_x) { if (!arguments.length) { return colorSchema; } colorSchema = _x; return this; }; /** * Gets or Sets the height of the legend chart * @param {number} _x Desired width for the chart * @return { height | module} Current height or Legend module to chain calls * @public */ exports.height = function(_x) { if (!arguments.length) { return height; } height = _x; return this; }; /** * Highlights a line entry by fading the rest of lines * @param {number} entryId ID of the entry line */ exports.highlight = function(entryId) { cleanFadedLines(); fadeLinesBut(entryId); }; /** * Gets or Sets the margin of the legend chart * @param {object} _x Margin object to get/set * @return { margin | module} Current margin or Legend module to chain calls * @public */ exports.margin = function(_x) { if (!arguments.length) { return margin; } margin = _x; return this; }; /** * Gets or Sets the width of the legend chart * @param {number} _x Desired width for the graph * @return { width | module} Current width or Legend module to chain calls * @public */ exports.width = function(_x) { if (!arguments.length) { return width; } width = _x; return this; }; return exports; }; }); × Search results Close "},"mini-tooltip.js.html":{"id":"mini-tooltip.js.html","title":"Source: mini-tooltip.js","body":" API BarBrushDonutLegendLineMini-tooltipSparklineStacked-areaStepTooltip Demos _GETTINGSTARTEDbarbrushdonutkitchen-sinklinesparklinestacked-areastep Global Global Source: mini-tooltip.js define(function(require){ 'use strict'; const d3Array = require('d3-array'); const d3Ease = require('d3-ease'); const d3Format = require('d3-format'); const d3Selection = require('d3-selection'); const d3Transition = require('d3-transition'); /** * Mini Tooltip Component reusable API class that renders a * simple and configurable tooltip element for Britechart's * bar and step chart. * * @module Mini-tooltip * @tutorial bar * @requires d3 * * @example * var barChart = line(), * miniTooltip = miniTooltip(); * * barChart * .width(500) * .height(300) * .on('customMouseHover', miniTooltip.show) * .on('customMouseMove', miniTooltip.update) * .on('customMouseOut', miniTooltip.hide); * * d3Selection.select('.css-selector') * .datum(dataset) * .call(barChart); * * d3Selection.select('.metadata-group .mini-tooltip-container') * .datum([]) * .call(miniTooltip); * */ return function module() { let margin = { top: 12, right: 12, bottom: 12, left: 12 }, width = 100, height = 100, // Optional Title title = '', // Data Format valueLabel = 'value', nameLabel = 'name', // Animations mouseChaseDuration = 100, ease = d3Ease.easeQuadInOut, // tooltip tooltipBackground, backgroundBorderRadius = 1, tooltipTextContainer, tooltipOffset = { y: 0, x: 20 }, // Fonts textSize = 14, textLineHeight = 1.5, valueTextSize = 27, valueTextLineHeight = 1.18, // Colors bodyFillColor = '#FFFFFF', borderStrokeColor = '#D2D6DF', titleFillColor = '#666a73', nameTextFillColor = '#666a73', valueTextFillColor = '#45494E', valueTextWeight = 200, // formats tooltipValueFormat = d3Format.format('.2f'), chartWidth, chartHeight, svg; /** * This function creates the graph using the selection as container * @param {D3Selection} _selection A d3 selection that represents * the container(s) where the chart(s) will be rendered * @param {Array} _data The data to attach and generate the chart (usually an empty array) */ function exports(_selection) { _selection.each(function(_data){ chartWidth = width - margin.left - margin.right; chartHeight = height - margin.top - margin.bottom; buildSVG(this); drawTooltip(); }); } /** * Builds containers for the tooltip * Also applies the Margin convention * @private */ function buildContainerGroups() { let container = svg.append('g') .classed('tooltip-container-group', true) .attr('transform', `translate( ${margin.left}, ${margin.top})`); container.append('g').classed('tooltip-group', true); } /** * Builds the SVG element that will contain the chart * @param {HTMLElement} container DOM element that will work as the container of the graph * @private */ function buildSVG(container) { if (!svg) { svg = d3Selection.select(container) .append('g') .classed('britechart britechart-mini-tooltip', true); buildContainerGroups(); } svg .attr('width', width + margin.left + margin.right) .attr('height', height + margin.top + margin.bottom); // Hidden by default exports.hide(); } /** * Draws the different elements of the Tooltip box * @return void */ function drawTooltip(){ tooltipTextContainer = svg.selectAll('.tooltip-group') .append('g') .classed('tooltip-text', true); tooltipBackground = tooltipTextContainer .append('rect') .classed('tooltip-background', true) .attr('width', width) .attr('height', height) .attr('rx', backgroundBorderRadius) .attr('ry', backgroundBorderRadius) .attr('y', - margin.top) .attr('x', - margin.left) .style('fill', bodyFillColor) .style('stroke', borderStrokeColor) .style('stroke-width', 1) .style('pointer-events', 'none') .style('opacity', 0.9); } /** * Figures out the max length of the tooltip lines * @param {D3Selection[]} texts List of svg elements of each line * @return {Number} Max size of the lines */ function getMaxLengthLine(...texts) { let textSizes = texts.filter(x =&gt; !!x) .map(x =&gt; x.node().getBBox().width); return d3Array.max(textSizes); } /** * Calculates the desired position for the tooltip * @param {Number} mouseX Current horizontal mouse position * @param {Number} mouseY Current vertical mouse position * @param {Number} parentChartWidth Parent's chart width * @param {Number} parentChartHeight Parent's chart height * @return {Number[]} X and Y position * @private */ function getTooltipPosition([mouseX, mouseY], [parentChartWidth, parentChartHeight]) { let tooltipX, tooltipY; if (hasEnoughHorizontalRoom(parentChartWidth, mouseX)) { tooltipX = mouseX + tooltipOffset.x; } else { tooltipX = mouseX - chartWidth - tooltipOffset.x - margin.right; } if (hasEnoughVerticalRoom(parentChartHeight, mouseY)) { tooltipY = mouseY + tooltipOffset.y; } else { tooltipY = mouseY - chartHeight - tooltipOffset.y - margin.bottom; } return [tooltipX, tooltipY]; } /** * Checks if the mouse is over the bounds of the parent chart * @param {Number} chartWidth Parent's chart * @param {Number} positionX Mouse position * @return {Boolean} If the mouse position allows space for the tooltip */ function hasEnoughHorizontalRoom(parentChartWidth, positionX) { return (parentChartWidth - margin.left - margin.right - chartWidth) - positionX &gt; 0; } /** * Checks if the mouse is over the bounds of the parent chart * @param {Number} chartWidth Parent's chart * @param {Number} positionX Mouse position * @return {Boolean} If the mouse position allows space for the tooltip */ function hasEnoughVerticalRoom(parentChartHeight, positionY) { return (parentChartHeight - margin.top - margin.bottom - chartHeight) - positionY &gt; 0; } /** * Hides the tooltip * @return {void} */ function hideTooltip() { svg.style('display', 'none'); } /** * Shows the tooltip updating it's content * @param {Object} dataPoint Data point from the chart * @return {void} */ function showTooltip(dataPoint) { updateContent(dataPoint); svg.style('display', 'block'); } /** * Draws the data entries inside the tooltip for a given topic * @param {Object} topic Topic to extract data from * @return void */ function updateContent(dataPoint = {}){ let value = dataPoint[valueLabel] || '', name = dataPoint[nameLabel] || '', lineHeight = textSize * textLineHeight, valueLineHeight = valueTextSize * valueTextLineHeight, defaultDy = '1em', temporalHeight = 0, tooltipValue, tooltipName, tooltipTitle; tooltipTextContainer.selectAll('text') .remove(); if (title) { tooltipTitle = tooltipTextContainer .append('text') .classed('mini-tooltip-title', true) .attr('dy', defaultDy) .attr('y', 0) .style('fill', titleFillColor) .style('font-size', textSize) .text(title); temporalHeight = lineHeight + temporalHeight; } if (name) { tooltipName = tooltipTextContainer .append('text') .classed('mini-tooltip-name', true) .attr('dy', defaultDy) .attr('y', temporalHeight || 0) .style('fill', nameTextFillColor) .style('font-size', textSize) .text(name); temporalHeight = lineHeight + temporalHeight; } if (value) { tooltipValue = tooltipTextContainer .append('text') .classed('mini-tooltip-value', true) .attr('dy', defaultDy) .attr('y', temporalHeight || 0) .style('fill', valueTextFillColor) .style('font-size', valueTextSize) .style('font-weight', valueTextWeight) .text(tooltipValueFormat(value)); temporalHeight = valueLineHeight + temporalHeight; } chartWidth = getMaxLengthLine(tooltipName, tooltipTitle, tooltipValue); chartHeight = temporalHeight; } /** * Updates size and position of tooltip depending on the side of the chart we are in * @param {Object} dataPoint DataPoint of the tooltip * @return void */ function updatePositionAndSize(mousePosition, parentChartSize) { let [tooltipX, tooltipY] = getTooltipPosition(mousePosition, parentChartSize); svg.transition() .duration(mouseChaseDuration) .ease(ease) .attr('height', chartHeight + margin.top + margin.bottom) .attr('width', chartWidth + margin.left + margin.right) .attr('transform', `translate(${tooltipX},${tooltipY})`); tooltipBackground .attr('height', chartHeight + margin.top + margin.bottom) .attr('width', chartWidth + margin.left + margin.right); } /** * Updates tooltip content, size and position * * @param {Object} dataPoint Current datapoint to show info about * @return void */ function updateTooltip(dataPoint, position, chartSize) { updateContent(dataPoint); updatePositionAndSize(position, chartSize); } /** * Hides the tooltip * @return {Module} Tooltip module to chain calls * @public */ exports.hide = function() { hideTooltip(); return this; }; /** * Gets or Sets data's nameLabel * @param {text} _x Desired nameLabel * @return { text | module} nameLabel or Step Chart module to chain calls * @public */ exports.nameLabel = function(_x) { if (!arguments.length) { return nameLabel; } nameLabel = _x; return this; }; /** * Shows the tooltip * @return {Module} Tooltip module to chain calls * @public */ exports.show = function() { showTooltip(); return this; }; /** * Gets or Sets the title of the tooltip * @param {string} _x Desired title * @return { string | module} Current title or module to chain calls * @public */ exports.title = function(_x) { if (!arguments.length) { return title; } title = _x; return this; }; /** * Updates the position and content of the tooltip * @param {Object} dataPoint Datapoint of the hovered element * @param {Array} mousePosition Mouse position relative to the parent chart [x, y] * @param {Array} chartSize Parent chart size [x, y] * @return {module} Current component */ exports.update = function(dataPoint, mousePosition, chartSize) { updateTooltip(dataPoint, mousePosition, chartSize); return this; }; return exports; }; }); × Search results Close "},"sparkline.js.html":{"id":"sparkline.js.html","title":"Source: sparkline.js","body":" API BarBrushDonutLegendLineMini-tooltipSparklineStacked-areaStepTooltip Demos _GETTINGSTARTEDbarbrushdonutkitchen-sinklinesparklinestacked-areastep Global Global Source: sparkline.js define(function(require){ 'use strict'; const d3Array = require('d3-array'); const d3Ease = require('d3-ease'); const d3Scale = require('d3-scale'); const d3Shape = require('d3-shape'); const d3Selection = require('d3-selection'); const d3Transition = require('d3-transition'); const exportChart = require('./helpers/exportChart'); const colorHelper = require('./helpers/colors'); /** * @typedef SparklineChartData * @type {Object[]} * @property {Number} value Value of the group (required) * @property {String} name Name of the group (required) * * @example * [ * { * value: 1, * date: '2011-01-06T00:00:00Z' * }, * { * value: 2, * date: '2011-01-07T00:00:00Z' * } */ /** * Sparkline Chart reusable API module that allows us * rendering a sparkline configurable chart. * * @module Sparkline * @tutorial sparkline * @requires d3 * * @example * var sparkLineChart = sparkline(); * * sparkLineChart * .width(200) * .height(100); * * d3Selection.select('.css-selector') * .datum(dataset) * .call(sparkLineChart); * */ return function module(){ let margin = { left: 5, right: 5, top: 5, bottom: 5 }, width = 100, height = 30, xScale, yScale, areaGradient = ['#F5FDFF', '#F6FEFC'], lineGradient = colorHelper.colorGradients.greenBlueGradient, svg, chartWidth, chartHeight, data, hasArea = true, isAnimated = false, clipDuration = 3000, ease = d3Ease.easeQuadInOut, line, markerSize = 1.5, valueLabel = 'value', dateLabel = 'date', // getters getDate = ({date}) =&gt; date, getValue = ({value}) =&gt; value; /** * This function creates the graph using the selection and data provided * * @param {D3Selection} _selection A d3 selection that represents * the container(s) where the chart(s) will be rendered * @param {SparklineChartData} _data The data to attach and generate the chart */ function exports(_selection) { _selection.each(function(_data){ chartWidth = width - margin.left - margin.right; chartHeight = height - margin.top - margin.bottom; data = cleanData(_data); buildScales(); buildSVG(this); createGradients(); createMaskingClip(); drawLine(); drawArea(); drawEndMarker(); }); } /** * Builds containers for the chart, the axis and a wrapper for all of them * NOTE: The order of drawing of this group elements is really important, * as everything else will be drawn on top of them * @private */ function buildContainerGroups(){ let container = svg.append('g') .classed('container-group', true) .attr('transform', `translate(${margin.left},${margin.top})`); container .append('g').classed('chart-group', true); container .append('g').classed('metadata-group', true); } /** * Creates the x, y and color scales of the chart * @private */ function buildScales(){ xScale = d3Scale.scaleLinear() .domain(d3Array.extent(data, getDate)) .range([0, chartWidth]); yScale = d3Scale.scaleLinear() .domain(d3Array.extent(data, getValue)) .range([chartHeight, 0]); } /** * Builds the SVG element that will contain the chart * @param {HTMLElement} container DOM element that will work as the container of the graph * @private */ function buildSVG(container){ if (!svg) { svg = d3Selection.select(container) .append('svg') .classed('britechart sparkline', true); buildContainerGroups(); } svg .transition() .ease(ease) .attr('width', width) .attr('height', height); } /** * Cleaning data adding the proper format * @param {array} data Data * @private */ function cleanData(data) { return data.map((d) =&gt; { d.date = new Date(d[dateLabel]); d.value = +d[valueLabel]; return d; }); } /** * Creates the gradient on the area below the line * @return {void} */ function createGradients() { let metadataGroup = svg.select('.metadata-group'); metadataGroup.append('linearGradient') .attr('id', 'sparkline-area-gradient') .attr('gradientUnits', 'userSpaceOnUse') .attr('x1', 0) .attr('x2', xScale(data[data.length - 1].date)) .attr('y1', 0) .attr('y2', 0) .selectAll('stop') .data([ {offset: '0%', color: areaGradient[0]}, {offset: '100%', color: areaGradient[1]} ]) .enter().append('stop') .attr('offset', ({offset}) =&gt; offset) .attr('stop-color', ({color}) =&gt; color); metadataGroup.append('linearGradient') .attr('id', 'sparkline-line-gradient') .attr('gradientUnits', 'userSpaceOnUse') .attr('x1', 0) .attr('x2', xScale(data[data.length - 1].date)) .attr('y1', 0) .attr('y2', 0) .selectAll('stop') .data([ {offset: '0%', color: lineGradient[0]}, {offset: '100%', color: lineGradient[1]} ]) .enter().append('stop') .attr('offset', ({offset}) =&gt; offset) .attr('stop-color', ({color}) =&gt; color); } /** * Creates a masking clip that would help us fake an animation if the * proper flag is true * * @return {void} */ function createMaskingClip() { if (isAnimated) { svg.select('.metadata-group') .append('clipPath') .attr('id', 'maskingClip') .append('rect') .attr('width', 0) .attr('height', height); d3Selection.select('#maskingClip rect') .transition() .ease(ease) .duration(clipDuration) .attr('width', width); } } /** * Draws the area that will be placed below the line * @private */ function drawArea(){ let area = d3Shape.area() .x(({date}) =&gt; xScale(date)) .y0(() =&gt; yScale(0)) .y1(({value}) =&gt; yScale(value)) .curve(d3Shape.curveBasis); svg.select('.chart-group') .append('path') .datum(data) .attr('class', 'sparkline-area') .attr('d', area) .attr('clip-path', 'url(#maskingClip)'); } /** * Draws the line element within the chart group * @private */ function drawLine(){ line = d3Shape.line() .curve(d3Shape.curveBasis) .x(({date}) =&gt; xScale(date)) .y(({value}) =&gt; yScale(value)); svg.select('.chart-group') .append('path') .datum(data) .attr('class', 'line') .attr('d', line) .attr('clip-path', 'url(#maskingClip)'); } /** * Draws a marker at the end of the sparkline */ function drawEndMarker(){ svg.selectAll('.chart-group') .append('circle') .attr('class', 'sparkline-circle') .attr('cx', xScale(data[data.length - 1].date)) .attr('cy', yScale(data[data.length - 1].value)) .attr('r', markerSize); } // Accessors /** * Gets or Sets the dateLabel of the chart * @param {Number} _x Desired dateLabel for the graph * @return { dateLabel | module} Current dateLabel or Chart module to chain calls * @public */ exports.dateLabel = function(_x) { if (!arguments.length) { return dateLabel; } dateLabel = _x; return this; }; /** * Gets or Sets the duration of the animation * @param {Number} _x Desired animation duration for the graph * @return { dateLabel | module} Current animation duration or Chart module to chain calls * @public */ exports.duration = function(_x) { if (!arguments.length) { return clipDuration; } clipDuration = _x; return this; }; /** * Gets or Sets the areaGradient of the chart * @param {String[]} _x Desired areaGradient for the graph * @return { areaGradient | module} Current areaGradient or Chart module to chain calls * @public */ exports.areaGradient = function(_x) { if (!arguments.length) { return areaGradient; } areaGradient = _x; return this; }; /** * Gets or Sets the lineGradient of the chart * @param {String[]} _x Desired lineGradient for the graph * @return { lineGradient | module} Current lineGradient or Chart module to chain calls * @public */ exports.lineGradient = function(_x) { if (!arguments.length) { return lineGradient; } lineGradient = _x; return this; }; /** * Gets or Sets the height of the chart * @param {Number} _x Desired width for the graph * @return { height | module} Current height or Chart module to chain calls * @public */ exports.height = function(_x) { if (!arguments.length) { return height; } height = _x; return this; }; /** * Gets or Sets the isAnimated property of the chart * @param {Boolean} _x Desired animation flag * @return { isAnimated | module} Current isAnimated flag or Chart module * @public */ exports.isAnimated = function(_x) { if (!arguments.length) { return isAnimated; } isAnimated = _x; return this; }; /** * Gets or Sets the margin of the chart * @param {Object} _x Margin object to get/set * @return { margin | module} Current margin or Chart module to chain calls * @public */ exports.margin = function(_x) { if (!arguments.length) { return margin; } margin = _x; return this; }; /** * Gets or Sets the width of the chart * @param {Number} _x Desired width for the graph * @return { width | module} Current width or Chart module to chain calls * @public */ exports.width = function(_x) { if (!arguments.length) { return width; } width = _x; return this; }; /** * Gets or Sets the valueLabel of the chart * @param {Number} _x Desired valueLabel for the graph * @return { valueLabel | module} Current valueLabel or Chart module to chain calls * @public */ exports.valueLabel = function(_x) { if (!arguments.length) { return valueLabel; } valueLabel = _x; return this; }; /** * Chart exported to png and a download action is fired * @public */ exports.exportChart = function(filename, title) { exportChart.call(exports, svg, filename, title); }; return exports; }; }); × Search results Close "},"step.js.html":{"id":"step.js.html","title":"Source: step.js","body":" API BarBrushDonutLegendLineMini-tooltipSparklineStacked-areaStepTooltip Demos _GETTINGSTARTEDbarbrushdonutkitchen-sinklinesparklinestacked-areastep Global Global Source: step.js define(function(require) { 'use strict'; const d3Array = require('d3-array'); const d3Axis = require('d3-axis'); const d3Dispatch = require('d3-dispatch'); const d3Ease = require('d3-ease'); const d3Format = require('d3-format'); const d3Scale = require('d3-scale'); const d3Selection = require('d3-selection'); const d3Transition = require('d3-transition'); const exportChart = require('./helpers/exportChart'); /** * @typedef StepChartData * @type Object[] * * @property {String} key Key we measure (required) * @property {Number} value value of the key (required) * * @example * [ * { * value: 1, * key: 'glittering' * }, * { * value: 1, * key: 'luminous' * } * ] */ /** * Step Chart reusable API class that renders a * simple and configurable step chart. * * @module Step * @tutorial step * @requires d3-array, d3-axis, d3-dispatch, d3-format, d3-scale, d3-selection, d3-transition * * @example * var stepChart= step(); * * stepChart * .height(500) * .width(800); * * d3Selection.select('.css-selector') * .datum(dataset) * .call(stepChart); * */ return function module() { let margin = {top: 20, right: 20, bottom: 30, left: 40}, width = 960, height = 500, ease = d3Ease.easeQuadInOut, data, chartWidth, chartHeight, xScale, yScale, numOfVerticalTicks = 6, xAxis, xAxisLabel, yAxis, yAxisLabel, xAxisLabelOffset = 45, yAxisLabelOffset = -20, xAxisPadding = { top: 0, left: 0, bottom: 0, right: 0 }, yTickPadding = 8, svg, valueLabel = 'value', nameLabel = 'key', maskGridLines, baseLine, // Dispatcher object to broadcast the mouse events // Ref: https://github.com/mbostock/d3/wiki/Internals#d3_dispatch dispatcher = d3Dispatch.dispatch('customMouseOver', 'customMouseOut', 'customMouseMove'), // Formats yAxisTickFormat = d3Format.format('.3'), // extractors getKey = ({key}) =&gt; key, getValue = ({value}) =&gt; value; /** * This function creates the graph using the selection as container * @param {D3Selection} _selection A d3 selection that represents * the container(s) where the chart(s) will be rendered * @param {StepChartData} _data The data to attach and generate the chart */ function exports(_selection){ _selection.each(function(_data){ // Make space on the left of the graph for the y axis label chartWidth = width - margin.left - margin.right; chartHeight = height - margin.top - margin.bottom; data = cleanData(_data); buildScales(); buildAxis(); buildSVG(this); drawGridLines(); drawSteps(); drawAxis(); }); } /** * Creates the d3 x and y axis, setting orientations * @private */ function buildAxis(){ xAxis = d3Axis.axisBottom(xScale); yAxis = d3Axis.axisLeft(yScale) .ticks(numOfVerticalTicks) .tickPadding(yTickPadding) .tickFormat(yAxisTickFormat); } /** * Builds containers for the chart, the axis and a wrapper for all of them * Also applies the Margin convention * @private */ function buildContainerGroups(){ let container = svg .append('g') .classed('container-group', true) .attr('transform', `translate(${margin.left}, ${margin.top})`); container .append('g') .classed('grid-lines-group', true); container .append('g') .classed('chart-group', true); container .append('g') .classed('x-axis-group axis', true) .append('g') .classed('x-axis-label', true); container .append('g') .classed('y-axis-group axis', true) .append('g') .classed('y-axis-label', true); container .append('g').classed('metadata-group', true); } /** * Creates the x and y scales of the graph * @private */ function buildScales(){ xScale = d3Scale.scaleBand() .domain(data.map(getKey)) .rangeRound([0, chartWidth]) .paddingInner(0); yScale = d3Scale.scaleLinear() .domain([0, d3Array.max(data, getValue)]) .rangeRound([chartHeight, 0]); } /** * Builds the SVG element that will contain the chart * @param {HTMLElement} container DOM element that will work as the container of the graph * @private */ function buildSVG(container){ if (!svg) { svg = d3Selection.select(container) .append('svg') .classed('britechart step-chart', true); buildContainerGroups(); } svg .transition() .ease(ease) .attr('width', width + margin.left + margin.right) .attr('height', height + margin.top + margin.bottom); } /** * Cleaning data adding the proper format * @param {StepChartData} data Data * @private */ function cleanData(data) { return data.map((d) =&gt; { d.value = +d[valueLabel]; d.key = String(d[nameLabel]); return d; }); } /** * Draws the x and y axis on the svg object within their * respective groups * @private */ function drawAxis(){ svg.select('.x-axis-group.axis') .attr('transform', `translate(0, ${chartHeight})`) .call(xAxis); if (xAxisLabel) { svg.select('.x-axis-label') .append('text') .attr('text-anchor', 'middle') .attr('x', chartWidth / 2) .attr('y', xAxisLabelOffset) .text(xAxisLabel); } svg.select('.y-axis-group.axis') .call(yAxis); if (yAxisLabel) { svg.select('.y-axis-label') .append('text') .attr('x', -chartHeight / 2) .attr('y', yAxisLabelOffset) .attr('text-anchor', 'middle') .attr('transform', 'rotate(270 0 0)') .text(yAxisLabel); } } /** * Draws the step elements within the chart group * @private */ function drawSteps(){ let steps = svg.select('.chart-group').selectAll('.step').data(data); // Enter steps.enter() .append('rect') .classed('step', true) .attr('x', chartWidth) // Initially drawing the steps at the end of Y axis .attr('y', ({value}) =&gt; yScale(value)) .attr('width', xScale.bandwidth()) .attr('height', (d) =&gt; (chartHeight - yScale(d.value))) .on('mouseover', function() { dispatcher.call('customMouseOver', this); }) .on('mousemove', function(d) { dispatcher.call('customMouseMove', this, d, d3Selection.mouse(this), [chartWidth, chartHeight]); }) .on('mouseout', function() { dispatcher.call('customMouseOut', this); }) .merge(steps) .transition() .ease(ease) .attr('x', ({key}) =&gt; xScale(key)) .attr('y', function(d) { return yScale(d.value); }) .attr('width', xScale.bandwidth()) .attr('height', function(d) { return chartHeight - yScale(d.value); }); // Exit steps.exit() .transition() .style('opacity', 0) .remove(); } /** * Draws grid lines on the background of the chart * @return void */ function drawGridLines(){ maskGridLines = svg.select('.grid-lines-group') .selectAll('line.horizontal-grid-line') .data(yScale.ticks(numOfVerticalTicks)) .enter() .append('line') .attr('class', 'horizontal-grid-line') .attr('x1', (xAxisPadding.left)) .attr('x2', chartWidth) .attr('y1', (d) =&gt; yScale(d)) .attr('y2', (d) =&gt; yScale(d)); //draw a horizontal line to extend x-axis till the edges baseLine = svg.select('.grid-lines-group') .selectAll('line.extended-x-line') .data([0]) .enter() .append('line') .attr('class', 'extended-x-line') .attr('x1', (xAxisPadding.left)) .attr('x2', chartWidth) .attr('y1', height - margin.bottom - margin.top) .attr('y2', height - margin.bottom - margin.top); } /** * Chart exported to png and a download action is fired * @public */ exports.exportChart = function(filename) { exportChart.call(exports, svg, filename); }; /** * Gets or Sets the margin of the chart * @param {object} _x Margin object to get/set * @return { margin | module} Current margin or Step Chart module to chain calls * @public */ exports.margin = function(_x) { if (!arguments.length) { return margin; } margin = _x; return this; }; /** * Gets or Sets the width of the chart * @param {number} _x Desired width for the graph * @return { width | module} Current width or step Chart module to chain calls * @public */ exports.width = function(_x) { if (!arguments.length) { return width; } width = _x; return this; }; /** * Gets or Sets the height of the chart * @param {number} _x Desired width for the graph * @return { height | module} Current height or Step Chart module to chain calls * @public */ exports.height = function(_x) { if (!arguments.length) { return height; } height = _x; return this; }; /** * Gets or Sets the number of vertical ticks on the chart * @param {number} _x Desired width for the graph * @return { height | module} Current height or Step Chart module to chain calls * @public */ exports.numOfVerticalTicks = function(_x) { if (!arguments.length) { return numOfVerticalTicks; } numOfVerticalTicks = _x; return this; }; /** * Gets or Sets the text of the xAxisLabel on the chart * @param {text} _x Desired text for the label * @return { text | module} label or Step Chart module to chain calls * @public */ exports.xAxisLabel = function(_x) { if (!arguments.length) { return xAxisLabel; } xAxisLabel = _x; return this; }; /** * Gets or Sets the offset of the xAxisLabel on the chart * @param {integer} _x Desired offset for the label * @return { integer | module} label or Step Chart module to chain calls * @public */ exports.xAxisLabelOffset = function(_x) { if (!arguments.length) { return xAxisLabelOffset; } xAxisLabelOffset = _x; return this; }; /** * Gets or Sets the text of the yAxisLabel on the chart * @param {text} _x Desired text for the label * @return { text | module} label or Step Chart module to chain calls * @public */ exports.yAxisLabel = function(_x) { if (!arguments.length) { return yAxisLabel; } yAxisLabel = _x; return this; }; /** * Gets or Sets the offset of the yAxisLabel on the chart * @param {integer} _x Desired offset for the label * @return { integer | module} label or Step Chart module to chain calls * @public */ exports.yAxisLabelOffset = function(_x) { if (!arguments.length) { return yAxisLabelOffset; } yAxisLabelOffset = _x; return this; }; /** * Exposes an 'on' method that acts as a bridge with the event dispatcher * We are going to expose this events: * customMouseOver, customMouseMove and customMouseOut * * @return {module} Bar Chart * @public */ exports.on = function() { let value = dispatcher.on.apply(dispatcher, arguments); return value === dispatcher ? exports : value; }; /** * Chart exported to png and a download action is fired * @public */ exports.exportChart = function(filename, title) { exportChart.call(exports, svg, filename, title); }; return exports; }; }); × Search results Close "},"tooltip.js.html":{"id":"tooltip.js.html","title":"Source: tooltip.js","body":" API BarBrushDonutLegendLineMini-tooltipSparklineStacked-areaStepTooltip Demos _GETTINGSTARTEDbarbrushdonutkitchen-sinklinesparklinestacked-areastep Global Global Source: tooltip.js define(function(require){ 'use strict'; const d3Format = require('d3-format'); const d3Selection = require('d3-selection'); const d3Transition = require('d3-transition'); const d3TimeFormat = require('d3-time-format'); const { axisTimeCombinations } = require('./helpers/constants.js'); /** * Tooltip Component reusable API class that renders a * simple and configurable tooltip element for Britechart's * line chart or stacked area chart. * * @module Tooltip * @tutorial tooltip * @requires d3-array, d3-axis, d3-dispatch, d3-format, d3-scale, d3-selection, d3-transition * * @example * var lineChart = line(), * tooltip = tooltip(); * * tooltip * .title('Tooltip title'); * * lineChart * .width(500) * .on('customMouseOver', function() { * tooltip.show(); * }) * .on('customMouseMove', function(dataPoint, topicColorMap, dataPointXPosition) { * tooltip.update(dataPoint, topicColorMap, dataPointXPosition); * }) * .on('customMouseOut', function() { * tooltip.hide(); * }); * * d3Selection.select('.css-selector') * .datum(dataset) * .call(lineChart); * * d3Selection.select('.metadata-group .hover-marker') * .datum([]) * .call(tooltip); * */ return function module() { let margin = { top: 2, right: 2, bottom: 2, left: 2 }, width = 250, height = 45, title = 'Tooltip title', // tooltip tooltip, tooltipOffset = { y: -55, x: 0 }, tooltipMaxTopicLength = 170, tooltipTextContainer, tooltipDivider, tooltipBody, tooltipTitle, tooltipWidth = 250, tooltipHeight = 48, ttTextX = 0, ttTextY = 37, textSize, entryLineLimit = 3, circleYOffset = 8, colorMap, bodyFillColor = '#FFFFFF', borderStrokeColor = '#D2D6DF', titleFillColor = '#6D717A', textFillColor = '#282C35', tooltipTextColor = '#000000', dateLabel = 'date', valueLabel = 'value', topicLabel = 'topics', defaultAxisSettings = axisTimeCombinations.DAY_MONTH, forceAxisSettings = null, // formats monthDayYearFormat = d3TimeFormat.timeFormat('%b %d, %Y'), monthDayHourFormat = d3TimeFormat.timeFormat('%b %d, %I %p'), valueRangeLimits = { small: 10, medium: 100 }, integerValueFormats = { small: d3Format.format(''), medium: d3Format.format(''), large: d3Format.format('.2s') }, decimalValueFormats = { small: d3Format.format('.3f'), medium: d3Format.format('.1f'), large: d3Format.format('.2s') }, chartWidth, chartHeight, data, svg; /** * This function creates the graph using the selection as container * @param {D3Selection} _selection A d3 selection that represents * the container(s) where the chart(s) will be rendered * @param {Object} _data The data to attach and generate the chart */ function exports(_selection) { _selection.each(function(_data){ chartWidth = width - margin.left - margin.right; chartHeight = height - margin.top - margin.bottom; data = _data; buildSVG(this); }); } /** * Builds containers for the tooltip * Also applies the Margin convention * @private */ function buildContainerGroups() { var container = svg.append('g') .classed('tooltip-container-group', true) .attr('transform', `translate( ${margin.left}, ${margin.top})`); container.append('g').classed('tooltip-group', true); } /** * Builds the SVG element that will contain the chart * @param {HTMLElement} container DOM element that will work as the container of the graph * @private */ function buildSVG(container) { if (!svg) { svg = d3Selection.select(container) .append('g') .classed('britechart britechart-tooltip', true); buildContainerGroups(); drawTooltip(); } svg.transition() .attr('width', width + margin.left + margin.right) .attr('height', height + margin.top + margin.bottom); // Hidden by default exports.hide(); } /** * Resets the tooltipBody content * @return void */ function cleanContent(){ tooltipBody.selectAll('text').remove(); tooltipBody.selectAll('circle').remove(); } /** * Draws the different elements of the Tooltip box * @return void */ function drawTooltip(){ tooltipTextContainer = svg.selectAll('.tooltip-group') .append('g') .classed('tooltip-text', true); tooltip = tooltipTextContainer .append('rect') .classed('tooltip-text-container', true) .attr('x', -tooltipWidth / 4 + 8) .attr('y', 0) .attr('width', tooltipWidth) .attr('height', tooltipHeight) .attr('rx', 3) .attr('ry', 3) .style('fill', bodyFillColor) .style('stroke', borderStrokeColor) .style('stroke-width', 1); tooltipTitle = tooltipTextContainer .append('text') .classed('tooltip-title', true) .attr('x', -tooltipWidth / 4 + 17) .attr('dy', '.35em') .attr('y', 16) .style('fill', titleFillColor); tooltipDivider = tooltipTextContainer .append('line') .classed('tooltip-divider', true) .attr('x1', -tooltipWidth / 4 + 15) .attr('y1', 31) .attr('x2', 265) .attr('y2', 31) .style('stroke', borderStrokeColor); tooltipBody = tooltipTextContainer .append('g') .classed('tooltip-body', true) .style('transform', 'translateY(8px)') .style('fill', textFillColor); } /** * Formats a floating point value depending on its value range * @param {Number} value Decimal point value to format * @return {Number} Formatted value to show */ function formatDecimalValue(value) { let size = 'large'; if (value &lt; valueRangeLimits.small) { size = 'small'; } else if (value &lt; valueRangeLimits.medium) { size = 'medium'; } return decimalValueFormats[size](value); } /** * Formats an integer value depending on its value range * @param {Number} value Decimal point value to format * @return {Number} Formatted value to show */ function formatIntegerValue(value) { let size = 'large'; if (value &lt; valueRangeLimits.small) { size = 'small'; } if (value &lt; valueRangeLimits.medium) { size = 'medium'; } return integerValueFormats[size](value); } /** * Formats the value depending on its characteristics * @param {Number} value Value to format * @return {Number} Formatted value */ function getFormattedValue(value) { if (!value) { return 0; } if (isInteger(value)) { value = formatIntegerValue(value); } else { value = formatDecimalValue(value); } return value; } /** * Extracts the value from the data object * @param {Object} data Data value containing the info * @return {String} Value to show */ function getValueText(data) { let value = data[valueLabel]; let valueText; if (data.missingValue) { valueText = '-'; } else { valueText = getFormattedValue(value).toString(); } return valueText; } /** * Checks if a number is an integer of has decimal values * @param {Number} value Value to check * @return {Boolean} If it is an iteger */ function isInteger(value) { return value % 1 === 0; } /** * Resets the height of the tooltip and the pointer for the text * position */ function resetSizeAndPositionPointers() { tooltipHeight = 48; ttTextY = 37; ttTextX = 0; } /** * Draws the data entries inside the tooltip for a given topic * @param {Object} topic Topic to extract data from * @return void */ function updateContent(topic){ let name = topic.name, tooltipRight, tooltipLeftText, tooltipRightText, elementText; tooltipLeftText = topic.topicName || name; tooltipRightText = getValueText(topic); elementText = tooltipBody .append('text') .classed('tooltip-left-text', true) .attr('dy', '1em') .attr('x', ttTextX - 20) .attr('y', ttTextY) .style('fill', tooltipTextColor) .text(tooltipLeftText) .call(textWrap, tooltipMaxTopicLength, -25); tooltipRight = tooltipBody .append('text') .classed('tooltip-right-text', true) .attr('dy', '1em') .attr('x', ttTextX + 8) .attr('y', ttTextY) .style('fill', tooltipTextColor) .text(tooltipRightText); textSize = elementText.node().getBBox(); tooltipHeight += textSize.height + 5; // Not sure if necessary tooltipRight.attr('x', tooltipWidth - tooltipRight.node().getBBox().width - 10 - tooltipWidth / 4) tooltipBody .append('circle') .classed('tooltip-circle', true) .attr('cx', 23 - tooltipWidth / 4) .attr('cy', (ttTextY + circleYOffset)) .attr('r', 5) .style('fill', colorMap[name]) .style('stroke-width', 1); ttTextY += textSize.height + 7; } /** * Updates size and position of tooltip depending on the side of the chart we are in * @param {Object} dataPoint DataPoint of the tooltip * @param {Number} xPosition DataPoint's x position in the chart * @return void */ function updatePositionAndSize(dataPoint, xPosition){ tooltip .attr('width', tooltipWidth) .attr('height', tooltipHeight + 10); // show tooltip to the right if ((xPosition - tooltipWidth) &lt; 0) { // Tooltip on the right tooltipTextContainer .attr('transform', 'translate(' + (tooltipWidth - 185) + ',' + tooltipOffset.y + ')'); } else { // Tooltip on the left tooltipTextContainer .attr('transform', 'translate(' + (-205) + ',' + tooltipOffset.y + ')'); } tooltipDivider .attr('x2', tooltipWidth - 60); } /** * Updates value of tooltipTitle with the data meaning and the date * @param {Object} dataPoint Point of data to use as source * @return void */ function updateTitle(dataPoint) { var date = new Date(dataPoint[dateLabel]), tooltipTitleText = title + ' - ' + formatDate(date); tooltipTitle.text(tooltipTitleText); } /** * Figures out which date format to use when showing the date of the current data entry * @return {Function} The proper date formatting function */ function formatDate(date) { let settings = forceAxisSettings || defaultAxisSettings; let format = null; if (settings === axisTimeCombinations.DAY_MONTH || settings === axisTimeCombinations.MONTH_YEAR) { format = monthDayYearFormat; } else if (settings === axisTimeCombinations.HOUR_DAY || settings === axisTimeCombinations.MINUTE_HOUR) { format = monthDayHourFormat; } return format(date); } /** * Updates tooltip title, content, size and position * * @param {lineChartPointByDate} dataPoint Current datapoint to show info about * @param {Number} xPosition Position of the mouse on the X axis * @return void */ function updateTooltip(dataPoint, xPosition) { var topics = dataPoint[topicLabel]; cleanContent(); resetSizeAndPositionPointers(); updateTitle(dataPoint); topics.forEach(updateContent); updatePositionAndSize(dataPoint, xPosition); } /** * Wraps a text given the text, width, x position and textFormatter function * @param {D3Selection} text Selection with the text to wrap inside * @param {Number} width Desired max width for that line * @param {Number} xpos Initial x position of the text * * REF: http://bl.ocks.org/mbostock/7555321 * More discussions on https://github.com/mbostock/d3/issues/1642 */ function textWrap(text, width, xpos) { xpos = xpos || 0; text.each(function() { var words, word, line, lineNumber, lineHeight, y, dy, tspan; text = d3Selection.select(this); words = text.text().split(/\\s+/).reverse(); line = []; lineNumber = 0; lineHeight = 1.2; y = text.attr('y'); dy = parseFloat(text.attr('dy')); tspan = text .text(null) .append('tspan') .attr('x', xpos) .attr('y', y) .attr('dy', dy + 'em'); while ((word = words.pop())) { line.push(word); tspan.text(line.join(' ')); if (tspan.node().getComputedTextLength() &gt; width) { line.pop(); tspan.text(line.join(' ')); if (lineNumber &lt; entryLineLimit - 1) { line = [word]; tspan = text.append('tspan') .attr('x', xpos) .attr('y', y) .attr('dy', ++lineNumber * lineHeight + dy + 'em') .text(word); } } } }); } /** * Gets or Sets the dateLabel of the data * @param {Number} _x Desired dateLabel * @return { dateLabel | module} Current dateLabel or Chart module to chain calls * @public */ exports.dateLabel = function(_x) { if (!arguments.length) { return dateLabel; } dateLabel = _x; return this; }; /** * Gets or Sets the valueLabel of the data * @param {Number} _x Desired valueLabel * @return { valueLabel | module} Current valueLabel or Chart module to chain calls * @public */ exports.valueLabel = function(_x) { if (!arguments.length) { return valueLabel; } valueLabel = _x; return this; }; /** * Gets or Sets the topicLabel of the data * @param {Number} _x Desired topicLabel * @return { topicLabel | module} Current topicLabel or Chart module to chain calls * @public */ exports.topicLabel = function(_x) { if (!arguments.length) { return topicLabel; } topicLabel = _x; return this; }; /** * Hides the tooltip * @return {Module} Tooltip module to chain calls * @public */ exports.hide = function() { svg.style('display', 'none'); return this; }; /** * Shows the tooltip * @return {Module} Tooltip module to chain calls * @public */ exports.show = function() { svg.style('display', 'block'); return this; }; /** * Gets or Sets the title of the tooltip * @param {string} _x Desired title * @return { string | module} Current title or module to chain calls * @public */ exports.title = function(_x) { if (!arguments.length) { return title; } title = _x; return this; }; /** * Updates the position and content of the tooltip * @param {Object} dataPoint Datapoint to represent * @param {Object} colorMapping Color scheme of the topics * @param {Number} position X-scale position in pixels * @return {Module} Tooltip module to chain calls * @public */ exports.update = function(dataPoint, colorMapping, position) { colorMap = colorMapping; updateTooltip(dataPoint, position); return this; }; /** * Exposes the ability to force the tooltip to use a certain date format * @param {String} _x Desired format * @return { (String|Module) } Current format or module to chain calls */ exports.forceDateRange = function(_x) { if (!arguments.length) { return forceAxisSettings || defaultAxisSettings; } forceAxisSettings = _x; return this; }; /** * constants to be used to force the x axis to respect a certain granularity * current options: HOUR_DAY, DAY_MONTH, MONTH_YEAR * @example tooltip.forceDateRange(tooltip.axisTimeCombinations.HOUR_DAY) */ exports.axisTimeCombinations = axisTimeCombinations; return exports; }; }); × Search results Close "},"global.html":{"id":"global.html","title":"Global","body":" API BarBrushDonutLegendLineMini-tooltipSparklineStacked-areaStepTooltip Demos _GETTINGSTARTEDbarbrushdonutkitchen-sinklinesparklinestacked-areastep Global Global Global Type Definitions areaChartData Type: Object Properties: Name Type Description data Array.&lt;Object&gt; All data entries date String Date of the entry name String Name of the entry value Number Value of the entry Source: stacked-area.js Example { 'data': [ { &quot;date&quot;: &quot;2011-01-05T00:00:00Z&quot;, &quot;name&quot;: &quot;Direct&quot;, &quot;value&quot;: 0 } ] } BarChartData Type: Array.&lt;Object&gt; Properties: Name Type Description value Number Value of the group (required) name String Name of the group (required) Source: bar.js Example [ { value: 1, name: 'glittering' }, { value: 1, name: 'luminous' } ] BrushChartData Type: Array.&lt;Object&gt; Properties: Name Type Description value Number Value to chart (required) date Date Date of the value (required) Source: brush.js Example [ { value: 1, date: '2011-01-06T00:00:00Z' }, { value: 2, date: '2011-01-07T00:00:00Z' } ] D3Selection Type: Array.&lt;Array&gt; Properties: Name Type Description length Number Size of the selection parentNode DOMElement Parent of the selection Source: line.js DonutChartData Type: Array.&lt;Object&gt; Properties: Name Type Description quantity Number Quantity of the group (required) percentage Number Percentage of the total (required) name String Name of the group (required) id Number Identifier for the group required for legend feature (optional) Source: donut.js Example [ { quantity: 1, percentage: 50, name: 'glittering', id: 1 }, { quantity: 1, percentage: 50, name: 'luminous', id: 2 } ] LegendChartData Type: Array.&lt;Object&gt; Properties: Name Type Description id Number Id of the group (required) quantity Number Quantity of the group (required) name String Name of the group (required) Source: legend.js Example [ { id: 1, quantity: 2, name: 'glittering' }, { id: 2, quantity: 3, name: 'luminous' } LineChartData Type: Array.&lt;Object&gt; Properties: Name Type Description dataByTopic Array.&lt;lineChartDataByTopic&gt; Data values to chart (required) Source: line.js Example { dataByTopic: [ { topicName: 'San Francisco', topic: 123, dates: [ { date: '2017-01-16T16:00:00-08:00', value: 1 }, { date: '2017-01-16T17:00:00-08:00', value: 2 } ] }, { topicName: 'Other', topic: 345, dates: [ {...}, {...} ] } ] } lineChartDataByTopic Type: Object Properties: Name Type Description topicName String Topic name (required) topic Number Topic identifier (required) dates Array.&lt;Object&gt; All date entries with values for that topic (required) Source: line.js Example { topicName: 'San Francisco', topic: 123, dates: [ { date: '2017-01-16T16:00:00-08:00', value: 1 }, { date: '2017-01-16T17:00:00-08:00', value: 2 } ] } SparklineChartData Type: Array.&lt;Object&gt; Properties: Name Type Description value Number Value of the group (required) name String Name of the group (required) Source: sparkline.js Example [ { value: 1, date: '2011-01-06T00:00:00Z' }, { value: 2, date: '2011-01-07T00:00:00Z' } StepChartData Type: Array.&lt;Object&gt; Properties: Name Type Description key String Key we measure (required) value Number value of the key (required) Source: step.js Example [ { value: 1, key: 'glittering' }, { value: 1, key: 'luminous' } ] × Search results Close "},"modules.list.html":{"id":"modules.list.html","title":"API","body":" API BarBrushDonutLegendLineMini-tooltipSparklineStacked-areaStepTooltip Demos _GETTINGSTARTEDbarbrushdonutkitchen-sinklinesparklinestacked-areastep Global Global API × Search results Close "},"tutorials.list.html":{"id":"tutorials.list.html","title":"Demos","body":" API BarBrushDonutLegendLineMini-tooltipSparklineStacked-areaStepTooltip Demos _GETTINGSTARTEDbarbrushdonutkitchen-sinklinesparklinestacked-areastep Global Global Demos × Search results Close "},"index.html":{"id":"index.html","title":"Index","body":" API BarBrushDonutLegendLineMini-tooltipSparklineStacked-areaStepTooltip Demos _GETTINGSTARTEDbarbrushdonutkitchen-sinklinesparklinestacked-areastep Global Global Britecharts Britecharts is a client-side reusable Charting Library based on D3.js v4 that allows easy and intuitive use of charts and components that can be composed together creating amazing visualizations. Britecharts components have been written in ES2015 with a Test Driven methodology so they are fully tested, and we are commited to keep them that way. Key FeaturesThe main characteristics of this library are: Reusability Composability Fully tested ES2015 source code (transpiled with Babel) UsageThe typical use of Britecharts involves creating a chart using it's simple API, and rendering it on a container which has previously been applied some data. The code will look like this: barChart .width(500) .height(300); barContainer.datum(dataset).call(barChart);APIAll the components expose some basic API methods like width, height and margin. Additionally, each chart or component can expose more methods. They will be ready to check in the documentation of the modules: Bar Chart: API - Demo Line Chart: API - Demo Donut Chart: API - Demo Brush Chart: API - Demo Sparkline Chart: API - Demo Stacked Area Chart: API - Demo Tooltip Chart: API - Demo Mini Tooltip Chart: API - Demo Legend Chart: API - Demo Step Chart: API - Demo InstallationBritecharts components are distributed in UMD modules, each one exposing a D3.js component written with the Reusable API pattern. In order to use any of the Britecharts modules, you will need to require the chart in your JS file using AMD/CommonJS modules. You would also need to load the D3.js selection library in order to select the chart container. They also provide some minimal CSS styling, that can be loaded independently or as a bundle. RoadmapThis project is in active development, if you are interested on helping you can check the contributing document. Review the issues page for more info in what's coming and to give your feedback and to vote for your favorite proposals. See Also Getting Started Guide Documentation Release Notes Contributing Guide Github Repo AcknowledgmentsBritecharts was inspired by two books, Developing a D3.js Edge and Mastering D3.js. It also leveraged a great number of examples and articles from the D3.js community overall. LicenseCopyright 2017 Eventbrite Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); you may not use this file except in compliance with the License. You may obtain a copy of the License at https://www.apache.org/licenses/LICENSE-2.0 Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an &quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License. Read more in the license document × Search results Close "},"module-Bar.html":{"id":"module-Bar.html","title":"API: Bar","body":" API BarBrushDonutLegendLineMini-tooltipSparklineStacked-areaStepTooltip Demos _GETTINGSTARTEDbarbrushdonutkitchen-sinklinesparklinestacked-areastep Global Global API: Bar Bar Chart reusable API class that renders a simple and configurable bar chart. (require(&quot;Bar&quot;))(_selection, _data) This function creates the graph using the selection as container Parameters: Name Type Description _selection D3Selection A d3 selection that represents the container(s) where the chart(s) will be rendered _data BarChartData The data to attach and generate the chart Source: bar.js Requires module:d3-array, Methods module:Bar(_selection, _data) This function creates the graph using the selection as container Parameters: Name Type Description _selection D3Selection A d3 selection that represents the container(s) where the chart(s) will be rendered _data BarChartData The data to attach and generate the chart Source: bar.js &lt;static&gt; enablePercentageLabels(_x) Default false. If true, adds percentage labels at the end of the bars Parameters: Name Type Description _x Boolean Source: bar.js Returns: Current value of enablePercentageLables or Bar Chart module to chain calls Type Boolean | module &lt;static&gt; exportChart() Chart exported to png and a download action is fired Source: bar.js &lt;static&gt; exportChart() Chart exported to png and a download action is fired Source: bar.js &lt;static&gt; height(_x) Gets or Sets the height of the chart Parameters: Name Type Description _x number Desired width for the graph Source: bar.js Returns: Current height or Bar Chart module to chain calls Type height | module &lt;static&gt; horizontal(_x) Gets or Sets the horizontal direction of the chart Parameters: Name Type Description _x number Desired horizontal direction for the graph Source: bar.js Returns: Current horizontal direction or Bar Chart module to chain calls Type horizontal | module &lt;static&gt; margin(_x) Gets or Sets the margin of the chart Parameters: Name Type Description _x object Margin object to get/set Source: bar.js Returns: Current margin or Bar Chart module to chain calls Type margin | module &lt;static&gt; on() Exposes an 'on' method that acts as a bridge with the event dispatcher We are going to expose this events: customMouseOver, customMouseMove and customMouseOut Source: bar.js Returns: Bar Chart Type module &lt;static&gt; percentageAxisToMaxRatio(_x) Configurable extension of the x axis if your max point was 50% you might want to show x axis to 60%, pass 1.2 Parameters: Name Type Description _x number ratio to max data point to add to the x axis Source: bar.js Returns: Current ratio or Bar Chart module to chain calls Type ratio | module &lt;static&gt; percentageLabelMargin(_x) Default 10px. Offset between end of bar and start of the percentage bars Parameters: Name Type Description _x number percentage margin offset from end of bar Source: bar.js Returns: Currnet offset or Bar Chart module to chain calls Type number | module &lt;static&gt; width(_x) Gets or Sets the width of the chart Parameters: Name Type Description _x number Desired width for the graph Source: bar.js Returns: Current width or Bar Chart module to chain calls Type width | module &lt;static&gt; yAxisPaddingBetweenChart(_x) Default 10. Space between y axis and chart Parameters: Name Type Description _x number space between y axis and chart Source: bar.js Returns: Current value of yAxisPaddingBetweenChart or Bar Chart module to chain calls Type number | module × Search results Close "},"module-Brush.html":{"id":"module-Brush.html","title":"API: Brush","body":" API BarBrushDonutLegendLineMini-tooltipSparklineStacked-areaStepTooltip Demos _GETTINGSTARTEDbarbrushdonutkitchen-sinklinesparklinestacked-areastep Global Global API: Brush Brush Chart reusable API class that renders a simple and configurable brush chart. (require(&quot;Brush&quot;))(_selection, _data) This function creates the graph using the selection as container Parameters: Name Type Description _selection D3Selection A d3 selection that represents the container(s) where the chart(s) will be rendered _data BrushChartData The data to attach and generate the chart Source: brush.js Requires module:d3-array, Methods module:Brush(_selection, _data) This function creates the graph using the selection as container Parameters: Name Type Description _selection D3Selection A d3 selection that represents the container(s) where the chart(s) will be rendered _data BrushChartData The data to attach and generate the chart Source: brush.js &lt;static&gt; dateRange(_x) Gets or Sets the dateRange for the selected part of the brush Parameters: Name Type Description _x Array.&lt;String&gt; Desired dateRange for the graph Source: brush.js Returns: Current dateRange or Chart module to chain calls Type dateRange | module &lt;static&gt; gradient(_x) Gets or Sets the gradient of the chart Parameters: Name Type Description _x Array.&lt;String&gt; Desired gradient for the graph Source: brush.js Returns: Current gradient or Chart module to chain calls Type gradient | module &lt;static&gt; height(_x) Gets or Sets the height of the chart Parameters: Name Type Description _x number Desired width for the graph Source: brush.js Returns: Current height or Chart module to chain calls Type height | module &lt;static&gt; margin(_x) Gets or Sets the margin of the chart Parameters: Name Type Description _x object Margin object to get/set Source: brush.js Returns: Current margin or Chart module to chain calls Type margin | module &lt;static&gt; onBrush(_x) Gets or Sets the callback that will be called when the user brushes over the area Parameters: Name Type Description _x function Callback to call Source: brush.js Returns: Current callback function or the Chart Module Type function | module &lt;static&gt; width(_x) Gets or Sets the width of the chart Parameters: Name Type Description _x number Desired width for the graph Source: brush.js Returns: Current width or Chart module to chain calls Type width | module × Search results Close "},"module-Donut.html":{"id":"module-Donut.html","title":"API: Donut","body":" API BarBrushDonutLegendLineMini-tooltipSparklineStacked-areaStepTooltip Demos _GETTINGSTARTEDbarbrushdonutkitchen-sinklinesparklinestacked-areastep Global Global API: Donut Reusable Donut Chart API class that renders a simple and configurable donut chart. (require(&quot;Donut&quot;))(_selection, _data) This function creates the graph using the selection as container Parameters: Name Type Description _selection D3Selection A d3 selection that represents the container(s) where the chart(s) will be rendered _data DonutChartData The data to attach and generate the chart Source: donut.js Requires module:d3-dispatch, Methods module:Donut(_selection, _data) This function creates the graph using the selection as container Parameters: Name Type Description _selection D3Selection A d3 selection that represents the container(s) where the chart(s) will be rendered _data DonutChartData The data to attach and generate the chart Source: donut.js &lt;static&gt; colorSchema(_x) Gets or Sets the colorSchema of the chart Parameters: Name Type Description _x Array.&lt;String&gt; Desired colorSchema for the graph Source: donut.js Returns: Current colorSchema or Chart module to chain calls Type colorSchema | module &lt;static&gt; exportChart() Chart exported to png and a download action is fired Source: donut.js &lt;static&gt; externalRadius(_x) Gets or Sets the externalRadius of the chart Parameters: Name Type Description _x Number ExternalRadius number to get/set Source: donut.js Returns: Current externalRadius or Donut Chart module to chain calls Type Number | Module &lt;static&gt; height(_x) Gets or Sets the height of the chart Parameters: Name Type Description _x Number Desired width for the graph Source: donut.js Returns: Current height or Donut Chart module to chain calls Type Number | Module &lt;static&gt; internalRadius(_x) Gets or Sets the internalRadius of the chart Parameters: Name Type Description _x Number InternalRadius number to get/set Source: donut.js Returns: Current internalRadius or Donut Chart module to chain calls Type Number | Module &lt;static&gt; margin(_x) Gets or Sets the margin of the chart Parameters: Name Type Description _x Object Margin object to get/set Source: donut.js Returns: Current margin or Donut Chart module to chain calls Type Number | Module &lt;static&gt; on() Exposes an 'on' method that acts as a bridge with the event dispatcher We are going to expose this events: customMouseOver, customMouseMove and customMouseOut Source: donut.js Returns: Bar Chart Type module &lt;static&gt; width(_x) Gets or Sets the width of the chart Parameters: Name Type Description _x Number Desired width for the graph Source: donut.js Returns: Current width or Donut Chart module to chain calls Type Number | Module × Search results Close "},"module-Legend.html":{"id":"module-Legend.html","title":"API: Legend","body":" API BarBrushDonutLegendLineMini-tooltipSparklineStacked-areaStepTooltip Demos _GETTINGSTARTEDbarbrushdonutkitchen-sinklinesparklinestacked-areastep Global Global API: Legend Legend Component reusable API class that renders a simple and configurable legend element. (require(&quot;Legend&quot;))(_selection, _data) This function creates the graph using the selection as container Parameters: Name Type Description _selection D3Selection A d3 selection that represents the container(s) where the chart(s) will be rendered _data object The data to attach and generate the chart Source: legend.js Requires module:d3 Methods module:Legend(_selection, _data) This function creates the graph using the selection as container Parameters: Name Type Description _selection D3Selection A d3 selection that represents the container(s) where the chart(s) will be rendered _data object The data to attach and generate the chart Source: legend.js &lt;static&gt; clearHighlight() Clears the highlighted line entry Source: legend.js &lt;static&gt; colorSchema(_x) Gets or Sets the colorSchema of the chart Parameters: Name Type Description _x Array Color scheme array to get/set Source: legend.js Returns: Current colorSchema or Donut Chart module to chain calls Type Number | Module &lt;static&gt; height(_x) Gets or Sets the height of the legend chart Parameters: Name Type Description _x number Desired width for the chart Source: legend.js Returns: Current height or Legend module to chain calls Type height | module &lt;static&gt; highlight(entryId) Highlights a line entry by fading the rest of lines Parameters: Name Type Description entryId number ID of the entry line Source: legend.js &lt;static&gt; margin(_x) Gets or Sets the margin of the legend chart Parameters: Name Type Description _x object Margin object to get/set Source: legend.js Returns: Current margin or Legend module to chain calls Type margin | module &lt;static&gt; width(_x) Gets or Sets the width of the legend chart Parameters: Name Type Description _x number Desired width for the graph Source: legend.js Returns: Current width or Legend module to chain calls Type width | module × Search results Close "},"module-Line.html":{"id":"module-Line.html","title":"API: Line","body":" API BarBrushDonutLegendLineMini-tooltipSparklineStacked-areaStepTooltip Demos _GETTINGSTARTEDbarbrushdonutkitchen-sinklinesparklinestacked-areastep Global Global API: Line Line Chart reusable API module that allows us rendering a multi line and configurable chart. (require(&quot;Line&quot;))(_selection, _data) This function creates the graph using the selection and data provided Parameters: Name Type Description _selection D3Selection A d3 selection that represents the container(s) where the chart(s) will be rendered _data LineChartData The data to attach and generate the chart Source: line.js Requires module:d3-array, Members &lt;static&gt; axisTimeCombinations constants to be used to force the x axis to respect a certain granularity current options: HOUR_DAY, DAY_MONTH, MONTH_YEAR Source: line.js Example line.forceAxisFormat(line.axisTimeCombinations.HOUR_DAY) Methods module:Line(_selection, _data) This function creates the graph using the selection and data provided Parameters: Name Type Description _selection D3Selection A d3 selection that represents the container(s) where the chart(s) will be rendered _data LineChartData The data to attach and generate the chart Source: line.js &lt;static&gt; aspectRatio(_x) Gets or Sets the aspect ratio of the chart Parameters: Name Type Description _x Number Desired aspect ratio for the graph Source: line.js Returns: Current aspect ratio or Line Chart module to chain calls Type Number | Module &lt;static&gt; colorSchema(_x) Gets or Sets the colorSchema of the chart Parameters: Name Type Description _x Array.&lt;String&gt; Desired colorSchema for the graph Source: line.js Returns: Current colorSchema or Chart module to chain calls Type colorSchema | module &lt;static&gt; dateLabel(_x) Gets or Sets the dateLabel of the chart Parameters: Name Type Description _x Number Desired dateLabel for the graph Source: line.js Returns: Current dateLabel or Chart module to chain calls Type dateLabel | module &lt;static&gt; exportChart() Chart exported to png and a download action is fired Source: line.js &lt;static&gt; forceAxisFormat(_x) Exposes the ability to force the chart to show a certain x axis grouping Parameters: Name Type Description _x String Desired format Source: line.js Returns: Current format or module to chain calls Type String | Module &lt;static&gt; height(_x) Gets or Sets the height of the chart Parameters: Name Type Description _x Number Desired width for the graph Source: line.js Returns: Current height or Line Chart module to chain calls Type Number | Module &lt;static&gt; margin(_x) Gets or Sets the margin of the chart Parameters: Name Type Description _x Object Margin object to get/set Source: line.js Returns: Current margin or Line Chart module to chain calls Type Number | Module &lt;static&gt; on() Exposes an 'on' method that acts as a bridge with the event dispatcher We are going to expose this events: customMouseHover, customMouseMove and customMouseOut Source: line.js Returns: Bar Chart Type module &lt;static&gt; tooltipThreshold(_x) Gets or Sets the minimum width of the graph in order to show the tooltip NOTE: This could also depend on the aspect ratio Parameters: Name Type Description _x Number Desired tooltip threshold for the graph Source: line.js Returns: Current tooltip threshold or Line Chart module to chain calls Type Number | Module &lt;static&gt; topicLabel(_x) Gets or Sets the topicLabel of the chart Parameters: Name Type Description _x Number Desired topicLabel for the graph Source: line.js Returns: Current topicLabel or Chart module to chain calls Type topicLabel | module &lt;static&gt; valueLabel(_x) Gets or Sets the valueLabel of the chart Parameters: Name Type Description _x Number Desired valueLabel for the graph Source: line.js Returns: Current valueLabel or Chart module to chain calls Type valueLabel | module &lt;static&gt; width(_x) Gets or Sets the width of the chart Parameters: Name Type Description _x Number Desired width for the graph Source: line.js Returns: Current width or Line Chart module to chain calls Type Number | Module × Search results Close "},"module-Mini-tooltip.html":{"id":"module-Mini-tooltip.html","title":"API: Mini-tooltip","body":" API BarBrushDonutLegendLineMini-tooltipSparklineStacked-areaStepTooltip Demos _GETTINGSTARTEDbarbrushdonutkitchen-sinklinesparklinestacked-areastep Global Global API: Mini-tooltip Mini Tooltip Component reusable API class that renders a simple and configurable tooltip element for Britechart's bar and step chart. (require(&quot;Mini-tooltip&quot;))(_selection, _data) This function creates the graph using the selection as container Parameters: Name Type Description _selection D3Selection A d3 selection that represents the container(s) where the chart(s) will be rendered _data Array The data to attach and generate the chart (usually an empty array) Source: mini-tooltip.js Requires module:d3 Methods module:Mini-tooltip(_selection, _data) This function creates the graph using the selection as container Parameters: Name Type Description _selection D3Selection A d3 selection that represents the container(s) where the chart(s) will be rendered _data Array The data to attach and generate the chart (usually an empty array) Source: mini-tooltip.js &lt;static&gt; hide() Hides the tooltip Source: mini-tooltip.js Returns: Tooltip module to chain calls Type Module &lt;static&gt; nameLabel(_x) Gets or Sets data's nameLabel Parameters: Name Type Description _x text Desired nameLabel Source: mini-tooltip.js Returns: nameLabel or Step Chart module to chain calls Type text | module &lt;static&gt; show() Shows the tooltip Source: mini-tooltip.js Returns: Tooltip module to chain calls Type Module &lt;static&gt; title(_x) Gets or Sets the title of the tooltip Parameters: Name Type Description _x string Desired title Source: mini-tooltip.js Returns: Current title or module to chain calls Type string | module &lt;static&gt; update(dataPoint, mousePosition, chartSize) Updates the position and content of the tooltip Parameters: Name Type Description dataPoint Object Datapoint of the hovered element mousePosition Array Mouse position relative to the parent chart [x, y] chartSize Array Parent chart size [x, y] Source: mini-tooltip.js Returns: Current component Type module × Search results Close "},"module-Sparkline.html":{"id":"module-Sparkline.html","title":"API: Sparkline","body":" API BarBrushDonutLegendLineMini-tooltipSparklineStacked-areaStepTooltip Demos _GETTINGSTARTEDbarbrushdonutkitchen-sinklinesparklinestacked-areastep Global Global API: Sparkline Sparkline Chart reusable API module that allows us rendering a sparkline configurable chart. (require(&quot;Sparkline&quot;))(_selection, _data) This function creates the graph using the selection and data provided Parameters: Name Type Description _selection D3Selection A d3 selection that represents the container(s) where the chart(s) will be rendered _data SparklineChartData The data to attach and generate the chart Source: sparkline.js Requires module:d3 Methods module:Sparkline(_selection, _data) This function creates the graph using the selection and data provided Parameters: Name Type Description _selection D3Selection A d3 selection that represents the container(s) where the chart(s) will be rendered _data SparklineChartData The data to attach and generate the chart Source: sparkline.js &lt;static&gt; areaGradient(_x) Gets or Sets the areaGradient of the chart Parameters: Name Type Description _x Array.&lt;String&gt; Desired areaGradient for the graph Source: sparkline.js Returns: Current areaGradient or Chart module to chain calls Type areaGradient | module &lt;static&gt; dateLabel(_x) Gets or Sets the dateLabel of the chart Parameters: Name Type Description _x Number Desired dateLabel for the graph Source: sparkline.js Returns: Current dateLabel or Chart module to chain calls Type dateLabel | module &lt;static&gt; duration(_x) Gets or Sets the duration of the animation Parameters: Name Type Description _x Number Desired animation duration for the graph Source: sparkline.js Returns: Current animation duration or Chart module to chain calls Type dateLabel | module &lt;static&gt; exportChart() Chart exported to png and a download action is fired Source: sparkline.js &lt;static&gt; height(_x) Gets or Sets the height of the chart Parameters: Name Type Description _x Number Desired width for the graph Source: sparkline.js Returns: Current height or Chart module to chain calls Type height | module &lt;static&gt; isAnimated(_x) Gets or Sets the isAnimated property of the chart Parameters: Name Type Description _x Boolean Desired animation flag Source: sparkline.js Returns: Current isAnimated flag or Chart module Type isAnimated | module &lt;static&gt; lineGradient(_x) Gets or Sets the lineGradient of the chart Parameters: Name Type Description _x Array.&lt;String&gt; Desired lineGradient for the graph Source: sparkline.js Returns: Current lineGradient or Chart module to chain calls Type lineGradient | module &lt;static&gt; margin(_x) Gets or Sets the margin of the chart Parameters: Name Type Description _x Object Margin object to get/set Source: sparkline.js Returns: Current margin or Chart module to chain calls Type margin | module &lt;static&gt; valueLabel(_x) Gets or Sets the valueLabel of the chart Parameters: Name Type Description _x Number Desired valueLabel for the graph Source: sparkline.js Returns: Current valueLabel or Chart module to chain calls Type valueLabel | module &lt;static&gt; width(_x) Gets or Sets the width of the chart Parameters: Name Type Description _x Number Desired width for the graph Source: sparkline.js Returns: Current width or Chart module to chain calls Type width | module × Search results Close "},"module-Stacked-area.html":{"id":"module-Stacked-area.html","title":"API: Stacked-area","body":" API BarBrushDonutLegendLineMini-tooltipSparklineStacked-areaStepTooltip Demos _GETTINGSTARTEDbarbrushdonutkitchen-sinklinesparklinestacked-areastep Global Global API: Stacked-area Stacked Area Chart reusable API module that allows us rendering a multi area and configurable chart. (require(&quot;Stacked-area&quot;))(_selection, _data) This function creates the graph using the selection and data provided Parameters: Name Type Description _selection D3Selection A d3 selection that represents the container(s) where the chart(s) will be rendered _data areaChartData The data to attach and generate the chart Source: stacked-area.js Requires module:d3-array, Methods module:Stacked-area(_selection, _data) This function creates the graph using the selection and data provided Parameters: Name Type Description _selection D3Selection A d3 selection that represents the container(s) where the chart(s) will be rendered _data areaChartData The data to attach and generate the chart Source: stacked-area.js &lt;static&gt; aspectRatio(_x) Gets or Sets the aspect ratio of the chart Parameters: Name Type Description _x Number Desired aspect ratio for the graph Source: stacked-area.js Returns: Current aspect ratio or Area Chart module to chain calls Type Number | Module &lt;static&gt; colorSchema(_x) Gets or Sets the colorSchema of the chart Parameters: Name Type Description _x Array.&lt;String&gt; Desired colorSchema for the graph Source: stacked-area.js Returns: Current colorSchema or Chart module to chain calls Type colorSchema | module &lt;static&gt; dateLabel(_x) Gets or Sets the dateLabel of the chart Parameters: Name Type Description _x Number Desired dateLabel for the graph Source: stacked-area.js Returns: Current dateLabel or Chart module to chain calls Type dateLabel | module &lt;static&gt; exportChart() Chart exported to png and a download action is fired Source: stacked-area.js &lt;static&gt; height(_x) Gets or Sets the height of the chart Parameters: Name Type Description _x Number Desired width for the graph Source: stacked-area.js Returns: Current height or Area Chart module to chain calls Type height | module &lt;static&gt; keyLabel(_x) Gets or Sets the keyLabel of the chart Parameters: Name Type Description _x Number Desired keyLabel for the graph Source: stacked-area.js Returns: Current keyLabel or Chart module to chain calls Type keyLabel | module &lt;static&gt; margin(_x) Gets or Sets the margin of the chart Parameters: Name Type Description _x Object Margin object to get/set Source: stacked-area.js Returns: Current margin or Area Chart module to chain calls Type margin | module &lt;static&gt; on() Exposes an 'on' method that acts as a bridge with the event dispatcher We are going to expose this events: customMouseOver, customMouseMove and customMouseOut Source: stacked-area.js Returns: Bar Chart Type module &lt;static&gt; tooltipThreshold(_x) Gets or Sets the tooltipThreshold of the chart Parameters: Name Type Description _x Object Margin object to get/set Source: stacked-area.js Returns: Current tooltipThreshold or Area Chart module to chain calls Type tooltipThreshold | module &lt;static&gt; valueLabel(_x) Gets or Sets the valueLabel of the chart Parameters: Name Type Description _x Number Desired valueLabel for the graph Source: stacked-area.js Returns: Current valueLabel or Chart module to chain calls Type valueLabel | module &lt;static&gt; width(_x) Gets or Sets the width of the chart Parameters: Name Type Description _x Number Desired width for the graph Source: stacked-area.js Returns: Current width or Area Chart module to chain calls Type width | module × Search results Close "},"module-Step.html":{"id":"module-Step.html","title":"API: Step","body":" API BarBrushDonutLegendLineMini-tooltipSparklineStacked-areaStepTooltip Demos _GETTINGSTARTEDbarbrushdonutkitchen-sinklinesparklinestacked-areastep Global Global API: Step Step Chart reusable API class that renders a simple and configurable step chart. (require(&quot;Step&quot;))(_selection, _data) This function creates the graph using the selection as container Parameters: Name Type Description _selection D3Selection A d3 selection that represents the container(s) where the chart(s) will be rendered _data StepChartData The data to attach and generate the chart Source: step.js Requires module:d3-array, Methods module:Step(_selection, _data) This function creates the graph using the selection as container Parameters: Name Type Description _selection D3Selection A d3 selection that represents the container(s) where the chart(s) will be rendered _data StepChartData The data to attach and generate the chart Source: step.js &lt;static&gt; exportChart() Chart exported to png and a download action is fired Source: step.js &lt;static&gt; exportChart() Chart exported to png and a download action is fired Source: step.js &lt;static&gt; height(_x) Gets or Sets the height of the chart Parameters: Name Type Description _x number Desired width for the graph Source: step.js Returns: Current height or Step Chart module to chain calls Type height | module &lt;static&gt; margin(_x) Gets or Sets the margin of the chart Parameters: Name Type Description _x object Margin object to get/set Source: step.js Returns: Current margin or Step Chart module to chain calls Type margin | module &lt;static&gt; numOfVerticalTicks(_x) Gets or Sets the number of vertical ticks on the chart Parameters: Name Type Description _x number Desired width for the graph Source: step.js Returns: Current height or Step Chart module to chain calls Type height | module &lt;static&gt; on() Exposes an 'on' method that acts as a bridge with the event dispatcher We are going to expose this events: customMouseOver, customMouseMove and customMouseOut Source: step.js Returns: Bar Chart Type module &lt;static&gt; width(_x) Gets or Sets the width of the chart Parameters: Name Type Description _x number Desired width for the graph Source: step.js Returns: Current width or step Chart module to chain calls Type width | module &lt;static&gt; xAxisLabel(_x) Gets or Sets the text of the xAxisLabel on the chart Parameters: Name Type Description _x text Desired text for the label Source: step.js Returns: label or Step Chart module to chain calls Type text | module &lt;static&gt; xAxisLabelOffset(_x) Gets or Sets the offset of the xAxisLabel on the chart Parameters: Name Type Description _x integer Desired offset for the label Source: step.js Returns: label or Step Chart module to chain calls Type integer | module &lt;static&gt; yAxisLabel(_x) Gets or Sets the text of the yAxisLabel on the chart Parameters: Name Type Description _x text Desired text for the label Source: step.js Returns: label or Step Chart module to chain calls Type text | module &lt;static&gt; yAxisLabelOffset(_x) Gets or Sets the offset of the yAxisLabel on the chart Parameters: Name Type Description _x integer Desired offset for the label Source: step.js Returns: label or Step Chart module to chain calls Type integer | module × Search results Close "},"module-Tooltip.html":{"id":"module-Tooltip.html","title":"API: Tooltip","body":" API BarBrushDonutLegendLineMini-tooltipSparklineStacked-areaStepTooltip Demos _GETTINGSTARTEDbarbrushdonutkitchen-sinklinesparklinestacked-areastep Global Global API: Tooltip Tooltip Component reusable API class that renders a simple and configurable tooltip element for Britechart's line chart or stacked area chart. (require(&quot;Tooltip&quot;))(_selection, _data) This function creates the graph using the selection as container Parameters: Name Type Description _selection D3Selection A d3 selection that represents the container(s) where the chart(s) will be rendered _data Object The data to attach and generate the chart Source: tooltip.js Requires module:d3-array, Members &lt;static&gt; axisTimeCombinations constants to be used to force the x axis to respect a certain granularity current options: HOUR_DAY, DAY_MONTH, MONTH_YEAR Source: tooltip.js Example tooltip.forceDateRange(tooltip.axisTimeCombinations.HOUR_DAY) Methods module:Tooltip(_selection, _data) This function creates the graph using the selection as container Parameters: Name Type Description _selection D3Selection A d3 selection that represents the container(s) where the chart(s) will be rendered _data Object The data to attach and generate the chart Source: tooltip.js &lt;static&gt; dateLabel(_x) Gets or Sets the dateLabel of the data Parameters: Name Type Description _x Number Desired dateLabel Source: tooltip.js Returns: Current dateLabel or Chart module to chain calls Type dateLabel | module &lt;static&gt; forceDateRange(_x) Exposes the ability to force the tooltip to use a certain date format Parameters: Name Type Description _x String Desired format Source: tooltip.js Returns: Current format or module to chain calls Type String | Module &lt;static&gt; hide() Hides the tooltip Source: tooltip.js Returns: Tooltip module to chain calls Type Module &lt;static&gt; show() Shows the tooltip Source: tooltip.js Returns: Tooltip module to chain calls Type Module &lt;static&gt; title(_x) Gets or Sets the title of the tooltip Parameters: Name Type Description _x string Desired title Source: tooltip.js Returns: Current title or module to chain calls Type string | module &lt;static&gt; topicLabel(_x) Gets or Sets the topicLabel of the data Parameters: Name Type Description _x Number Desired topicLabel Source: tooltip.js Returns: Current topicLabel or Chart module to chain calls Type topicLabel | module &lt;static&gt; update(dataPoint, colorMapping, position) Updates the position and content of the tooltip Parameters: Name Type Description dataPoint Object Datapoint to represent colorMapping Object Color scheme of the topics position Number X-scale position in pixels Source: tooltip.js Returns: Tooltip module to chain calls Type Module &lt;static&gt; valueLabel(_x) Gets or Sets the valueLabel of the data Parameters: Name Type Description _x Number Desired valueLabel Source: tooltip.js Returns: Current valueLabel or Chart module to chain calls Type valueLabel | module × Search results Close "},"tutorial--_GETTINGSTARTED.html":{"id":"tutorial--_GETTINGSTARTED.html","title":"Tutorial: _GETTINGSTARTED","body":" API BarBrushDonutLegendLineMini-tooltipSparklineStacked-areaStepTooltip Demos _GETTINGSTARTEDbarbrushdonutkitchen-sinklinesparklinestacked-areastep Global Global _GETTINGSTARTED Getting Started with BritechartsBritecharts has been created to help users consume and create d3 charts. It leverages a reusable API, which produces chart objects that (after initialization) can be configured and then applied to a container with a data set to plot. Using Britecharts in your projectIn order to use a Britecharts chart in your project you would need to: Add Britecharts as a dependency in your package.json (not needed in core). &quot;britecharts&quot;: &quot;git+https://git@github.com/eventbrite/britecharts.git&quot; Require the proper chart as a requirejs module, we can do: LineChart = require('britecharts/dist/umd/line.min') Require D3Selection as a dependency, in order to select a container to execute the chart on. d3Selection = require('d3-selection') Call the chart with a container and data attached to the container. var container = d3Selection.select('.chart-container'), lineChart = new LineChart(); if (container.node()) { lineChart .tooltipThreshold(tooltipShouldShowThreshold) .margin(chartMargin) .height(chartHeight) .width(chartWidth); } // This line gets together container, data and chart container.datum(data).call(lineChart);And that would generate your britechart! It won't look perfect though, you will need to load a small CSS file in order to see it styled. You can load the whole bundle: &lt;link type=&quot;text/css&quot; rel=&quot;stylesheet&quot; href=&quot;pathToBritecharts/dist/css/bundle.css&quot;&gt;or just load the styles for the current chart: &lt;link type=&quot;text/css&quot; rel=&quot;stylesheet&quot; href=&quot;pathToBritecharts/dist/css/charts/line.css&quot;&gt;Making it ResponsiveYou will probably want to set up a listener for the resize event to re-render the chart, and probably debounce it, so it doesn't render too many times. Check in our kitchen sink all the available charts. If you already know d3.js and you enjoy the project, we hope you could try to make your own chart. × Search results Close "},"tutorial-bar.html":{"id":"tutorial-bar.html","title":"Tutorial: bar","body":" Bar Chart with Tooltip The code barChart .width(containerWidth) .height(300) .on('customMouseHover', tooltip.show) .on('customMouseMove', tooltip.update); .on('customMouseOut', tooltip.hide); barContainer.datum(dataset).call(barChart); tooltipContainer = d3.select('.bar-chart .metadata-group'); tooltipContainer.datum([]).call(tooltip); Export Chart You can also export this chart by pressing Horizontal Bar Chart The code barChart .horizontal(true) .width(containerWidth) .height(300); barContainer.datum(dataset).call(barChart); Simple Bar Chart The code barChart .width(containerWidth) .height(300); barContainer.datum(dataset).call(barChart); × Search results Close "},"tutorial-brush.html":{"id":"tutorial-brush.html","title":"Tutorial: brush","body":" Simple Brush Chart Selected from to Brush chart to use with other charts as a time range selector. The code brushChart .width(containerWidth) .height(300) .onBrush(function(brushExtent) { // Do something with the brushExtent }); brushContainer.datum(dataset).call(brushChart); × Search results Close "},"tutorial-donut.html":{"id":"tutorial-donut.html","title":"Tutorial: donut","body":" Donut Chart with Legend The code donutChart .width(containerWidth) .height(containerWidth) .externalRadius(containerWidth/2.5) .internalRadius(containerWidth/5) .colorScheme(briteChartsColors) .on('customMouseOver', function(data) { legendChart.highlight(data.data.id); }) .on('customMouseOut', function() { legendChart.clearHighlight(); }); donutContainer.datum(dataset).call(donutChart); legendContainer.datum(dataset).call(legendChart); Colors You can also check other color schemas: Export Chart You can also export this chart by pressing: Simple Donut Chart The code donutChart .width(containerWidth) .height(containerWidth) .externalRadius(containerWidth/4) .internalRadius(containerWidth/8); donutContainer.datum(dataset).call(donutChart); × Search results Close "},"tutorial-kitchen-sink.html":{"id":"tutorial-kitchen-sink.html","title":"Tutorial: kitchen-sink","body":" Bar Chart Horizontal Bar Chart Line Chart Donut Chart Brush Chart Selected from to Step Chart Stacked Area Chart × Search results Close "},"tutorial-line.html":{"id":"tutorial-line.html","title":"Tutorial: line","body":" Line Chart with fixed Aspect Ratio The code lineChart .aspectRatio(0.5) .tooltipThreshold(600) .width(containerWidth); container.datum(dataset).call(lineChart); Colors You can also check other color schemas: Export Chart You can also export this chart by pressing: Line Chart with a single data source This is the same chart as above, but when there is a single data source we apply a gradient to the line to give it a little flair. This chart has a fixed height like the one below. The code lineChart .tooltipThreshold(600) .height(300) .width(containerWidth); container.datum(dataset).call(lineChart); Export Chart You can also export this chart by pressing: Line Chart with Fixed Height In this case, we have set a fixed height on the chart, as we are currently doing on the Sales report: The code lineChart .tooltipThreshold(600) .height(300) .width(containerWidth); container.datum(dataset).call(lineChart); × Search results Close "},"tutorial-sparkline.html":{"id":"tutorial-sparkline.html","title":"Tutorial: sparkline","body":" Sparkline Chart This is the sparkline chart used for showing trends in data over time. We have included a resize listener to show how the different charts respond to changes on the viewport. The code sparklineChart .dateLabel('dateUTC') .isAnimated(true) .duration(2500) .height(containerWidth / 3) .width(containerWidth / 2); container.datum(dataset) .call(sparklineChart); Export Chart You can also export this chart by pressing: × Search results Close "},"tutorial-stacked-area.html":{"id":"tutorial-stacked-area.html","title":"Tutorial: stacked-area","body":" Stacked Area Chart with Tooltip The code // StackedAreChart Setup and start stackedArea .tooltipThreshold(400) .width(containerWidth) .on('customMouseOver', function() { chartTooltip.show(); }) .on('customMouseMove', function(dataPoint, topicColorMap, dataPointXPosition) { chartTooltip.update(dataPoint, topicColorMap, dataPointXPosition); }) .on('customMouseOut', function() { chartTooltip.hide(); }); container.datum(dataset.data).call(stackedArea); // Tooltip Setup and start chartTooltip .title('Testing tooltip'); // Note that if the viewport width is less than the tooltipThreshold value, // this container won't exist, and the tooltip won't show up tooltipContainer = d3.select('.metadata-group .vertical-marker-container'); tooltipContainer.datum([]).call(chartTooltip); Colors You can also check other color schemas: Export Chart You can also export this chart by pressing: Stacked Area Chart with fixed Aspect Ratio The code // StackedAreChart Setup and start stackedArea .tooltipThreshold(400) .width(containerWidth) .aspectRatio(0.6) .on('customMouseOver', function() { chartTooltip.show(); }) .on('customMouseMove', function(dataPoint, topicColorMap, dataPointXPosition) { chartTooltip.update(dataPoint, topicColorMap, dataPointXPosition); }) .on('customMouseOut', function() { chartTooltip.hide(); }); container.datum(dataset.data).call(stackedArea); // Tooltip Setup and start chartTooltip .title('Testing tooltip'); // Note that if the viewport width is less than the tooltipThreshold value, // this container won't exist, and the tooltip won't show up tooltipContainer = d3.select('.metadata-group .vertical-marker-container'); tooltipContainer.datum([]).call(chartTooltip); × Search results Close "},"tutorial-step.html":{"id":"tutorial-step.html","title":"Tutorial: step","body":" Step Chart The code // StepChart without Axis Labels: stepChart .width(500) .height(300); stepContainer.datum(dataset).call(stepChart); // StepChart with Axis Labels: // If the labels get cutoff when added, it's a good idea // to tweak the left margin to get the look you want stepChart .width(500) .height(300) .xAxisLabel('Fruit Type') .xAxisLabelOffset(45) .yAxisLabel('Quantity') .yAxisLabelOffset(-45) .margin({ top: 20, right: 20, bottom: 30, left: 65 }); stepContainer.datum(dataset).call(stepChart); Export Chart You can also export this chart by pressing: × Search results Close "}}
    </script>

    <script type="text/javascript">
        $(document).ready(function() {
            Searcher.init();
        });

        $(window).on("message", function(msg) {
            var msgData = msg.originalEvent.data;

            if (msgData.msgid != "docstrap.quicksearch.start") {
                return;
            }

            var results = Searcher.search(msgData.searchTerms);

            window.parent.postMessage({"results": results, "msgid": "docstrap.quicksearch.done"}, "*");
        });
    </script>
</body>
</html>
