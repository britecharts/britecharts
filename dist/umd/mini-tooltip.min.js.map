{"version":3,"sources":["webpack:///webpack/universalModuleDefinition?5ca6****","webpack:///mini-tooltip.min.js","webpack:///webpack/bootstrap 3078ad2e01e313492c35?c726****","webpack:///./src/charts/mini-tooltip.js","webpack:///external \"d3\"?c0c4****"],"names":["root","factory","exports","module","require","define","amd","a","i","this","__WEBPACK_EXTERNAL_MODULE_1__","modules","__webpack_require__","moduleId","installedModules","id","loaded","call","m","c","p","__WEBPACK_AMD_DEFINE_RESULT__","_slicedToArray","sliceIterator","arr","_arr","_n","_d","_e","undefined","_s","_i","Symbol","iterator","next","done","push","value","length","err","Array","isArray","Object","TypeError","d3","_selection","each","_data","chartWidth","width","margin","left","right","chartHeight","height","top","bottom","buildSVG","drawTooltip","buildContainerGroups","container","svg","append","classed","attr","transform","select","transition","ease","hide","tooltipTextContainer","selectAll","tooltipBackground","rx","backgroundBorderRadius","ry","y","x","style","fill","bodyFillColor","stroke","borderStrokeColor","stroke-width","pointer-events","opacity","getMaxLengthLine","_len","arguments","texts","_key","textSizes","filter","map","node","getBBox","max","getTooltipPosition","_ref","_ref2","_ref4","mouseX","mouseY","_ref3","parentChartWidth","parentChartHeight","tooltipX","tooltipY","hasEnoughHorizontalRoom","tooltipOffset","hasEnoughVerticalRoom","positionX","positionY","hideTooltip","showTooltip","dataPoint","updateContent","valueLabel","name","nameLabel","lineHeight","textSize","textLineHeight","valueLineHeight","valueTextSize","valueTextLineHeight","defaultDy","temporalHeight","tooltipValue","tooltipName","tooltipTitle","remove","title","dy","titleFillColor","text","nameTextFillColor","valueTextFillColor","valueTextWeight","tooltipValueFormat","updatePositionAndSize","mousePosition","parentChartSize","_getTooltipPosition","_getTooltipPosition2","newSize","duration","mouseChaseDuration","updateTooltip","position","chartSize","format","show","_x","update"],"mappings":"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","file":"mini-tooltip.min.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(require(\"d3\"));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([\"d3\"], factory);\n\telse {\n\t\tvar a = typeof exports === 'object' ? factory(require(\"d3\")) : factory(root[\"d3\"]);\n\t\tfor(var i in a) (typeof exports === 'object' ? exports : root)[i] = a[i];\n\t}\n})(this, function(__WEBPACK_EXTERNAL_MODULE_1__) {\nreturn \n\n\n/** WEBPACK FOOTER **\n ** webpack/universalModuleDefinition\n **/","(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(require(\"d3\"));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([\"d3\"], factory);\n\telse {\n\t\tvar a = typeof exports === 'object' ? factory(require(\"d3\")) : factory(root[\"d3\"]);\n\t\tfor(var i in a) (typeof exports === 'object' ? exports : root)[i] = a[i];\n\t}\n})(this, function(__WEBPACK_EXTERNAL_MODULE_1__) {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_RESULT__;'use strict';\n\t\n\tvar _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"]) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); } }; }();\n\t\n\t!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {\n\t    'use strict';\n\t\n\t    var d3 = __webpack_require__(1);\n\t\n\t    /**\n\t     * Mini Tooltip Component reusable API class that renders a\n\t     * simple and configurable tooltip element for Britechart's\n\t     * bar and step chart.\n\t     *\n\t     * @module Mini-tooltip\n\t     * @version 0.0.1\n\t     * @tutorial bar\n\t     * @requires d3\n\t     *\n\t     * @example\n\t     * var barChart = line(),\n\t     *     miniTooltip = miniTooltip();\n\t     *\n\t     * barChart\n\t     *     .width(500)\n\t     *     .height(300)\n\t     *     .on('customMouseHover', miniTooltip.show)\n\t     *     .on('customMouseMove', miniTooltip.update)\n\t     *     .on('customMouseOut', miniTooltip.hide);\n\t     *\n\t     * d3.select('.css-selector')\n\t     *     .datum(dataset)\n\t     *     .call(barChart);\n\t     *\n\t     * d3.select('.metadata-group .mini-tooltip-container')\n\t     *     .datum([])\n\t     *     .call(miniTooltip);\n\t     *\n\t     */\n\t    return function module() {\n\t\n\t        var margin = {\n\t            top: 12,\n\t            right: 12,\n\t            bottom: 12,\n\t            left: 12\n\t        },\n\t            width = 50,\n\t            height = 50,\n\t\n\t\n\t        // Optional Title\n\t        title = '',\n\t\n\t\n\t        // Data Format\n\t        valueLabel = 'value',\n\t            nameLabel = 'name',\n\t\n\t\n\t        // Animations\n\t        mouseChaseDuration = 200,\n\t            ease = 'ease-in',\n\t\n\t\n\t        // tooltip\n\t        tooltipBackground = void 0,\n\t            backgroundBorderRadius = 1,\n\t            tooltipTextContainer = void 0,\n\t            tooltipOffset = {\n\t            y: 0,\n\t            x: 20\n\t        },\n\t\n\t\n\t        // Fonts\n\t        textSize = 14,\n\t            textLineHeight = 1.5,\n\t            valueTextSize = 27,\n\t            valueTextLineHeight = 1.18,\n\t\n\t\n\t        // Colors\n\t        bodyFillColor = '#FFFFFF',\n\t            borderStrokeColor = '#D2D6DF',\n\t            titleFillColor = '#666a73',\n\t            nameTextFillColor = '#666a73',\n\t            valueTextFillColor = '#45494E',\n\t            valueTextWeight = 200,\n\t\n\t\n\t        // formats\n\t        tooltipValueFormat = d3.format(',1f'),\n\t            chartWidth = void 0,\n\t            chartHeight = void 0,\n\t            svg = void 0;\n\t\n\t        /**\n\t         * This function creates the graph using the selection as container\n\t         * @param {D3Selection} _selection A d3 selection that represents\n\t         *                                  the container(s) where the chart(s) will be rendered\n\t         * @param {Array} _data The data to attach and generate the chart (usually an empty array)\n\t         */\n\t        function exports(_selection) {\n\t            _selection.each(function (_data) {\n\t                chartWidth = width - margin.left - margin.right;\n\t                chartHeight = height - margin.top - margin.bottom;\n\t\n\t                buildSVG(this);\n\t                drawTooltip();\n\t            });\n\t        }\n\t\n\t        /**\n\t         * Builds containers for the tooltip\n\t         * Also applies the Margin convention\n\t         * @private\n\t         */\n\t        function buildContainerGroups() {\n\t            var container = svg.append('g').classed('tooltip-container-group', true).attr({\n\t                transform: 'translate( ' + margin.left + ', ' + margin.top + ')'\n\t            });\n\t\n\t            container.append('g').classed('tooltip-group', true);\n\t        }\n\t\n\t        /**\n\t         * Builds the SVG element that will contain the chart\n\t         * @param  {HTMLElement} container DOM element that will work as the container of the graph\n\t         * @private\n\t         */\n\t        function buildSVG(container) {\n\t            if (!svg) {\n\t                svg = d3.select(container).append('g').classed('britechart britechart-mini-tooltip', true);\n\t\n\t                buildContainerGroups();\n\t            }\n\t            svg.transition().ease(ease).attr({\n\t                width: width + margin.left + margin.right,\n\t                height: height + margin.top + margin.bottom\n\t            });\n\t            // Hidden by default\n\t            exports.hide();\n\t        }\n\t\n\t        /**\n\t         * Draws the different elements of the Tooltip box\n\t         * @return void\n\t         */\n\t        function drawTooltip() {\n\t            tooltipTextContainer = svg.selectAll('.tooltip-group').append('g').classed('tooltip-text', true);\n\t\n\t            tooltipBackground = tooltipTextContainer.append('rect').classed('tooltip-background', true).attr({\n\t                'width': width,\n\t                'height': height,\n\t                'rx': backgroundBorderRadius,\n\t                'ry': backgroundBorderRadius,\n\t                'y': -margin.top,\n\t                'x': -margin.left\n\t            }).style({\n\t                'fill': bodyFillColor,\n\t                'stroke': borderStrokeColor,\n\t                'stroke-width': 1,\n\t                'pointer-events': 'none',\n\t                'opacity': 0.9\n\t            });\n\t        }\n\t\n\t        /**\n\t         * Figures out the max length of the tooltip lines\n\t         * @param  {D3Selection[]} texts    List of svg elements of each line\n\t         * @return {Number}                 Max size of the lines\n\t         */\n\t        function getMaxLengthLine() {\n\t            for (var _len = arguments.length, texts = Array(_len), _key = 0; _key < _len; _key++) {\n\t                texts[_key] = arguments[_key];\n\t            }\n\t\n\t            var textSizes = texts.filter(function (x) {\n\t                return !!x;\n\t            }).map(function (x) {\n\t                return x.node().getBBox().width;\n\t            });\n\t\n\t            return d3.max(textSizes);\n\t        }\n\t\n\t        /**\n\t         * Calculates the desired position for the tooltip\n\t         * @param  {Number} mouseX             Current horizontal mouse position\n\t         * @param  {Number} mouseY             Current vertical mouse position\n\t         * @param  {Number} parentChartWidth   Parent's chart width\n\t         * @param  {Number} parentChartHeight  Parent's chart height\n\t         * @return {Number[]}                  X and Y position\n\t         * @private\n\t         */\n\t        function getTooltipPosition(_ref, _ref2) {\n\t            var _ref4 = _slicedToArray(_ref, 2);\n\t\n\t            var mouseX = _ref4[0];\n\t            var mouseY = _ref4[1];\n\t\n\t            var _ref3 = _slicedToArray(_ref2, 2);\n\t\n\t            var parentChartWidth = _ref3[0];\n\t            var parentChartHeight = _ref3[1];\n\t\n\t            var tooltipX = void 0,\n\t                tooltipY = void 0;\n\t\n\t            if (hasEnoughHorizontalRoom(parentChartWidth, mouseX)) {\n\t                tooltipX = mouseX + tooltipOffset.x;\n\t            } else {\n\t                tooltipX = mouseX - chartWidth - tooltipOffset.x - margin.right;\n\t            }\n\t\n\t            if (hasEnoughVerticalRoom(parentChartHeight, mouseY)) {\n\t                tooltipY = mouseY + tooltipOffset.y;\n\t            } else {\n\t                tooltipY = mouseY - chartHeight - tooltipOffset.y - margin.bottom;\n\t            }\n\t\n\t            return [tooltipX, tooltipY];\n\t        }\n\t\n\t        /**\n\t         * Checks if the mouse is over the bounds of the parent chart\n\t         * @param  {Number}  chartWidth Parent's chart\n\t         * @param  {Number}  positionX  Mouse position\n\t         * @return {Boolean}            If the mouse position allows space for the tooltip\n\t         */\n\t        function hasEnoughHorizontalRoom(parentChartWidth, positionX) {\n\t            return parentChartWidth - margin.left - margin.right - chartWidth - positionX > 0;\n\t        }\n\t\n\t        /**\n\t         * Checks if the mouse is over the bounds of the parent chart\n\t         * @param  {Number}  chartWidth Parent's chart\n\t         * @param  {Number}  positionX  Mouse position\n\t         * @return {Boolean}            If the mouse position allows space for the tooltip\n\t         */\n\t        function hasEnoughVerticalRoom(parentChartHeight, positionY) {\n\t            return parentChartHeight - margin.top - margin.bottom - chartHeight - positionY > 0;\n\t        }\n\t\n\t        /**\n\t         * Hides the tooltip\n\t         * @return {void}\n\t         */\n\t        function hideTooltip() {\n\t            svg.style('display', 'none');\n\t        }\n\t\n\t        /**\n\t         * Shows the tooltip updating it's content\n\t         * @param  {Object} dataPoint Data point from the chart\n\t         * @return {void}\n\t         */\n\t        function showTooltip(dataPoint) {\n\t            updateContent(dataPoint);\n\t            svg.style('display', 'block');\n\t        }\n\t\n\t        /**\n\t         * Draws the data entries inside the tooltip for a given topic\n\t         * @param  {Object} topic Topic to extract data from\n\t         * @return void\n\t         */\n\t        function updateContent() {\n\t            var dataPoint = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\t\n\t            var value = dataPoint[valueLabel] || '',\n\t                name = dataPoint[nameLabel] || '',\n\t                lineHeight = textSize * textLineHeight,\n\t                valueLineHeight = valueTextSize * valueTextLineHeight,\n\t                defaultDy = '1em',\n\t                temporalHeight = 0,\n\t                tooltipValue = void 0,\n\t                tooltipName = void 0,\n\t                tooltipTitle = void 0;\n\t\n\t            tooltipTextContainer.selectAll('text').remove();\n\t\n\t            if (title) {\n\t                tooltipTitle = tooltipTextContainer.append('text').classed('mini-tooltip-title', true).attr({\n\t                    'dy': defaultDy,\n\t                    'y': 0\n\t                }).style('fill', titleFillColor).style('font-size', textSize).text(title);\n\t\n\t                temporalHeight = lineHeight + temporalHeight;\n\t            }\n\t\n\t            if (name) {\n\t                tooltipName = tooltipTextContainer.append('text').classed('mini-tooltip-name', true).attr({\n\t                    'dy': defaultDy,\n\t                    'y': temporalHeight || 0\n\t                }).style('fill', nameTextFillColor).style('font-size', textSize).text(name);\n\t\n\t                temporalHeight = lineHeight + temporalHeight;\n\t            }\n\t\n\t            if (value) {\n\t                tooltipValue = tooltipTextContainer.append('text').classed('mini-tooltip-value', true).attr({\n\t                    'dy': defaultDy,\n\t                    'y': temporalHeight || 0\n\t                }).style('fill', valueTextFillColor).style('font-size', valueTextSize).style('font-weight', valueTextWeight).text(tooltipValueFormat(value));\n\t\n\t                temporalHeight = valueLineHeight + temporalHeight;\n\t            }\n\t\n\t            chartWidth = getMaxLengthLine(tooltipName, tooltipTitle, tooltipValue);\n\t            chartHeight = temporalHeight;\n\t        }\n\t\n\t        /**\n\t         * Updates size and position of tooltip depending on the side of the chart we are in\n\t         * @param  {Object} dataPoint DataPoint of the tooltip\n\t         * @return void\n\t         */\n\t        function updatePositionAndSize(mousePosition, parentChartSize) {\n\t            var _getTooltipPosition = getTooltipPosition(mousePosition, parentChartSize);\n\t\n\t            var _getTooltipPosition2 = _slicedToArray(_getTooltipPosition, 2);\n\t\n\t            var tooltipX = _getTooltipPosition2[0];\n\t            var tooltipY = _getTooltipPosition2[1];\n\t\n\t            var newSize = {\n\t                width: chartWidth + margin.left + margin.right,\n\t                height: chartHeight + margin.top + margin.bottom\n\t            };\n\t\n\t            svg.transition().duration(mouseChaseDuration).ease(ease).attr(newSize).attr('transform', 'translate(' + tooltipX + ',' + tooltipY + ')');\n\t\n\t            tooltipBackground.transition().ease(ease).attr(newSize);\n\t        }\n\t\n\t        /**\n\t         * Updates tooltip content, size and position\n\t         *\n\t         * @param  {Object} dataPoint Current datapoint to show info about\n\t         * @return void\n\t         */\n\t        function updateTooltip(dataPoint, position, chartSize) {\n\t            updateContent(dataPoint);\n\t            updatePositionAndSize(position, chartSize);\n\t        }\n\t\n\t        /**\n\t         * Hides the tooltip\n\t         * @return {Module} Tooltip module to chain calls\n\t         * @public\n\t         */\n\t        exports.hide = function () {\n\t            hideTooltip();\n\t\n\t            return this;\n\t        };\n\t\n\t        /**\n\t         * Shows the tooltip\n\t         * @return {Module} Tooltip module to chain calls\n\t         * @public\n\t         */\n\t        exports.show = function () {\n\t            showTooltip();\n\t\n\t            return this;\n\t        };\n\t\n\t        /**\n\t         * Gets or Sets the title of the tooltip\n\t         * @param  {string} _x Desired title\n\t         * @return { string | module} Current title or module to chain calls\n\t         * @public\n\t         */\n\t        exports.title = function (_x) {\n\t            if (!arguments.length) {\n\t                return title;\n\t            }\n\t            title = _x;\n\t            return this;\n\t        };\n\t\n\t        /**\n\t         * Updates the position and content of the tooltip\n\t         * @param  {Object} dataPoint       Datapoint of the hovered element\n\t         * @param  {Array} mousePosition    Mouse position relative to the parent chart [x, y]\n\t         * @param  {Array} chartSize        Parent chart size [x, y]\n\t         * @return {module}                 Current component\n\t         */\n\t        exports.update = function (dataPoint, mousePosition, chartSize) {\n\t            updateTooltip(dataPoint, mousePosition, chartSize);\n\t\n\t            return this;\n\t        };\n\t\n\t        return exports;\n\t    };\n\t}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n/***/ },\n/* 1 */\n/***/ function(module, exports) {\n\n\tmodule.exports = __WEBPACK_EXTERNAL_MODULE_1__;\n\n/***/ }\n/******/ ])\n});\n;\n\n\n/** WEBPACK FOOTER **\n ** mini-tooltip.min.js\n **/"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n/** WEBPACK FOOTER **\n ** webpack/bootstrap 3078ad2e01e313492c35\n **/","define(function(require){\n    'use strict';\n\n    const d3 = require('d3');\n\n    /**\n     * Mini Tooltip Component reusable API class that renders a\n     * simple and configurable tooltip element for Britechart's\n     * bar and step chart.\n     *\n     * @module Mini-tooltip\n     * @version 0.0.1\n     * @tutorial bar\n     * @requires d3\n     *\n     * @example\n     * var barChart = line(),\n     *     miniTooltip = miniTooltip();\n     *\n     * barChart\n     *     .width(500)\n     *     .height(300)\n     *     .on('customMouseHover', miniTooltip.show)\n     *     .on('customMouseMove', miniTooltip.update)\n     *     .on('customMouseOut', miniTooltip.hide);\n     *\n     * d3.select('.css-selector')\n     *     .datum(dataset)\n     *     .call(barChart);\n     *\n     * d3.select('.metadata-group .mini-tooltip-container')\n     *     .datum([])\n     *     .call(miniTooltip);\n     *\n     */\n    return function module() {\n\n        let margin = {\n                top: 12,\n                right: 12,\n                bottom: 12,\n                left: 12\n            },\n            width = 50,\n            height = 50,\n\n            // Optional Title\n            title = '',\n\n            // Data Format\n            valueLabel = 'value',\n            nameLabel = 'name',\n\n            // Animations\n            mouseChaseDuration = 200,\n            ease = 'ease-in',\n\n            // tooltip\n            tooltipBackground,\n            backgroundBorderRadius = 1,\n            tooltipTextContainer,\n            tooltipOffset = {\n                y: 0,\n                x: 20\n            },\n\n            // Fonts\n            textSize = 14,\n            textLineHeight = 1.5,\n            valueTextSize = 27,\n            valueTextLineHeight = 1.18,\n\n            // Colors\n            bodyFillColor = '#FFFFFF',\n            borderStrokeColor = '#D2D6DF',\n            titleFillColor = '#666a73',\n            nameTextFillColor = '#666a73',\n            valueTextFillColor = '#45494E',\n            valueTextWeight = 200,\n\n            // formats\n            tooltipValueFormat = d3.format(',1f'),\n\n            chartWidth,\n            chartHeight,\n            svg;\n\n\n        /**\n         * This function creates the graph using the selection as container\n         * @param {D3Selection} _selection A d3 selection that represents\n         *                                  the container(s) where the chart(s) will be rendered\n         * @param {Array} _data The data to attach and generate the chart (usually an empty array)\n         */\n        function exports(_selection) {\n            _selection.each(function(_data){\n                chartWidth = width - margin.left - margin.right;\n                chartHeight = height - margin.top - margin.bottom;\n\n                buildSVG(this);\n                drawTooltip();\n            });\n        }\n\n        /**\n         * Builds containers for the tooltip\n         * Also applies the Margin convention\n         * @private\n         */\n        function buildContainerGroups() {\n            let container = svg.append('g')\n                .classed('tooltip-container-group', true)\n                .attr({\n                    transform: `translate( ${margin.left}, ${margin.top})`\n                });\n\n            container.append('g').classed('tooltip-group', true);\n        }\n\n        /**\n         * Builds the SVG element that will contain the chart\n         * @param  {HTMLElement} container DOM element that will work as the container of the graph\n         * @private\n         */\n        function buildSVG(container) {\n            if (!svg) {\n                svg = d3.select(container)\n                    .append('g')\n                    .classed('britechart britechart-mini-tooltip', true);\n\n                buildContainerGroups();\n            }\n            svg\n                .transition()\n                .ease(ease)\n                .attr({\n                width: width + margin.left + margin.right,\n                height: height + margin.top + margin.bottom\n            });\n            // Hidden by default\n            exports.hide();\n        }\n\n        /**\n         * Draws the different elements of the Tooltip box\n         * @return void\n         */\n        function drawTooltip(){\n            tooltipTextContainer = svg.selectAll('.tooltip-group')\n                .append('g')\n                .classed('tooltip-text', true);\n\n            tooltipBackground = tooltipTextContainer\n              .append('rect')\n                .classed('tooltip-background', true)\n                .attr({\n                    'width': width,\n                    'height': height,\n                    'rx': backgroundBorderRadius,\n                    'ry': backgroundBorderRadius,\n                    'y': - margin.top,\n                    'x': - margin.left\n                })\n                .style({\n                    'fill': bodyFillColor,\n                    'stroke': borderStrokeColor,\n                    'stroke-width': 1,\n                    'pointer-events': 'none',\n                    'opacity': 0.9\n                });\n        }\n\n        /**\n         * Figures out the max length of the tooltip lines\n         * @param  {D3Selection[]} texts    List of svg elements of each line\n         * @return {Number}                 Max size of the lines\n         */\n        function getMaxLengthLine(...texts) {\n            let textSizes = texts.filter(x => !!x)\n                .map(x => x.node().getBBox().width);\n\n            return d3.max(textSizes);\n        }\n\n        /**\n         * Calculates the desired position for the tooltip\n         * @param  {Number} mouseX             Current horizontal mouse position\n         * @param  {Number} mouseY             Current vertical mouse position\n         * @param  {Number} parentChartWidth   Parent's chart width\n         * @param  {Number} parentChartHeight  Parent's chart height\n         * @return {Number[]}                  X and Y position\n         * @private\n         */\n        function getTooltipPosition([mouseX, mouseY], [parentChartWidth, parentChartHeight]) {\n            let tooltipX, tooltipY;\n\n            if (hasEnoughHorizontalRoom(parentChartWidth, mouseX)) {\n                tooltipX = mouseX + tooltipOffset.x;\n            } else {\n                tooltipX = mouseX - chartWidth - tooltipOffset.x - margin.right;\n            }\n\n            if (hasEnoughVerticalRoom(parentChartHeight, mouseY)) {\n                tooltipY = mouseY + tooltipOffset.y;\n            } else {\n                tooltipY = mouseY - chartHeight - tooltipOffset.y - margin.bottom;\n            }\n\n            return [tooltipX, tooltipY];\n        }\n\n        /**\n         * Checks if the mouse is over the bounds of the parent chart\n         * @param  {Number}  chartWidth Parent's chart\n         * @param  {Number}  positionX  Mouse position\n         * @return {Boolean}            If the mouse position allows space for the tooltip\n         */\n        function hasEnoughHorizontalRoom(parentChartWidth, positionX) {\n            return (parentChartWidth - margin.left - margin.right - chartWidth) - positionX > 0;\n        }\n\n        /**\n         * Checks if the mouse is over the bounds of the parent chart\n         * @param  {Number}  chartWidth Parent's chart\n         * @param  {Number}  positionX  Mouse position\n         * @return {Boolean}            If the mouse position allows space for the tooltip\n         */\n        function hasEnoughVerticalRoom(parentChartHeight, positionY) {\n            return (parentChartHeight - margin.top - margin.bottom - chartHeight) - positionY > 0;\n        }\n\n        /**\n         * Hides the tooltip\n         * @return {void}\n         */\n        function hideTooltip() {\n            svg.style('display', 'none');\n        }\n\n        /**\n         * Shows the tooltip updating it's content\n         * @param  {Object} dataPoint Data point from the chart\n         * @return {void}\n         */\n        function showTooltip(dataPoint) {\n            updateContent(dataPoint);\n            svg.style('display', 'block');\n        }\n\n        /**\n         * Draws the data entries inside the tooltip for a given topic\n         * @param  {Object} topic Topic to extract data from\n         * @return void\n         */\n        function updateContent(dataPoint = {}){\n            let value = dataPoint[valueLabel] || '',\n                name = dataPoint[nameLabel] || '',\n                lineHeight = textSize * textLineHeight,\n                valueLineHeight = valueTextSize * valueTextLineHeight,\n                defaultDy = '1em',\n                temporalHeight = 0,\n                tooltipValue,\n                tooltipName,\n                tooltipTitle;\n\n            tooltipTextContainer.selectAll('text')\n                .remove();\n\n            if (title) {\n                tooltipTitle = tooltipTextContainer\n                  .append('text')\n                    .classed('mini-tooltip-title', true)\n                    .attr({\n                        'dy': defaultDy,\n                        'y': 0\n                    })\n                    .style('fill', titleFillColor)\n                    .style('font-size', textSize)\n                    .text(title);\n\n                temporalHeight = lineHeight + temporalHeight;\n            }\n\n            if (name) {\n                tooltipName = tooltipTextContainer\n                  .append('text')\n                    .classed('mini-tooltip-name', true)\n                    .attr({\n                        'dy': defaultDy,\n                        'y': temporalHeight || 0\n                    })\n                    .style('fill', nameTextFillColor)\n                    .style('font-size', textSize)\n                    .text(name);\n\n                temporalHeight = lineHeight + temporalHeight;\n            }\n\n            if (value) {\n                tooltipValue = tooltipTextContainer\n                  .append('text')\n                    .classed('mini-tooltip-value', true)\n                    .attr({\n                        'dy': defaultDy,\n                        'y': temporalHeight || 0\n                    })\n                    .style('fill', valueTextFillColor)\n                    .style('font-size', valueTextSize)\n                    .style('font-weight', valueTextWeight)\n                    .text(tooltipValueFormat(value));\n\n                temporalHeight = valueLineHeight + temporalHeight;\n            }\n\n            chartWidth = getMaxLengthLine(tooltipName, tooltipTitle, tooltipValue);\n            chartHeight = temporalHeight;\n        }\n\n        /**\n         * Updates size and position of tooltip depending on the side of the chart we are in\n         * @param  {Object} dataPoint DataPoint of the tooltip\n         * @return void\n         */\n        function updatePositionAndSize(mousePosition, parentChartSize) {\n            let [tooltipX, tooltipY] = getTooltipPosition(mousePosition, parentChartSize);\n            let newSize = {\n                width: chartWidth + margin.left + margin.right,\n                height: chartHeight + margin.top + margin.bottom\n            };\n\n            svg.transition()\n                .duration(mouseChaseDuration)\n                .ease(ease)\n                .attr(newSize)\n                .attr('transform', `translate(${tooltipX},${tooltipY})`);\n\n            tooltipBackground\n                .transition()\n                .ease(ease)\n                .attr(newSize);\n        }\n\n        /**\n         * Updates tooltip content, size and position\n         *\n         * @param  {Object} dataPoint Current datapoint to show info about\n         * @return void\n         */\n        function updateTooltip(dataPoint, position, chartSize) {\n            updateContent(dataPoint);\n            updatePositionAndSize(position, chartSize);\n        }\n\n        /**\n         * Hides the tooltip\n         * @return {Module} Tooltip module to chain calls\n         * @public\n         */\n        exports.hide = function() {\n            hideTooltip();\n\n            return this;\n        };\n\n        /**\n         * Shows the tooltip\n         * @return {Module} Tooltip module to chain calls\n         * @public\n         */\n        exports.show = function() {\n            showTooltip();\n\n            return this;\n        };\n\n        /**\n         * Gets or Sets the title of the tooltip\n         * @param  {string} _x Desired title\n         * @return { string | module} Current title or module to chain calls\n         * @public\n         */\n        exports.title = function(_x) {\n            if (!arguments.length) {\n                return title;\n            }\n            title = _x;\n            return this;\n        };\n\n        /**\n         * Updates the position and content of the tooltip\n         * @param  {Object} dataPoint       Datapoint of the hovered element\n         * @param  {Array} mousePosition    Mouse position relative to the parent chart [x, y]\n         * @param  {Array} chartSize        Parent chart size [x, y]\n         * @return {module}                 Current component\n         */\n        exports.update = function(dataPoint, mousePosition, chartSize) {\n            updateTooltip(dataPoint, mousePosition, chartSize);\n\n            return this;\n        };\n\n        return exports;\n    };\n});\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/charts/mini-tooltip.js\n **/","module.exports = __WEBPACK_EXTERNAL_MODULE_1__;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** external \"d3\"\n ** module id = 1\n ** module chunks = 0 1 2 3 4 5 6 7 8 9\n **/"],"sourceRoot":""}