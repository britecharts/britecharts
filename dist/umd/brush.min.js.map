{"version":3,"sources":["webpack:///webpack/universalModuleDefinition?5ca6","webpack:///brush.min.js","webpack:///webpack/bootstrap 55e57523fbdb728288bc?177e","webpack:///./src/charts/brush.js","webpack:///external \"d3\"?c0c4"],"names":["root","factory","exports","module","require","define","amd","a","i","this","__WEBPACK_EXTERNAL_MODULE_1__","modules","__webpack_require__","moduleId","installedModules","id","loaded","call","m","c","p","__WEBPACK_AMD_DEFINE_RESULT__","d3","_selection","each","_data","chartWidth","width","margin","left","right","chartHeight","height","top","bottom","data","cleanData","cloneData","buildScales","buildAxis","buildSVG","buildGradient","buildBrush","drawArea","drawAxis","drawBrush","setBrush","xAxis","svg","axis","scale","xScale","orient","tickFormat","xTickMonthFormat","brush","x","on","handleBrush","buildContainerGroups","container","append","classed","attr","metadataGroup","select","length","date","selectAll","offset","color","gradientColorSchema","enter","_ref3","_ref4","time","domain","extent","getDate","range","yScale","linear","max","getValue","transition","ease","parseDate","format","defaultTimeFormat","parse","map","d","dateLabel","value","valueLabel","dataToClone","JSON","stringify","area","_ref5","y0","y1","_ref6","interpolate","datum","chartBrush","brushExtent","event","target","onBrush","b","x0","invert","x1","duration","setBrushTransitionDuration","delay","setBrushTransitionDelay","_ref","_ref2","_x","arguments","undefined"],"mappings":"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","file":"brush.min.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(require(\"d3\"));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([\"d3\"], factory);\n\telse {\n\t\tvar a = typeof exports === 'object' ? factory(require(\"d3\")) : factory(root[\"d3\"]);\n\t\tfor(var i in a) (typeof exports === 'object' ? exports : root)[i] = a[i];\n\t}\n})(this, function(__WEBPACK_EXTERNAL_MODULE_1__) {\nreturn \n\n\n/** WEBPACK FOOTER **\n ** webpack/universalModuleDefinition\n **/","(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(require(\"d3\"));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([\"d3\"], factory);\n\telse {\n\t\tvar a = typeof exports === 'object' ? factory(require(\"d3\")) : factory(root[\"d3\"]);\n\t\tfor(var i in a) (typeof exports === 'object' ? exports : root)[i] = a[i];\n\t}\n})(this, function(__WEBPACK_EXTERNAL_MODULE_1__) {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_RESULT__;'use strict';\n\t\n\t!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {\n\t    'use strict';\n\t\n\t    var d3 = __webpack_require__(1);\n\t\n\t    /**\n\t     * @typedef BrushChartData\n\t     * @type {Object[]}\n\t     * @property {Number} value        Value to chart (required)\n\t     * @property {Date} date           Date of the value (required)\n\t     *\n\t     * @example\n\t     * [\n\t     *     {\n\t     *         value: 1,\n\t     *         date: '2011-01-06T00:00:00Z'\n\t     *     },\n\t     *     {\n\t     *         value: 2,\n\t     *         date: '2011-01-07T00:00:00Z'\n\t     *     }\n\t     * ]\n\t     */\n\t\n\t    /**\n\t     * Brush Chart reusable API class that renders a\n\t     * simple and configurable brush chart.\n\t     *\n\t     * @module Brush\n\t     * @version 0.0.1\n\t     * @tutorial brush\n\t     * @requires d3\n\t     *\n\t     * @example\n\t     * let brushChart = brush();\n\t     *\n\t     * brushChart\n\t     *     .height(500)\n\t     *     .width(800);\n\t     *\n\t     * d3.select('.css-selector')\n\t     *     .datum(dataset)\n\t     *     .call(brushChart);\n\t     *\n\t     */\n\t    return function module() {\n\t\n\t        var margin = { top: 20, right: 20, bottom: 40, left: 20 },\n\t            width = 960,\n\t            height = 500,\n\t            data = void 0,\n\t            svg = void 0,\n\t            ease = 'quad-out',\n\t            dateLabel = 'date',\n\t            valueLabel = 'value',\n\t            chartWidth = void 0,\n\t            chartHeight = void 0,\n\t            xScale = void 0,\n\t            yScale = void 0,\n\t            xAxis = void 0,\n\t            xAxisPadding = {\n\t            top: 0,\n\t            left: 0,\n\t            bottom: 0,\n\t            right: 0\n\t        },\n\t            brush = void 0,\n\t            chartBrush = void 0,\n\t            onBrush = null,\n\t            setBrushTransitionDuration = 500,\n\t            setBrushTransitionDelay = 1000,\n\t            gradientColorSchema = {\n\t            left: '#39C7EA',\n\t            right: '#4CDCBA'\n\t        },\n\t\n\t\n\t        // formats\n\t        defaultTimeFormat = '%m/%d/%Y',\n\t            xTickMonthFormat = d3.time.format('%b'),\n\t\n\t\n\t        // extractors\n\t        getValue = function getValue(_ref) {\n\t            var value = _ref.value;\n\t            return value;\n\t        },\n\t            getDate = function getDate(_ref2) {\n\t            var date = _ref2.date;\n\t            return date;\n\t        };\n\t\n\t        /**\n\t         * This function creates the graph using the selection as container\n\t         * @param  {D3Selection} _selection A d3 selection that represents\n\t         *                                  the container(s) where the chart(s) will be rendered\n\t         * @param {BrushChartData} _data The data to attach and generate the chart\n\t         */\n\t        function exports(_selection) {\n\t            _selection.each(function (_data) {\n\t                chartWidth = width - margin.left - margin.right;\n\t                chartHeight = height - margin.top - margin.bottom;\n\t                data = cleanData(cloneData(_data));\n\t\n\t                buildScales();\n\t                buildAxis();\n\t                buildSVG(this);\n\t                buildGradient();\n\t                buildBrush();\n\t                drawArea();\n\t                drawAxis();\n\t                drawBrush();\n\t\n\t                // This last step is optional, just needed when\n\t                // a given selection would need to be shown\n\t                setBrush(0, 0.5);\n\t            });\n\t        }\n\t\n\t        /**\n\t         * Creates the d3 x axis, setting orientation\n\t         * @private\n\t         */\n\t        function buildAxis() {\n\t            xAxis = d3.svg.axis().scale(xScale).orient('bottom').tickFormat(xTickMonthFormat);\n\t        }\n\t\n\t        /**\n\t         * Creates the brush element and attaches a listener\n\t         * @return {void}\n\t         */\n\t        function buildBrush() {\n\t            brush = d3.svg.brush().x(xScale).on('brush', handleBrush);\n\t        }\n\t\n\t        /**\n\t         * Builds containers for the chart, the axis and a wrapper for all of them\n\t         * Also applies the Margin convention\n\t         * @private\n\t         */\n\t        function buildContainerGroups() {\n\t            var container = svg.append('g').classed('container-group', true).attr('transform', 'translate(' + margin.left + ', ' + margin.top + ')');\n\t\n\t            container.append('g').classed('chart-group', true);\n\t            container.append('g').classed('metadata-group', true);\n\t            container.append('g').classed('x-axis-group', true);\n\t            container.append('g').classed('brush-group', true);\n\t        }\n\t\n\t        /**\n\t         * Creates the gradient on the area\n\t         * @return {void}\n\t         */\n\t        function buildGradient() {\n\t            var metadataGroup = svg.select('.metadata-group');\n\t\n\t            metadataGroup.append('linearGradient').attr('id', 'brush-area-gradient').attr('gradientUnits', 'userSpaceOnUse').attr('x1', 0).attr('x2', xScale(data[data.length - 1].date)).attr('y1', 0).attr('y2', 0).selectAll('stop').data([{ offset: '0%', color: gradientColorSchema.left }, { offset: '100%', color: gradientColorSchema.right }]).enter().append('stop').attr('offset', function (_ref3) {\n\t                var offset = _ref3.offset;\n\t                return offset;\n\t            }).attr('stop-color', function (_ref4) {\n\t                var color = _ref4.color;\n\t                return color;\n\t            });\n\t        }\n\t\n\t        /**\n\t         * Creates the x and y scales of the graph\n\t         * @private\n\t         */\n\t        function buildScales() {\n\t            xScale = d3.time.scale().domain(d3.extent(data, getDate)).range([0, chartWidth]);\n\t\n\t            yScale = d3.scale.linear().domain([0, d3.max(data, getValue)]).range([chartHeight, 0]);\n\t        }\n\t\n\t        /**\n\t         * Builds the SVG element that will contain the chart\n\t         * @param  {HTMLElement} container DOM element that will work as the container of the graph\n\t         * @private\n\t         */\n\t        function buildSVG(container) {\n\t            if (!svg) {\n\t                svg = d3.select(container).append('svg').classed('britechart brush-chart', true);\n\t\n\t                buildContainerGroups();\n\t            }\n\t\n\t            svg.transition().ease(ease).attr({\n\t                width: width,\n\t                height: height\n\t            });\n\t        }\n\t\n\t        /**\n\t         * Cleaning data adding the proper format\n\t         *\n\t         * @param  {BrushChartData} data Data\n\t         */\n\t        function cleanData(data) {\n\t            var parseDate = d3.time.format(defaultTimeFormat).parse;\n\t\n\t            return data.map(function (d) {\n\t                d.date = parseDate(d[dateLabel]);\n\t                d.value = +d[valueLabel];\n\t\n\t                return d;\n\t            });\n\t        }\n\t\n\t        /**\n\t         * Clones the passed array of data\n\t         * @param  {Object[]} dataToClone Data to clone\n\t         * @return {Object[]}             Cloned data\n\t         */\n\t        function cloneData(dataToClone) {\n\t            return JSON.parse(JSON.stringify(dataToClone));\n\t        }\n\t\n\t        /**\n\t         * Draws the x axis on the svg object within its group\n\t         *\n\t         * @private\n\t         */\n\t        function drawAxis() {\n\t            svg.select('.x-axis-group').append('g').attr('class', 'x axis').attr('transform', 'translate(0, ' + chartHeight + ')').call(xAxis);\n\t        }\n\t\n\t        /**\n\t         * Draws the area that is going to represent the data\n\t         *\n\t         * @return {void}\n\t         */\n\t        function drawArea() {\n\t            // Create and configure the area generator\n\t            var area = d3.svg.area().x(function (_ref5) {\n\t                var date = _ref5.date;\n\t                return xScale(date);\n\t            }).y0(chartHeight).y1(function (_ref6) {\n\t                var value = _ref6.value;\n\t                return yScale(value);\n\t            }).interpolate('basis');\n\t\n\t            // Create the area path\n\t            svg.select('.chart-group').append('path').datum(data).attr('class', 'brush-area').attr('d', area);\n\t        }\n\t\n\t        /**\n\t         * Draws the Brush components on its group\n\t         * @return {void}\n\t         */\n\t        function drawBrush() {\n\t            chartBrush = svg.select('.brush-group').call(brush);\n\t\n\t            // Update the height of the brushing rectangle\n\t            chartBrush.selectAll('rect').classed('brush-rect', true).attr('height', chartHeight);\n\t        }\n\t\n\t        /**\n\t         * When a brush event happens, we can extract info from the extension\n\t         * of the brush.\n\t         *\n\t         * @return {void}\n\t         */\n\t        function handleBrush() {\n\t            var brushExtent = d3.event.target.extent();\n\t\n\t            if (typeof onBrush === 'function') {\n\t                onBrush.call(null, brushExtent);\n\t            }\n\t        }\n\t\n\t        /**\n\t         * Sets a new brush extent within the passed percentage positions\n\t         * @param {Number} a Percentage of data that the brush start with\n\t         * @param {Number} b Percentage of data that the brush ends with\n\t         */\n\t        function setBrush(a, b) {\n\t            var x0 = xScale.invert(a * chartWidth),\n\t                x1 = xScale.invert(b * chartWidth);\n\t\n\t            brush.extent([x0, x1]);\n\t\n\t            // now draw the brush to match our extent\n\t            brush(d3.select('.brush-group').transition().duration(setBrushTransitionDuration));\n\t\n\t            // now fire the brushstart, brushmove, and brushend events\n\t            // set transition the delay and duration to 0 to draw right away\n\t            brush.event(d3.select('.brush-group').transition().delay(setBrushTransitionDelay).duration(setBrushTransitionDuration));\n\t        }\n\t\n\t        /**\n\t         * Gets or Sets the height of the chart\n\t         * @param  {number} _x Desired width for the graph\n\t         * @return { height | module} Current height or Chart module to chain calls\n\t         * @public\n\t         */\n\t        exports.height = function (_x) {\n\t            if (!arguments.length) {\n\t                return height;\n\t            }\n\t            height = _x;\n\t            return this;\n\t        };\n\t\n\t        /**\n\t         * Gets or Sets the margin of the chart\n\t         * @param  {object} _x Margin object to get/set\n\t         * @return { margin | module} Current margin or Chart module to chain calls\n\t         * @public\n\t         */\n\t        exports.margin = function (_x) {\n\t            if (!arguments.length) {\n\t                return margin;\n\t            }\n\t            margin = _x;\n\t            return this;\n\t        };\n\t\n\t        /**\n\t         * Gets or Sets the callback that will be called when the user brushes over the area\n\t         * @param  {Function} _x Callback to call\n\t         * @return {Function | module}    Current callback function or the Chart Module\n\t         */\n\t        exports.onBrush = function (_x) {\n\t            if (!arguments.length) return onBrush;\n\t            onBrush = _x;\n\t\n\t            return this;\n\t        };\n\t\n\t        /**\n\t         * Gets or Sets the width of the chart\n\t         * @param  {number} _x Desired width for the graph\n\t         * @return { width | module} Current width or Chart module to chain calls\n\t         * @public\n\t         */\n\t        exports.width = function (_x) {\n\t            if (!arguments.length) {\n\t                return width;\n\t            }\n\t            width = _x;\n\t            return this;\n\t        };\n\t        return exports;\n\t    };\n\t}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n/***/ },\n/* 1 */\n/***/ function(module, exports) {\n\n\tmodule.exports = __WEBPACK_EXTERNAL_MODULE_1__;\n\n/***/ }\n/******/ ])\n});\n;\n\n\n/** WEBPACK FOOTER **\n ** brush.min.js\n **/"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n/** WEBPACK FOOTER **\n ** webpack/bootstrap 55e57523fbdb728288bc\n **/","define(function(require) {\n    'use strict';\n\n    const d3 = require('d3');\n\n\n    /**\n     * @typedef BrushChartData\n     * @type {Object[]}\n     * @property {Number} value        Value to chart (required)\n     * @property {Date} date           Date of the value (required)\n     *\n     * @example\n     * [\n     *     {\n     *         value: 1,\n     *         date: '2011-01-06T00:00:00Z'\n     *     },\n     *     {\n     *         value: 2,\n     *         date: '2011-01-07T00:00:00Z'\n     *     }\n     * ]\n     */\n\n    /**\n     * Brush Chart reusable API class that renders a\n     * simple and configurable brush chart.\n     *\n     * @module Brush\n     * @version 0.0.1\n     * @tutorial brush\n     * @requires d3\n     *\n     * @example\n     * let brushChart = brush();\n     *\n     * brushChart\n     *     .height(500)\n     *     .width(800);\n     *\n     * d3.select('.css-selector')\n     *     .datum(dataset)\n     *     .call(brushChart);\n     *\n     */\n    return function module() {\n\n        let margin = {top: 20, right: 20, bottom: 40, left: 20},\n            width = 960,\n            height = 500,\n            data,\n            svg,\n\n            ease = 'quad-out',\n\n            dateLabel = 'date',\n            valueLabel = 'value',\n\n            chartWidth, chartHeight,\n            xScale, yScale,\n            xAxis,\n\n            xAxisPadding = {\n                top: 0,\n                left: 0,\n                bottom: 0,\n                right: 0\n            },\n\n            brush,\n            chartBrush,\n\n            onBrush = null,\n\n            setBrushTransitionDuration = 500,\n            setBrushTransitionDelay = 1000,\n\n            gradientColorSchema = {\n                left: '#39C7EA',\n                right: '#4CDCBA'\n            },\n\n            // formats\n            defaultTimeFormat = '%m/%d/%Y',\n            xTickMonthFormat = d3.time.format('%b'),\n\n            // extractors\n            getValue = ({value}) => value,\n            getDate = ({date}) => date;\n\n\n        /**\n         * This function creates the graph using the selection as container\n         * @param  {D3Selection} _selection A d3 selection that represents\n         *                                  the container(s) where the chart(s) will be rendered\n         * @param {BrushChartData} _data The data to attach and generate the chart\n         */\n        function exports(_selection){\n            _selection.each(function(_data){\n                chartWidth = width - margin.left - margin.right;\n                chartHeight = height - margin.top - margin.bottom;\n                data = cleanData(cloneData(_data));\n\n                buildScales();\n                buildAxis();\n                buildSVG(this);\n                buildGradient();\n                buildBrush();\n                drawArea();\n                drawAxis();\n                drawBrush();\n\n                // This last step is optional, just needed when\n                // a given selection would need to be shown\n                setBrush(0, 0.5);\n            });\n        }\n\n        /**\n         * Creates the d3 x axis, setting orientation\n         * @private\n         */\n        function buildAxis(){\n            xAxis = d3.svg.axis()\n                .scale(xScale)\n                .orient('bottom')\n                .tickFormat(xTickMonthFormat);\n        }\n\n        /**\n         * Creates the brush element and attaches a listener\n         * @return {void}\n         */\n        function buildBrush() {\n            brush = d3.svg.brush()\n                .x(xScale)\n                .on('brush', handleBrush);\n        }\n\n        /**\n         * Builds containers for the chart, the axis and a wrapper for all of them\n         * Also applies the Margin convention\n         * @private\n         */\n        function buildContainerGroups(){\n            let container = svg.append('g')\n                .classed('container-group', true)\n                .attr('transform', `translate(${margin.left}, ${margin.top})`);\n\n            container\n              .append('g')\n                .classed('chart-group', true);\n            container\n              .append('g')\n                .classed('metadata-group', true);\n            container\n              .append('g')\n                .classed('x-axis-group', true);\n            container\n              .append('g')\n                .classed('brush-group', true);\n        }\n\n        /**\n         * Creates the gradient on the area\n         * @return {void}\n         */\n        function buildGradient() {\n            let metadataGroup = svg.select('.metadata-group');\n\n            metadataGroup.append('linearGradient')\n                .attr('id', 'brush-area-gradient')\n                .attr('gradientUnits', 'userSpaceOnUse')\n                .attr('x1', 0)\n                .attr('x2', xScale(data[data.length - 1].date))\n                .attr('y1', 0)\n                .attr('y2', 0)\n              .selectAll('stop')\n                .data([\n                    {offset: '0%', color: gradientColorSchema.left},\n                    {offset: '100%', color: gradientColorSchema.right}\n                ])\n              .enter().append('stop')\n                .attr('offset', ({offset}) => offset)\n                .attr('stop-color', ({color}) => color);\n        }\n\n        /**\n         * Creates the x and y scales of the graph\n         * @private\n         */\n        function buildScales(){\n            xScale = d3.time.scale()\n                .domain(d3.extent(data, getDate ))\n                .range([0, chartWidth]);\n\n            yScale = d3.scale.linear()\n                .domain([0, d3.max(data, getValue)])\n                .range([chartHeight, 0]);\n        }\n\n        /**\n         * Builds the SVG element that will contain the chart\n         * @param  {HTMLElement} container DOM element that will work as the container of the graph\n         * @private\n         */\n        function buildSVG(container){\n            if (!svg) {\n                svg = d3.select(container)\n                    .append('svg')\n                    .classed('britechart brush-chart', true);\n\n                buildContainerGroups();\n            }\n\n            svg\n                .transition()\n                .ease(ease)\n                .attr({\n                    width: width,\n                    height: height\n                });\n        }\n\n        /**\n         * Cleaning data adding the proper format\n         *\n         * @param  {BrushChartData} data Data\n         */\n        function cleanData(data) {\n            let parseDate = d3.time.format(defaultTimeFormat).parse;\n\n            return data.map(function (d) {\n                d.date = parseDate(d[dateLabel]);\n                d.value = +d[valueLabel];\n\n                return d;\n            });\n        }\n\n        /**\n         * Clones the passed array of data\n         * @param  {Object[]} dataToClone Data to clone\n         * @return {Object[]}             Cloned data\n         */\n        function cloneData(dataToClone) {\n            return JSON.parse(JSON.stringify(dataToClone));\n        }\n\n        /**\n         * Draws the x axis on the svg object within its group\n         *\n         * @private\n         */\n        function drawAxis(){\n            svg.select('.x-axis-group')\n              .append('g')\n                .attr('class', 'x axis')\n                .attr('transform', `translate(0, ${chartHeight})`)\n                .call(xAxis);\n        }\n\n        /**\n         * Draws the area that is going to represent the data\n         *\n         * @return {void}\n         */\n        function drawArea() {\n            // Create and configure the area generator\n            let area = d3.svg.area()\n                .x(({date}) => xScale(date))\n                .y0(chartHeight)\n                .y1(({value}) => yScale(value))\n                .interpolate('basis');\n\n            // Create the area path\n            svg.select('.chart-group')\n              .append('path')\n                .datum(data)\n                .attr('class', 'brush-area')\n                .attr('d', area);\n        }\n\n        /**\n         * Draws the Brush components on its group\n         * @return {void}\n         */\n        function drawBrush() {\n            chartBrush = svg.select('.brush-group')\n                                .call(brush);\n\n            // Update the height of the brushing rectangle\n            chartBrush.selectAll('rect')\n                .classed('brush-rect', true)\n                .attr('height', chartHeight);\n        }\n\n        /**\n         * When a brush event happens, we can extract info from the extension\n         * of the brush.\n         *\n         * @return {void}\n         */\n        function handleBrush() {\n            let brushExtent = d3.event.target.extent();\n\n            if (typeof onBrush === 'function') {\n                onBrush.call(null, brushExtent);\n            }\n        }\n\n        /**\n         * Sets a new brush extent within the passed percentage positions\n         * @param {Number} a Percentage of data that the brush start with\n         * @param {Number} b Percentage of data that the brush ends with\n         */\n        function setBrush(a, b) {\n            let x0 = xScale.invert(a * chartWidth),\n                x1 = xScale.invert(b * chartWidth);\n\n            brush.extent([x0, x1]);\n\n            // now draw the brush to match our extent\n            brush(d3.select('.brush-group').transition().duration(setBrushTransitionDuration));\n\n            // now fire the brushstart, brushmove, and brushend events\n            // set transition the delay and duration to 0 to draw right away\n            brush.event(d3.select('.brush-group').transition().delay(setBrushTransitionDelay).duration(setBrushTransitionDuration));\n        }\n\n\n        /**\n         * Gets or Sets the height of the chart\n         * @param  {number} _x Desired width for the graph\n         * @return { height | module} Current height or Chart module to chain calls\n         * @public\n         */\n        exports.height = function(_x) {\n            if (!arguments.length) {\n                return height;\n            }\n            height = _x;\n            return this;\n        };\n\n        /**\n         * Gets or Sets the margin of the chart\n         * @param  {object} _x Margin object to get/set\n         * @return { margin | module} Current margin or Chart module to chain calls\n         * @public\n         */\n        exports.margin = function(_x) {\n            if (!arguments.length) {\n                return margin;\n            }\n            margin = _x;\n            return this;\n        };\n\n        /**\n         * Gets or Sets the callback that will be called when the user brushes over the area\n         * @param  {Function} _x Callback to call\n         * @return {Function | module}    Current callback function or the Chart Module\n         */\n        exports.onBrush = function(_x) {\n            if (!arguments.length) return onBrush;\n            onBrush = _x;\n\n            return this;\n        };\n\n        /**\n         * Gets or Sets the width of the chart\n         * @param  {number} _x Desired width for the graph\n         * @return { width | module} Current width or Chart module to chain calls\n         * @public\n         */\n        exports.width = function(_x) {\n            if (!arguments.length) {\n                return width;\n            }\n            width = _x;\n            return this;\n        };\n        return exports;\n    };\n\n});\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/charts/brush.js\n **/","module.exports = __WEBPACK_EXTERNAL_MODULE_1__;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** external \"d3\"\n ** module id = 1\n ** module chunks = 0 1 2 3 4 5 6 7 8\n **/"],"sourceRoot":""}