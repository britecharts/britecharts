{"version":3,"sources":["webpack:///webpack/universalModuleDefinition?5ca6","webpack:///brush.min.js","webpack:///webpack/bootstrap 41fa8f3a161ab8c2999f?0d98","webpack:///./src/charts/brush.js","webpack:///external \"d3\"?c0c4","webpack:///./src/charts/helpers/colors.js?2682"],"names":["root","factory","exports","module","require","define","amd","a","i","this","__WEBPACK_EXTERNAL_MODULE_1__","modules","__webpack_require__","moduleId","installedModules","id","loaded","call","m","c","p","__WEBPACK_AMD_DEFINE_RESULT__","d3","colorHelper","_selection","each","_data","chartWidth","width","margin","left","right","chartHeight","height","top","bottom","data","cleanData","cloneData","buildScales","buildAxis","buildSVG","buildGradient","buildBrush","drawArea","drawAxis","drawBrush","drawHandles","setBrush","xAxis","axisBottom","xScale","tickFormat","xTickMonthFormat","brush","brushX","extent","on","handleBrush","handleBrushEnded","buildContainerGroups","container","svg","append","classed","attr","metadataGroup","select","length","date","selectAll","offset","color","gradient","enter","_ref3","_ref4","scaleTime","domain","getDate","range","yScale","scaleLinear","max","getValue","transition","ease","parseDate","timeParse","defaultTimeFormat","map","d","dateLabel","value","valueLabel","dataToClone","JSON","parse","stringify","area","x","_ref5","y0","y1","_ref6","curve","curveBasis","datum","chartBrush","handleFillColor","colorSchemasHuman","britechartsGreySchema","handle","style","s","event","selection","dateExtent","invert","onBrush","sourceEvent","d0","d1","timeDay","round","floor","target","move","b","x0","x1","easeQuadOut","colorGradients","greenBlueGradient","timeFormat","_ref","_ref2","_x","arguments","undefined","britechartGradients","orangePinkGradient","bluePurpleGradient","britechartsColorSchema","extendedOrangeColorSchema","extendedBlueColorSchema","extendedLightBlueColorSchema","extendedGreenColorSchema","extendedYellowColorSchema","extendedPinkColorSchema","extendedPurpleColorSchema","extendedRedColorSchema","colorSchemas","colorGradientsHuman"],"mappings":"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","file":"brush.min.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(require(\"d3\"));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([\"d3\"], factory);\n\telse {\n\t\tvar a = typeof exports === 'object' ? factory(require(\"d3\")) : factory(root[\"d3\"]);\n\t\tfor(var i in a) (typeof exports === 'object' ? exports : root)[i] = a[i];\n\t}\n})(this, function(__WEBPACK_EXTERNAL_MODULE_1__) {\nreturn \n\n\n// WEBPACK FOOTER //\n// webpack/universalModuleDefinition","(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(require(\"d3\"));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([\"d3\"], factory);\n\telse {\n\t\tvar a = typeof exports === 'object' ? factory(require(\"d3\")) : factory(root[\"d3\"]);\n\t\tfor(var i in a) (typeof exports === 'object' ? exports : root)[i] = a[i];\n\t}\n})(this, function(__WEBPACK_EXTERNAL_MODULE_1__) {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_RESULT__;'use strict';\n\t\n\t!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {\n\t    'use strict';\n\t\n\t    var d3 = __webpack_require__(1);\n\t\n\t    var colorHelper = __webpack_require__(5);\n\t\n\t    /**\n\t     * @typedef BrushChartData\n\t     * @type {Object[]}\n\t     * @property {Number} value        Value to chart (required)\n\t     * @property {Date} date           Date of the value (required)\n\t     *\n\t     * @example\n\t     * [\n\t     *     {\n\t     *         value: 1,\n\t     *         date: '2011-01-06T00:00:00Z'\n\t     *     },\n\t     *     {\n\t     *         value: 2,\n\t     *         date: '2011-01-07T00:00:00Z'\n\t     *     }\n\t     * ]\n\t     */\n\t\n\t    /**\n\t     * Brush Chart reusable API class that renders a\n\t     * simple and configurable brush chart.\n\t     *\n\t     * @module Brush\n\t     * @version 0.0.1\n\t     * @tutorial brush\n\t     * @requires d3\n\t     *\n\t     * @example\n\t     * let brushChart = brush();\n\t     *\n\t     * brushChart\n\t     *     .height(500)\n\t     *     .width(800);\n\t     *\n\t     * d3.select('.css-selector')\n\t     *     .datum(dataset)\n\t     *     .call(brushChart);\n\t     *\n\t     */\n\t    return function module() {\n\t\n\t        var margin = { top: 20, right: 20, bottom: 40, left: 20 },\n\t            width = 960,\n\t            height = 500,\n\t            data = void 0,\n\t            svg = void 0,\n\t            ease = d3.easeQuadOut,\n\t            dateLabel = 'date',\n\t            valueLabel = 'value',\n\t            chartWidth = void 0,\n\t            chartHeight = void 0,\n\t            xScale = void 0,\n\t            yScale = void 0,\n\t            xAxis = void 0,\n\t            xAxisPadding = {\n\t            top: 0,\n\t            left: 0,\n\t            bottom: 0,\n\t            right: 0\n\t        },\n\t            brush = void 0,\n\t            chartBrush = void 0,\n\t            handle = void 0,\n\t            onBrush = null,\n\t            gradient = colorHelper.colorGradients.greenBlueGradient,\n\t\n\t\n\t        // formats\n\t        defaultTimeFormat = '%m/%d/%Y',\n\t            xTickMonthFormat = d3.timeFormat('%b'),\n\t\n\t\n\t        // extractors\n\t        getValue = function getValue(_ref) {\n\t            var value = _ref.value;\n\t            return value;\n\t        },\n\t            getDate = function getDate(_ref2) {\n\t            var date = _ref2.date;\n\t            return date;\n\t        };\n\t\n\t        /**\n\t         * This function creates the graph using the selection as container\n\t         * @param  {D3Selection} _selection A d3 selection that represents\n\t         *                                  the container(s) where the chart(s) will be rendered\n\t         * @param {BrushChartData} _data The data to attach and generate the chart\n\t         */\n\t        function exports(_selection) {\n\t            _selection.each(function (_data) {\n\t                chartWidth = width - margin.left - margin.right;\n\t                chartHeight = height - margin.top - margin.bottom;\n\t                data = cleanData(cloneData(_data));\n\t\n\t                buildScales();\n\t                buildAxis();\n\t                buildSVG(this);\n\t                buildGradient();\n\t                buildBrush();\n\t                drawArea();\n\t                drawAxis();\n\t                drawBrush();\n\t                drawHandles();\n\t\n\t                // This last step is optional, just needed when\n\t                // a given selection would need to be shown\n\t                setBrush(0.25, 0.5);\n\t            });\n\t        }\n\t\n\t        /**\n\t         * Creates the d3 x axis, setting orientation\n\t         * @private\n\t         */\n\t        function buildAxis() {\n\t            xAxis = d3.axisBottom(xScale).tickFormat(xTickMonthFormat);\n\t        }\n\t\n\t        /**\n\t         * Creates the brush element and attaches a listener\n\t         * @return {void}\n\t         */\n\t        function buildBrush() {\n\t            brush = d3.brushX().extent([[0, 0], [chartWidth, chartHeight]]).on('brush', handleBrush).on('end', handleBrushEnded);\n\t        }\n\t\n\t        /**\n\t         * Builds containers for the chart, the axis and a wrapper for all of them\n\t         * Also applies the Margin convention\n\t         * @private\n\t         */\n\t        function buildContainerGroups() {\n\t            var container = svg.append('g').classed('container-group', true).attr('transform', 'translate(' + margin.left + ', ' + margin.top + ')');\n\t\n\t            container.append('g').classed('chart-group', true);\n\t            container.append('g').classed('metadata-group', true);\n\t            container.append('g').classed('x-axis-group', true);\n\t            container.append('g').classed('brush-group', true);\n\t        }\n\t\n\t        /**\n\t         * Creates the gradient on the area\n\t         * @return {void}\n\t         */\n\t        function buildGradient() {\n\t            var metadataGroup = svg.select('.metadata-group');\n\t\n\t            metadataGroup.append('linearGradient').attr('id', 'brush-area-gradient').attr('gradientUnits', 'userSpaceOnUse').attr('x1', 0).attr('x2', xScale(data[data.length - 1].date)).attr('y1', 0).attr('y2', 0).selectAll('stop').data([{ offset: '0%', color: gradient[0] }, { offset: '100%', color: gradient[1] }]).enter().append('stop').attr('offset', function (_ref3) {\n\t                var offset = _ref3.offset;\n\t                return offset;\n\t            }).attr('stop-color', function (_ref4) {\n\t                var color = _ref4.color;\n\t                return color;\n\t            });\n\t        }\n\t\n\t        /**\n\t         * Creates the x and y scales of the graph\n\t         * @private\n\t         */\n\t        function buildScales() {\n\t            xScale = d3.scaleTime().domain(d3.extent(data, getDate)).range([0, chartWidth]);\n\t\n\t            yScale = d3.scaleLinear().domain([0, d3.max(data, getValue)]).range([chartHeight, 0]);\n\t        }\n\t\n\t        /**\n\t         * Builds the SVG element that will contain the chart\n\t         * @param  {HTMLElement} container DOM element that will work as the container of the graph\n\t         * @private\n\t         */\n\t        function buildSVG(container) {\n\t            if (!svg) {\n\t                svg = d3.select(container).append('svg').classed('britechart brush-chart', true);\n\t\n\t                buildContainerGroups();\n\t            }\n\t\n\t            svg.transition().ease(ease).attr('width', width).attr('height', height);\n\t        }\n\t\n\t        /**\n\t         * Cleaning data adding the proper format\n\t         *\n\t         * @param  {BrushChartData} data Data\n\t         */\n\t        function cleanData(data) {\n\t            var parseDate = d3.timeParse(defaultTimeFormat);\n\t\n\t            return data.map(function (d) {\n\t                d.date = parseDate(d[dateLabel]);\n\t                d.value = +d[valueLabel];\n\t\n\t                return d;\n\t            });\n\t        }\n\t\n\t        /**\n\t         * Clones the passed array of data\n\t         * @param  {Object[]} dataToClone Data to clone\n\t         * @return {Object[]}             Cloned data\n\t         */\n\t        function cloneData(dataToClone) {\n\t            return JSON.parse(JSON.stringify(dataToClone));\n\t        }\n\t\n\t        /**\n\t         * Draws the x axis on the svg object within its group\n\t         *\n\t         * @private\n\t         */\n\t        function drawAxis() {\n\t            svg.select('.x-axis-group').append('g').attr('class', 'x axis').attr('transform', 'translate(0, ' + chartHeight + ')').call(xAxis);\n\t        }\n\t\n\t        /**\n\t         * Draws the area that is going to represent the data\n\t         *\n\t         * @return {void}\n\t         */\n\t        function drawArea() {\n\t            // Create and configure the area generator\n\t            var area = d3.area().x(function (_ref5) {\n\t                var date = _ref5.date;\n\t                return xScale(date);\n\t            }).y0(chartHeight).y1(function (_ref6) {\n\t                var value = _ref6.value;\n\t                return yScale(value);\n\t            }).curve(d3.curveBasis);\n\t\n\t            // Create the area path\n\t            svg.select('.chart-group').append('path').datum(data).attr('class', 'brush-area').attr('d', area);\n\t        }\n\t\n\t        /**\n\t         * Draws the Brush components on its group\n\t         * @return {void}\n\t         */\n\t        function drawBrush() {\n\t            chartBrush = svg.select('.brush-group').call(brush);\n\t\n\t            // Update the height of the brushing rectangle\n\t            chartBrush.selectAll('rect').classed('brush-rect', true).attr('height', chartHeight);\n\t        }\n\t\n\t        /**\n\t         * Draws a handle for the Brush section\n\t         * @return {void}\n\t         */\n\t        function drawHandles() {\n\t            var handleFillColor = colorHelper.colorSchemasHuman.britechartsGreySchema[1];\n\t\n\t            // Styling\n\t            handle = chartBrush.selectAll('.handle.brush-rect').style('fill', handleFillColor);\n\t        }\n\t\n\t        /**\n\t         * When a brush event happens, we can extract info from the extension\n\t         * of the brush.\n\t         *\n\t         * @return {void}\n\t         */\n\t        function handleBrush() {\n\t            var s = d3.event.selection,\n\t                dateExtent = s.map(xScale.invert);\n\t\n\t            if (typeof onBrush === 'function') {\n\t                onBrush.call(null, dateExtent);\n\t            }\n\t\n\t            // updateHandlers(dateExtent);\n\t        }\n\t\n\t        /**\n\t         * Processes the end brush event, snapping the boundaries to days\n\t         * as showed on the example on https://bl.ocks.org/mbostock/6232537\n\t         * @return {void}\n\t         * @private\n\t         */\n\t        function handleBrushEnded() {\n\t            if (!d3.event.sourceEvent) return; // Only transition after input.\n\t            if (!d3.event.selection) return; // Ignore empty selections.\n\t\n\t            var d0 = d3.event.selection.map(xScale.invert),\n\t                d1 = d0.map(d3.timeDay.round);\n\t\n\t            // If empty when rounded, use floor & ceil instead.\n\t            if (d1[0] >= d1[1]) {\n\t                d1[0] = d3.timeDay.floor(d0[0]);\n\t                d1[1] = d3.timeDay.offset(d1[0]);\n\t            }\n\t\n\t            d3.select(this).transition().call(d3.event.target.move, d1.map(xScale));\n\t        }\n\t\n\t        /**\n\t         * Sets a new brush extent within the passed percentage positions\n\t         * @param {Number} a Percentage of data that the brush start with\n\t         * @param {Number} b Percentage of data that the brush ends with\n\t         */\n\t        function setBrush(a, b) {\n\t            var x0 = a * chartWidth,\n\t                x1 = b * chartWidth;\n\t\n\t            brush.move(chartBrush, [x0, x1]);\n\t        }\n\t\n\t        /**\n\t         * Updates visibility and position of the brush handlers\n\t         * @param  {Number[]} dateExtent Date range\n\t         * @return {void}\n\t         */\n\t        function updateHandlers(dateExtent) {\n\t            if (dateExtent == null) {\n\t                handle.attr('display', 'none');\n\t            } else {\n\t                handle.attr('display', null).attr('transform', function (d, i) {\n\t                    return 'translate(' + dateExtent[i] + ',' + chartHeight / 2 + ')';\n\t                });\n\t            }\n\t        }\n\t\n\t        /**\n\t         * Gets or Sets the gradient of the chart\n\t         * @param  {String[]} _x Desired gradient for the graph\n\t         * @return { gradient | module} Current gradient or Chart module to chain calls\n\t         * @public\n\t         */\n\t        exports.gradient = function (_x) {\n\t            if (!arguments.length) {\n\t                return gradient;\n\t            }\n\t            gradient = _x;\n\t            return this;\n\t        };\n\t\n\t        /**\n\t         * Gets or Sets the height of the chart\n\t         * @param  {number} _x Desired width for the graph\n\t         * @return { height | module} Current height or Chart module to chain calls\n\t         * @public\n\t         */\n\t        exports.height = function (_x) {\n\t            if (!arguments.length) {\n\t                return height;\n\t            }\n\t            height = _x;\n\t            return this;\n\t        };\n\t\n\t        /**\n\t         * Gets or Sets the margin of the chart\n\t         * @param  {object} _x Margin object to get/set\n\t         * @return { margin | module} Current margin or Chart module to chain calls\n\t         * @public\n\t         */\n\t        exports.margin = function (_x) {\n\t            if (!arguments.length) {\n\t                return margin;\n\t            }\n\t            margin = _x;\n\t            return this;\n\t        };\n\t\n\t        /**\n\t         * Gets or Sets the callback that will be called when the user brushes over the area\n\t         * @param  {Function} _x Callback to call\n\t         * @return {Function | module}    Current callback function or the Chart Module\n\t         */\n\t        exports.onBrush = function (_x) {\n\t            if (!arguments.length) return onBrush;\n\t            onBrush = _x;\n\t\n\t            return this;\n\t        };\n\t\n\t        /**\n\t         * Gets or Sets the width of the chart\n\t         * @param  {number} _x Desired width for the graph\n\t         * @return { width | module} Current width or Chart module to chain calls\n\t         * @public\n\t         */\n\t        exports.width = function (_x) {\n\t            if (!arguments.length) {\n\t                return width;\n\t            }\n\t            width = _x;\n\t            return this;\n\t        };\n\t\n\t        return exports;\n\t    };\n\t}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n/***/ },\n/* 1 */\n/***/ function(module, exports) {\n\n\tmodule.exports = __WEBPACK_EXTERNAL_MODULE_1__;\n\n/***/ },\n/* 2 */,\n/* 3 */,\n/* 4 */,\n/* 5 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_RESULT__;'use strict';\n\t\n\t!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {\n\t\n\t    // Color Gradients\n\t    var britechartGradients = {\n\t        greenBlueGradient: ['#39C7EA', '#4CDCBA'],\n\t        orangePinkGradient: ['#FBC670', '#F766B8'],\n\t        bluePurpleGradient: ['#3DC3C9', '#824a9e']\n\t    };\n\t\n\t    // Color Schemas\n\t    // Standard Color Schema for Britecharts\n\t    var britechartsColorSchema = ['#6CEDC8', '#3DC3C9', '#FBC670', '#F766B8', '#998EE3', '#824a9e'];\n\t\n\t    // Grey Schema for Britecharts\n\t    var britechartsGreySchema = ['#F8F8FA', '#EFF2F5', '#D2D6DF', '#C3C6CF', '#ADB0B6', '#666A73', '#45494E', '#363A43', '#282C35'];\n\t\n\t    // Extended Orange Palette\n\t    var extendedOrangeColorSchema = ['#f9e9c5', '#fcc870', '#ffa71a', '#fb8825', '#f6682f', '#db5a2c', '#bf4c28', '#a43b1c', '#892a10'];\n\t    // Extended Blue Palette\n\t    var extendedBlueColorSchema = ['#ccf7f6', '#70e4e0', '#00d8d2', '#00acaf', '#007f8c', '#005e66', '#003c3f', '#002d2f', '#0d2223'];\n\t    // Extended LightBlue Palette\n\t    var extendedLightBlueColorSchema = ['#ccfffe', '#94f7f4', '#00fff8', '#1de1e1', '#39c2c9', '#2e9a9d', '#227270', '#1a5957', '#133f3e'];\n\t    // Extended Green Palette\n\t    var extendedGreenColorSchema = ['#edfff7', '#d7ffef', '#c0ffe7', '#95f5d7', '#6aedc7', '#59c3a3', '#479980', '#34816a', '#206953'];\n\t    // Extended Yellow Palette\n\t    var extendedYellowColorSchema = ['#f9f2b3', '#fbe986', '#fce05a', '#fed72d', '#ffce00', '#fcc11c', '#f9b438', '#eda629', '#e09819'];\n\t    // Extended Pink Palette\n\t    var extendedPinkColorSchema = ['#fdd1ea', '#fb9cd2', '#f866b9', '#fc40b6', '#ff1ab3', '#e3239d', '#c62c86', '#a62073', '#85135f'];\n\t    // Extended Purple Palette\n\t    var extendedPurpleColorSchema = ['#ddd6fc', '#bbb1f0', '#998ce3', '#8e6bc1', '#824a9e', '#77337f', '#6b1c60', '#591650', '#470f3f'];\n\t    // Extended Red Palette\n\t    var extendedRedColorSchema = ['#ffd8d4', '#ffb5b0', '#ff938c', '#ff766c', '#ff584c', '#f04b42', '#e03d38', '#be2e29', '#9c1e19'];\n\t\n\t    return {\n\t        colorSchemas: {\n\t            britechartsColorSchema: britechartsColorSchema,\n\t            britechartsGreySchema: britechartsGreySchema,\n\t            extendedOrangeColorSchema: extendedOrangeColorSchema,\n\t            extendedBlueColorSchema: extendedBlueColorSchema,\n\t            extendedLightBlueColorSchema: extendedLightBlueColorSchema,\n\t            extendedGreenColorSchema: extendedGreenColorSchema,\n\t            extendedYellowColorSchema: extendedYellowColorSchema,\n\t            extendedPinkColorSchema: extendedPinkColorSchema,\n\t            extendedPurpleColorSchema: extendedPurpleColorSchema,\n\t            extendedRedColorSchema: extendedRedColorSchema\n\t        },\n\t        colorSchemasHuman: {\n\t            'britechartsColorSchema': 'Britecharts Default',\n\t            'britechartsGreySchema': 'Britecharts Grey',\n\t            'extendedOrangeColorSchema': 'Orange',\n\t            'extendedBlueColorSchema': 'Blue',\n\t            'extendedLightBlueColorSchema': 'Light Blue',\n\t            'extendedGreenColorSchema': 'Green',\n\t            'extendedYellowColorSchema': 'Yellow',\n\t            'extendedPinkColorSchema': 'Pink',\n\t            'extendedPurpleColorSchema': 'Purple',\n\t            'extendedRedColorSchema': 'Red'\n\t        },\n\t        colorGradients: britechartGradients,\n\t        colorGradientsHuman: {\n\t            greenBlueGradient: 'Green To Blue',\n\t            orangePinkGradient: 'Orange to Pink',\n\t            bluePurpleGradient: 'Blue to Purple'\n\t        }\n\t    };\n\t}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n/***/ }\n/******/ ])\n});\n;\n\n\n// WEBPACK FOOTER //\n// brush.min.js"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap 41fa8f3a161ab8c2999f","define(function(require) {\n    'use strict';\n\n    const d3 = require('d3');\n\n    const colorHelper = require('./helpers/colors');\n\n\n    /**\n     * @typedef BrushChartData\n     * @type {Object[]}\n     * @property {Number} value        Value to chart (required)\n     * @property {Date} date           Date of the value (required)\n     *\n     * @example\n     * [\n     *     {\n     *         value: 1,\n     *         date: '2011-01-06T00:00:00Z'\n     *     },\n     *     {\n     *         value: 2,\n     *         date: '2011-01-07T00:00:00Z'\n     *     }\n     * ]\n     */\n\n    /**\n     * Brush Chart reusable API class that renders a\n     * simple and configurable brush chart.\n     *\n     * @module Brush\n     * @version 0.0.1\n     * @tutorial brush\n     * @requires d3\n     *\n     * @example\n     * let brushChart = brush();\n     *\n     * brushChart\n     *     .height(500)\n     *     .width(800);\n     *\n     * d3.select('.css-selector')\n     *     .datum(dataset)\n     *     .call(brushChart);\n     *\n     */\n    return function module() {\n\n        let margin = {top: 20, right: 20, bottom: 40, left: 20},\n            width = 960,\n            height = 500,\n            data,\n            svg,\n\n            ease = d3.easeQuadOut,\n\n            dateLabel = 'date',\n            valueLabel = 'value',\n\n            chartWidth, chartHeight,\n            xScale, yScale,\n            xAxis,\n\n            xAxisPadding = {\n                top: 0,\n                left: 0,\n                bottom: 0,\n                right: 0\n            },\n\n            brush,\n            chartBrush,\n            handle,\n\n            onBrush = null,\n\n            gradient = colorHelper.colorGradients.greenBlueGradient,\n\n            // formats\n            defaultTimeFormat = '%m/%d/%Y',\n            xTickMonthFormat = d3.timeFormat('%b'),\n\n            // extractors\n            getValue = ({value}) => value,\n            getDate = ({date}) => date;\n\n\n        /**\n         * This function creates the graph using the selection as container\n         * @param  {D3Selection} _selection A d3 selection that represents\n         *                                  the container(s) where the chart(s) will be rendered\n         * @param {BrushChartData} _data The data to attach and generate the chart\n         */\n        function exports(_selection){\n            _selection.each(function(_data){\n                chartWidth = width - margin.left - margin.right;\n                chartHeight = height - margin.top - margin.bottom;\n                data = cleanData(cloneData(_data));\n\n                buildScales();\n                buildAxis();\n                buildSVG(this);\n                buildGradient();\n                buildBrush();\n                drawArea();\n                drawAxis();\n                drawBrush();\n                drawHandles();\n\n                // This last step is optional, just needed when\n                // a given selection would need to be shown\n                setBrush(0.25, 0.5);\n            });\n        }\n\n        /**\n         * Creates the d3 x axis, setting orientation\n         * @private\n         */\n        function buildAxis(){\n            xAxis = d3.axisBottom(xScale)\n                .tickFormat(xTickMonthFormat);\n        }\n\n        /**\n         * Creates the brush element and attaches a listener\n         * @return {void}\n         */\n        function buildBrush() {\n            brush = d3.brushX()\n                .extent([[0, 0], [chartWidth, chartHeight]])\n                .on('brush', handleBrush)\n                .on('end', handleBrushEnded);\n        }\n\n        /**\n         * Builds containers for the chart, the axis and a wrapper for all of them\n         * Also applies the Margin convention\n         * @private\n         */\n        function buildContainerGroups(){\n            let container = svg.append('g')\n                .classed('container-group', true)\n                .attr('transform', `translate(${margin.left}, ${margin.top})`);\n\n            container\n              .append('g')\n                .classed('chart-group', true);\n            container\n              .append('g')\n                .classed('metadata-group', true);\n            container\n              .append('g')\n                .classed('x-axis-group', true);\n            container\n              .append('g')\n                .classed('brush-group', true);\n        }\n\n        /**\n         * Creates the gradient on the area\n         * @return {void}\n         */\n        function buildGradient() {\n            let metadataGroup = svg.select('.metadata-group');\n\n            metadataGroup.append('linearGradient')\n                .attr('id', 'brush-area-gradient')\n                .attr('gradientUnits', 'userSpaceOnUse')\n                .attr('x1', 0)\n                .attr('x2', xScale(data[data.length - 1].date))\n                .attr('y1', 0)\n                .attr('y2', 0)\n              .selectAll('stop')\n                .data([\n                    {offset: '0%', color: gradient[0]},\n                    {offset: '100%', color: gradient[1]}\n                ])\n              .enter().append('stop')\n                .attr('offset', ({offset}) => offset)\n                .attr('stop-color', ({color}) => color);\n        }\n\n        /**\n         * Creates the x and y scales of the graph\n         * @private\n         */\n        function buildScales(){\n            xScale = d3.scaleTime()\n                .domain(d3.extent(data, getDate ))\n                .range([0, chartWidth]);\n\n            yScale = d3.scaleLinear()\n                .domain([0, d3.max(data, getValue)])\n                .range([chartHeight, 0]);\n        }\n\n        /**\n         * Builds the SVG element that will contain the chart\n         * @param  {HTMLElement} container DOM element that will work as the container of the graph\n         * @private\n         */\n        function buildSVG(container){\n            if (!svg) {\n                svg = d3.select(container)\n                    .append('svg')\n                    .classed('britechart brush-chart', true);\n\n                buildContainerGroups();\n            }\n\n            svg\n                .transition()\n                .ease(ease)\n                .attr('width', width)\n                .attr('height', height);\n        }\n\n        /**\n         * Cleaning data adding the proper format\n         *\n         * @param  {BrushChartData} data Data\n         */\n        function cleanData(data) {\n            let parseDate = d3.timeParse(defaultTimeFormat);\n\n            return data.map(function (d) {\n                d.date = parseDate(d[dateLabel]);\n                d.value = +d[valueLabel];\n\n                return d;\n            });\n        }\n\n        /**\n         * Clones the passed array of data\n         * @param  {Object[]} dataToClone Data to clone\n         * @return {Object[]}             Cloned data\n         */\n        function cloneData(dataToClone) {\n            return JSON.parse(JSON.stringify(dataToClone));\n        }\n\n        /**\n         * Draws the x axis on the svg object within its group\n         *\n         * @private\n         */\n        function drawAxis(){\n            svg.select('.x-axis-group')\n              .append('g')\n                .attr('class', 'x axis')\n                .attr('transform', `translate(0, ${chartHeight})`)\n                .call(xAxis);\n        }\n\n        /**\n         * Draws the area that is going to represent the data\n         *\n         * @return {void}\n         */\n        function drawArea() {\n            // Create and configure the area generator\n            let area = d3.area()\n                .x(({date}) => xScale(date))\n                .y0(chartHeight)\n                .y1(({value}) => yScale(value))\n                .curve(d3.curveBasis);\n\n            // Create the area path\n            svg.select('.chart-group')\n              .append('path')\n                .datum(data)\n                .attr('class', 'brush-area')\n                .attr('d', area);\n        }\n\n        /**\n         * Draws the Brush components on its group\n         * @return {void}\n         */\n        function drawBrush() {\n            chartBrush = svg.select('.brush-group')\n                                .call(brush);\n\n            // Update the height of the brushing rectangle\n            chartBrush.selectAll('rect')\n                .classed('brush-rect', true)\n                .attr('height', chartHeight);\n        }\n\n        /**\n         * Draws a handle for the Brush section\n         * @return {void}\n         */\n        function drawHandles() {\n            let handleFillColor = colorHelper.colorSchemasHuman.britechartsGreySchema[1];\n\n            // Styling\n            handle = chartBrush\n                        .selectAll('.handle.brush-rect')\n                        .style('fill', handleFillColor);\n        }\n\n        /**\n         * When a brush event happens, we can extract info from the extension\n         * of the brush.\n         *\n         * @return {void}\n         */\n        function handleBrush() {\n            let s = d3.event.selection,\n                dateExtent = s.map(xScale.invert);\n\n            if (typeof onBrush === 'function') {\n                onBrush.call(null, dateExtent);\n            }\n\n            // updateHandlers(dateExtent);\n        }\n\n        /**\n         * Processes the end brush event, snapping the boundaries to days\n         * as showed on the example on https://bl.ocks.org/mbostock/6232537\n         * @return {void}\n         * @private\n         */\n        function handleBrushEnded() {\n            if (!d3.event.sourceEvent) return; // Only transition after input.\n            if (!d3.event.selection) return; // Ignore empty selections.\n\n            let d0 = d3.event.selection.map(xScale.invert),\n                d1 = d0.map(d3.timeDay.round);\n\n            // If empty when rounded, use floor & ceil instead.\n            if (d1[0] >= d1[1]) {\n                d1[0] = d3.timeDay.floor(d0[0]);\n                d1[1] = d3.timeDay.offset(d1[0]);\n            }\n\n            d3.select(this)\n                .transition()\n                .call(d3.event.target.move, d1.map(xScale));\n        }\n\n        /**\n         * Sets a new brush extent within the passed percentage positions\n         * @param {Number} a Percentage of data that the brush start with\n         * @param {Number} b Percentage of data that the brush ends with\n         */\n        function setBrush(a, b) {\n            let x0 = a * chartWidth,\n                x1 = b * chartWidth;\n\n            brush\n                .move(chartBrush, [x0, x1]);\n        }\n\n        /**\n         * Updates visibility and position of the brush handlers\n         * @param  {Number[]} dateExtent Date range\n         * @return {void}\n         */\n        function updateHandlers(dateExtent) {\n            if (dateExtent == null) {\n                handle.attr('display', 'none');\n            } else {\n                handle\n                    .attr('display', null)\n                    .attr('transform', function(d, i) {\n                        return `translate(${dateExtent[i]},${chartHeight / 2})`;\n                    });\n            }\n        }\n\n        /**\n         * Gets or Sets the gradient of the chart\n         * @param  {String[]} _x Desired gradient for the graph\n         * @return { gradient | module} Current gradient or Chart module to chain calls\n         * @public\n         */\n        exports.gradient = function(_x) {\n            if (!arguments.length) {\n                return gradient;\n            }\n            gradient = _x;\n            return this;\n        };\n\n        /**\n         * Gets or Sets the height of the chart\n         * @param  {number} _x Desired width for the graph\n         * @return { height | module} Current height or Chart module to chain calls\n         * @public\n         */\n        exports.height = function(_x) {\n            if (!arguments.length) {\n                return height;\n            }\n            height = _x;\n            return this;\n        };\n\n        /**\n         * Gets or Sets the margin of the chart\n         * @param  {object} _x Margin object to get/set\n         * @return { margin | module} Current margin or Chart module to chain calls\n         * @public\n         */\n        exports.margin = function(_x) {\n            if (!arguments.length) {\n                return margin;\n            }\n            margin = _x;\n            return this;\n        };\n\n        /**\n         * Gets or Sets the callback that will be called when the user brushes over the area\n         * @param  {Function} _x Callback to call\n         * @return {Function | module}    Current callback function or the Chart Module\n         */\n        exports.onBrush = function(_x) {\n            if (!arguments.length) return onBrush;\n            onBrush = _x;\n\n            return this;\n        };\n\n        /**\n         * Gets or Sets the width of the chart\n         * @param  {number} _x Desired width for the graph\n         * @return { width | module} Current width or Chart module to chain calls\n         * @public\n         */\n        exports.width = function(_x) {\n            if (!arguments.length) {\n                return width;\n            }\n            width = _x;\n            return this;\n        };\n\n        return exports;\n    };\n\n});\n\n\n\n// WEBPACK FOOTER //\n// ./src/charts/brush.js","module.exports = __WEBPACK_EXTERNAL_MODULE_1__;\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"d3\"\n// module id = 1\n// module chunks = 0 1 2 3 4 5 6 7 8 9","define(function(require) {\n\n    // Color Gradients\n    const britechartGradients = {\n            greenBlueGradient: ['#39C7EA', '#4CDCBA'],\n            orangePinkGradient: ['#FBC670', '#F766B8'],\n            bluePurpleGradient: ['#3DC3C9', '#824a9e']\n        };\n\n    // Color Schemas\n    // Standard Color Schema for Britecharts\n    const britechartsColorSchema = [\n            '#6CEDC8',\n            '#3DC3C9',\n            '#FBC670',\n            '#F766B8',\n            '#998EE3',\n            '#824a9e'\n        ];\n\n    // Grey Schema for Britecharts\n    const britechartsGreySchema = [\n            '#F8F8FA',\n            '#EFF2F5',\n            '#D2D6DF',\n            '#C3C6CF',\n            '#ADB0B6',\n            '#666A73',\n            '#45494E',\n            '#363A43',\n            '#282C35'\n        ];\n\n    // Extended Orange Palette\n    const extendedOrangeColorSchema = [\n            '#f9e9c5',\n            '#fcc870',\n            '#ffa71a',\n            '#fb8825',\n            '#f6682f',\n            '#db5a2c',\n            '#bf4c28',\n            '#a43b1c',\n            '#892a10'\n        ];\n    // Extended Blue Palette\n    const extendedBlueColorSchema = [\n            '#ccf7f6',\n            '#70e4e0',\n            '#00d8d2',\n            '#00acaf',\n            '#007f8c',\n            '#005e66',\n            '#003c3f',\n            '#002d2f',\n            '#0d2223'\n        ];\n    // Extended LightBlue Palette\n    const extendedLightBlueColorSchema = [\n            '#ccfffe',\n            '#94f7f4',\n            '#00fff8',\n            '#1de1e1',\n            '#39c2c9',\n            '#2e9a9d',\n            '#227270',\n            '#1a5957',\n            '#133f3e'\n        ];\n    // Extended Green Palette\n    const extendedGreenColorSchema = [\n            '#edfff7',\n            '#d7ffef',\n            '#c0ffe7',\n            '#95f5d7',\n            '#6aedc7',\n            '#59c3a3',\n            '#479980',\n            '#34816a',\n            '#206953'\n        ];\n    // Extended Yellow Palette\n    const extendedYellowColorSchema = [\n            '#f9f2b3',\n            '#fbe986',\n            '#fce05a',\n            '#fed72d',\n            '#ffce00',\n            '#fcc11c',\n            '#f9b438',\n            '#eda629',\n            '#e09819'\n        ];\n    // Extended Pink Palette\n    const extendedPinkColorSchema = [\n            '#fdd1ea',\n            '#fb9cd2',\n            '#f866b9',\n            '#fc40b6',\n            '#ff1ab3',\n            '#e3239d',\n            '#c62c86',\n            '#a62073',\n            '#85135f'\n        ];\n    // Extended Purple Palette\n    const extendedPurpleColorSchema = [\n            '#ddd6fc',\n            '#bbb1f0',\n            '#998ce3',\n            '#8e6bc1',\n            '#824a9e',\n            '#77337f',\n            '#6b1c60',\n            '#591650',\n            '#470f3f'\n        ];\n    // Extended Red Palette\n    const extendedRedColorSchema = [\n            '#ffd8d4',\n            '#ffb5b0',\n            '#ff938c',\n            '#ff766c',\n            '#ff584c',\n            '#f04b42',\n            '#e03d38',\n            '#be2e29',\n            '#9c1e19'\n        ];\n\n    return {\n        colorSchemas: {\n            britechartsColorSchema,\n            britechartsGreySchema,\n            extendedOrangeColorSchema,\n            extendedBlueColorSchema,\n            extendedLightBlueColorSchema,\n            extendedGreenColorSchema,\n            extendedYellowColorSchema,\n            extendedPinkColorSchema,\n            extendedPurpleColorSchema,\n            extendedRedColorSchema\n        },\n        colorSchemasHuman: {\n            'britechartsColorSchema': 'Britecharts Default',\n            'britechartsGreySchema': 'Britecharts Grey',\n            'extendedOrangeColorSchema': 'Orange',\n            'extendedBlueColorSchema': 'Blue',\n            'extendedLightBlueColorSchema': 'Light Blue',\n            'extendedGreenColorSchema': 'Green',\n            'extendedYellowColorSchema': 'Yellow',\n            'extendedPinkColorSchema': 'Pink',\n            'extendedPurpleColorSchema': 'Purple',\n            'extendedRedColorSchema': 'Red'\n        },\n        colorGradients: britechartGradients,\n        colorGradientsHuman: {\n            greenBlueGradient: 'Green To Blue',\n            orangePinkGradient: 'Orange to Pink',\n            bluePurpleGradient: 'Blue to Purple'\n        }\n    };\n});\n\n\n\n// WEBPACK FOOTER //\n// ./src/charts/helpers/colors.js"],"sourceRoot":""}